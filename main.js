'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

global.RECIPES = {};
for (const a in REACTIONS) {
    for (const b in REACTIONS[a]) {
        global.RECIPES[REACTIONS[a][b]] = [a, b];
    }
}
global.BOOST_TO_BODYPART = {};
for (let bodypart in BOOSTS)
    for (let boost in BOOSTS[bodypart])
        global.BOOST_TO_BODYPART[boost] = bodypart;
global.BOOST_TO_TIER = {};
let boostNameLengthToTier = {
    2: 1,
    4: 2,
    5: 3
};
for (let bodypart in BOOSTS)
    for (let boost in BOOSTS[bodypart])
        global.BOOST_TO_TIER[boost] = boostNameLengthToTier[boost.length];
global.RES_ENERGY = RESOURCE_ENERGY;
global.RES_POWER = RESOURCE_POWER;
global.RES_OPS = RESOURCE_OPS;
global.RES_H = RESOURCE_HYDROGEN;
global.RES_O = RESOURCE_OXYGEN;
global.RES_U = RESOURCE_UTRIUM;
global.RES_L = RESOURCE_LEMERGIUM;
global.RES_K = RESOURCE_KEANIUM;
global.RES_Z = RESOURCE_ZYNTHIUM;
global.RES_X = RESOURCE_CATALYST;
global.RES_G = RESOURCE_GHODIUM;
global.RES_OH = RESOURCE_HYDROXIDE;
global.RES_ZK = RESOURCE_ZYNTHIUM_KEANITE;
global.RES_UL = RESOURCE_UTRIUM_LEMERGITE;
global.RES_UH = RESOURCE_UTRIUM_HYDRIDE;
global.RES_UO = RESOURCE_UTRIUM_OXIDE;
global.RES_KH = RESOURCE_KEANIUM_HYDRIDE;
global.RES_KO = RESOURCE_KEANIUM_OXIDE;
global.RES_LH = RESOURCE_LEMERGIUM_HYDRIDE;
global.RES_LO = RESOURCE_LEMERGIUM_OXIDE;
global.RES_ZH = RESOURCE_ZYNTHIUM_HYDRIDE;
global.RES_ZO = RESOURCE_ZYNTHIUM_OXIDE;
global.RES_GH = RESOURCE_GHODIUM_HYDRIDE;
global.RES_GO = RESOURCE_GHODIUM_OXIDE;
global.RES_UH2O = RESOURCE_UTRIUM_ACID;
global.RES_UHO2 = RESOURCE_UTRIUM_ALKALIDE;
global.RES_KH2O = RESOURCE_KEANIUM_ACID;
global.RES_KHO2 = RESOURCE_KEANIUM_ALKALIDE;
global.RES_LH2O = RESOURCE_LEMERGIUM_ACID;
global.RES_LHO2 = RESOURCE_LEMERGIUM_ALKALIDE;
global.RES_ZH2O = RESOURCE_ZYNTHIUM_ACID;
global.RES_ZHO2 = RESOURCE_ZYNTHIUM_ALKALIDE;
global.RES_GH2O = RESOURCE_GHODIUM_ACID;
global.RES_GHO2 = RESOURCE_GHODIUM_ALKALIDE;
global.RES_XUH2O = RESOURCE_CATALYZED_UTRIUM_ACID;
global.RES_XUHO2 = RESOURCE_CATALYZED_UTRIUM_ALKALIDE;
global.RES_XKH2O = RESOURCE_CATALYZED_KEANIUM_ACID;
global.RES_XKHO2 = RESOURCE_CATALYZED_KEANIUM_ALKALIDE;
global.RES_XLH2O = RESOURCE_CATALYZED_LEMERGIUM_ACID;
global.RES_XLHO2 = RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE;
global.RES_XZH2O = RESOURCE_CATALYZED_ZYNTHIUM_ACID;
global.RES_XZHO2 = RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE;
global.RES_XGH2O = RESOURCE_CATALYZED_GHODIUM_ACID;
global.RES_XGHO2 = RESOURCE_CATALYZED_GHODIUM_ALKALIDE;
global.COMPOUNDS_ALL = [
    RESOURCE_GHODIUM,
    RESOURCE_UTRIUM_LEMERGITE,
    RESOURCE_ZYNTHIUM_KEANITE,
    RESOURCE_HYDROXIDE,
    //
    RESOURCE_UTRIUM_HYDRIDE,
    RESOURCE_UTRIUM_OXIDE,
    RESOURCE_KEANIUM_HYDRIDE,
    RESOURCE_KEANIUM_OXIDE,
    RESOURCE_LEMERGIUM_HYDRIDE,
    RESOURCE_LEMERGIUM_OXIDE,
    RESOURCE_ZYNTHIUM_HYDRIDE,
    RESOURCE_ZYNTHIUM_OXIDE,
    RESOURCE_GHODIUM_HYDRIDE,
    RESOURCE_GHODIUM_OXIDE,
    //
    RESOURCE_UTRIUM_ACID,
    RESOURCE_UTRIUM_ALKALIDE,
    RESOURCE_KEANIUM_ACID,
    RESOURCE_KEANIUM_ALKALIDE,
    RESOURCE_LEMERGIUM_ACID,
    RESOURCE_LEMERGIUM_ALKALIDE,
    RESOURCE_ZYNTHIUM_ACID,
    RESOURCE_ZYNTHIUM_ALKALIDE,
    RESOURCE_GHODIUM_ACID,
    RESOURCE_GHODIUM_ALKALIDE,
    //
    RESOURCE_CATALYZED_UTRIUM_ACID,
    RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
    RESOURCE_CATALYZED_KEANIUM_ACID,
    RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
    RESOURCE_CATALYZED_LEMERGIUM_ACID,
    RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
    RESOURCE_CATALYZED_ZYNTHIUM_ACID,
    RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
    RESOURCE_CATALYZED_GHODIUM_ACID,
    RESOURCE_CATALYZED_GHODIUM_ALKALIDE
];
global.DIRECTIONS_ALL = [
    TOP,
    TOP_RIGHT,
    RIGHT,
    BOTTOM_RIGHT,
    BOTTOM,
    BOTTOM_LEFT,
    LEFT,
    TOP_LEFT
];
global.MARKET_RESOURCES_ALL = [
    ...RESOURCES_ALL,
    SUBSCRIPTION_TOKEN,
    CPU_UNLOCK,
    PIXEL,
    ACCESS_KEY
];
global.RESOURCE_COLORS = {
    energy: '#FEE476',
    battery: '#FEE476',
    power: '#F1243A',
    H: '#989898',
    O: '#989898',
    U: '#48C5E5',
    L: '#24D490',
    K: '#9269EC',
    Z: '#D9B478',
    X: '#F26D6F',
    reductant: '#989898',
    oxidant: '#989898',
    utrium_bar: '#48C5E5',
    lemergium_bar: '#24D490',
    keanium_bar: '#9269EC',
    zynthium_bar: '#D9B478',
    purifier: '#F26D6F',
    OH: '#B4B4B4',
    ZK: '#B4B4B4',
    UL: '#B4B4B4',
    G: '#FFFFFF',
    ghodium_melt: '#FFFFFF',
    composite: '#FFFFFF',
    crystal: '#FFFFFF',
    liquid: '#FFFFFF',
    UH: '#50D7F9',
    UO: '#50D7F9',
    KH: '#A071FF',
    KO: '#A071FF',
    LH: '#00F4A2',
    LO: '#00F4A2',
    ZH: '#FDD388',
    ZO: '#FDD388',
    GH: '#FFFFFF',
    GO: '#FFFFFF',
    UH2O: '#50D7F9',
    UHO2: '#50D7F9',
    KH2O: '#A071FF',
    KHO2: '#A071FF',
    LH2O: '#00F4A2',
    LHO2: '#00F4A2',
    ZH2O: '#FDD388',
    ZHO2: '#FDD388',
    GH2O: '#FFFFFF',
    GHO2: '#FFFFFF',
    XUH2O: '#50D7F9',
    XUHO2: '#50D7F9',
    XKH2O: '#A071FF',
    XKHO2: '#A071FF',
    XLH2O: '#00F4A2',
    XLHO2: '#00F4A2',
    XZH2O: '#FDD388',
    XZHO2: '#FDD388',
    XGH2O: '#FFFFFF',
    XGHO2: '#FFFFFF',
    metal: '#956F5C',
    alloy: '#956F5C',
    tube: '#956F5C',
    fixtures: '#956F5C',
    frame: '#956F5C',
    hydraulics: '#956F5C',
    machine: '#956F5C',
    biomass: '#84B012',
    cell: '#84B012',
    phlegm: '#84B012',
    tissue: '#84B012',
    muscle: '#84B012',
    organoid: '#84B012',
    organism: '#84B012',
    silicon: '#4DA7E5',
    wire: '#4DA7E5',
    switch: '#4DA7E5',
    transistor: '#4DA7E5',
    microchip: '#4DA7E5',
    circuit: '#4DA7E5',
    device: '#4DA7E5',
    mist: '#DA6BF5',
    condensate: '#DA6BF5',
    concentrate: '#DA6BF5',
    extract: '#DA6BF5',
    spirit: '#DA6BF5',
    emanation: '#DA6BF5',
    essence: '#DA6BF5',
    ops: '#FFFF00',
    token: '#FF00FF',
    accessKey: '#47B165',
    cpuUnlock: '#90872F',
    pixel: '#FF7378'
};
global.ERROR_STR = {
    [OK]: 'OK',
    [ERR_NOT_OWNER]: 'ERR_NOT_OWNER',
    [ERR_NO_PATH]: 'ERR_NO_PATH',
    [ERR_NAME_EXISTS]: 'ERR_NAME_EXISTS',
    [ERR_BUSY]: 'ERR_BUSY',
    [ERR_NOT_FOUND]: 'ERR_NOT_FOUND',
    [ERR_NOT_ENOUGH_RESOURCES]: 'ERR_NOT_ENOUGH_RESOURCES',
    [ERR_INVALID_TARGET]: 'ERR_INVALID_TARGET',
    [ERR_FULL]: 'ERR_FULL',
    [ERR_NOT_IN_RANGE]: 'ERR_NOT_IN_RANGE',
    [ERR_INVALID_ARGS]: 'ERR_INVALID_ARGS',
    [ERR_TIRED]: 'ERR_TIRED',
    [ERR_NO_BODYPART]: 'ERR_NO_BODYPART',
    [ERR_RCL_NOT_ENOUGH]: 'ERR_RCL_NOT_ENOUGH',
    [ERR_GCL_NOT_ENOUGH]: 'ERR_GCL_NOT_ENOUGH'
};
global.ROOM_ENERGY_CAPACITY = _.mapValues(EXTENSION_ENERGY_CAPACITY, (extensionCapacity, rcl) => extensionCapacity * CONTROLLER_STRUCTURES.extension[rcl] + SPAWN_ENERGY_CAPACITY * CONTROLLER_STRUCTURES.spawn[rcl]);
global.RANGED_MASS_ATTACK_POWER = [10, 10, 4, 1];
global.RANGED_ATTACK_RANGE = 3;
global.ATTACK_RANGE = 1;
global.OBSTACLE_STRUCTURE_TYPES = new Set(OBSTACLE_OBJECT_TYPES);

const COPS = [
    "ART999",
    "Aundine",
    "ben2",
    "demawi",
    "DomNomNom",
    "Fritee",
    "iceburg",
    "ICED_COFFEE",
    "Jibol",
    "Jumpp",
    "Kotarou",
    "Montblanc",
    "mute",
    "o4kapuk",
    //"Robalian",
    "shadow_bird",
    "szumi",
    "TheCreepz",
    "ThyReaper",
    "TiffanyTrump",
    "Xist",
    "Xolym"
];
const MMO_ALLIES = [
    'Creature',
    'FeldonDragon'
];
const MMO_NEUTRAL = [
    'TuN9aN0',
    'Sergey',
    'qnz',
    'zGeneral',
    ...COPS
];
const ALLIES_PER_SHARD = {
    shard2: MMO_ALLIES,
    shard3: MMO_ALLIES,
    swc: ['Modus', 'Lord Greywether', 'MarvinTMB', 'Kalgen']
};
const NEUTRAL_PER_SHARD = {
    shard2: MMO_NEUTRAL,
    shard3: MMO_NEUTRAL
};
const EMBARGO_PER_SHARD = {
    swc: []
};
class Config {
}
Config.segments = {
    harassResults: 97,
    swcSimpleProtocol: 90,
    stats: 99
};
//
Config.ALLIES = new Set([...(ALLIES_PER_SHARD[Game.shard.name] || [])]);
Config.NEUTRAL = new Set([...(NEUTRAL_PER_SHARD[Game.shard.name] || [])].filter(n => !Config.ALLIES.has(n)));
Config.WHITELIST = new Set([...Config.ALLIES, ...Config.NEUTRAL]);
Config.RAMPART_PASSAGE = new Set([]);
Config.EMBARGO = new Set([...(EMBARGO_PER_SHARD[Game.shard.name] || [])]);
//
Config.hasMarket = !['sim', 'shardSeason'].includes(Game.shard.name);
Config.isPixelsShard = ['shard2', 'shard3'].includes(Game.shard.name);
Config.isFastShard = ['botarena', 'swc', 'screepsplus2'].includes(Game.shard.name);
Config.defaultToggles = {
    autoclaim: true,
    autoharass: true,
    autoattack: true,
    autoBoostedAttack: true,
    harvestPower: false,
    useGH: false,
    processPower: false,
    forceCpuSaving: false,
    usePrimitiveRampartOpening: false,
    tradeWithPlayers: true,
    buildFactory: !['botarena', 'swc'].includes(Game.shard.name),
    pickupInvaderLoot: true,
    debugStats: false,
    logSkippingTicks: true,
    logStatsFlatten: false,
    logRebalance: false,
    logDistributionCPU: false,
    logFailedPathfinding: false,
    logMarketDebug: false,
    logPathfindingDebug: false,
    visual: false,
    visualRoomPlan: false,
    visualSpawnQueue: false,
    visualPathfinding: false,
    visualAttackableRooms: false,
    swcCooperation: false,
    swcAllowFunnel: false,
    swcCooperationLog: false
};
Config.CreepNames = {
    Hauler: 'Hauler',
    Miner: 'Miner',
    Builder: 'Builder',
    Upgrader: 'Upgrader',
    Repairer: 'Repairer',
    Reinforcer: 'Reinforcer',
    Harasser: 'Harasser',
    Swarmling: 'Swarmling',
    Distributor: 'Distributor',
    Guard: 'Guard',
    Hitter: 'HitTer',
    Declaimer: 'Declaimer',
    Claimer: 'Claimer',
    Scout: 'Scout',
    MineralMiner: 'MineralMiner',
    Reserver: 'Reserver',
    Salvager: 'Scavenger',
    KeeperSlayer: 'KeeperSlayer',
    DepositMiner: 'Harvester',
    DrillHead: 'DrillHead',
    DrillTail: 'DrillTail',
    Unpoisoner: 'Cleanser',
    DuoHead: 'DuoHead',
    DuoTail: 'DuoTail'
};
Config.TARGET_STOCK = {
    energy: { storage: 400000, terminal: 50000 },
    power: { storage: 5000, terminal: 3000 },
    ops: { storage: 3000, terminal: 3000 },
    //
    metal: { storage: 300, terminal: 3000 },
    biomass: { storage: 300, terminal: 3000 },
    silicon: { storage: 300, terminal: 3000 },
    mist: { storage: 300, terminal: 3000 },
    //
    O: { storage: 15000, terminal: 3000 },
    H: { storage: 15000, terminal: 3000 },
    U: { storage: 15000, terminal: 3000 },
    K: { storage: 15000, terminal: 3000 },
    L: { storage: 15000, terminal: 3000 },
    Z: { storage: 15000, terminal: 3000 },
    X: { storage: 15000, terminal: 3000 },
    G: { storage: 8000, terminal: 3000 },
    //
    UL: { storage: 3000, terminal: 3000 },
    ZK: { storage: 3000, terminal: 3000 },
    OH: { storage: 3000, terminal: 3000 },
    //
    UH: { storage: 9000, terminal: 3000 },
    KO: { storage: 9000, terminal: 3000 },
    LH: { storage: 9000, terminal: 3000 },
    LO: { storage: 9000, terminal: 3000 },
    ZH: { storage: 9000, terminal: 3000 },
    ZO: { storage: 9000, terminal: 3000 },
    GH: { storage: 9000, terminal: 3000 },
    GO: { storage: 9000, terminal: 3000 },
    //
    UH2O: { storage: 9000, terminal: 3000 },
    KHO2: { storage: 9000, terminal: 3000 },
    LH2O: { storage: 9000, terminal: 3000 },
    LHO2: { storage: 9000, terminal: 3000 },
    ZH2O: { storage: 9000, terminal: 3000 },
    ZHO2: { storage: 9000, terminal: 3000 },
    GH2O: { storage: 9000, terminal: 3000 },
    GHO2: { storage: 9000, terminal: 3000 },
    //
    XUH2O: { storage: 18000, terminal: 3000 },
    XKHO2: { storage: 18000, terminal: 3000 },
    XLH2O: { storage: 18000, terminal: 3000 },
    XLHO2: { storage: 18000, terminal: 3000 },
    XZH2O: { storage: 18000, terminal: 3000 },
    XZHO2: { storage: 18000, terminal: 3000 },
    XGH2O: { storage: 18000, terminal: 3000 },
    XGHO2: { storage: 18000, terminal: 3000 }
};
Config.BOOST_PRIORITY = [
    // combat boosts and their component
    [
        RES_XGHO2, RES_XKHO2, RES_XLHO2, RES_XZHO2,
        RES_GHO2, RES_KHO2, RES_LHO2, RES_ZHO2,
        RES_OH,
        RES_G, RES_ZK, RES_UL, RES_KO, RES_LO, RES_ZO, RES_GO //, RES_ZH
    ],
    // eco and defense
    [RES_XLH2O, RES_XUH2O, RES_UH2O, RES_LH2O, RES_LH, RES_UH],
    // Upgrade
    [RES_XGH2O],
    [RES_GH2O],
    [RES_GH]
];
Config.TERMINAL_STORAGE_IGNORE_THRESHOLD = 2400;
Config.NUKER_LOADING_ENERGY_THRESHOLD = 200000;
Config.POWER_PROCESSING_ENERGY_THRESHOLD = 300000;
Config.ROOM_STATS_PERIOD = 1500;
Config.ROOM_SPREAD_MIN = 1;
Config.ROOM_SPREAD_PREFERRED = 4;
Config.ROOM_SPREAD_MAX = 7;
Config.operateSpawnOperations = [
    'FlagOperationHitSquad',
    'OperationHitSquad',
    'OperationBuildSupport',
    'OperationDefend',
    'OperationSupply',
    'OperationGuard'
];

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

var TraceEventPhase;
(function (TraceEventPhase) {
    TraceEventPhase["Start"] = "B";
    TraceEventPhase["End"] = "E";
})(TraceEventPhase || (TraceEventPhase = {}));
class Profiler {
    static get wrappedFunctions() { return Profiler._wrappedFunctions; }
    static get list() {
        return Profiler._list;
    }
    static get cpuByCategory() {
        return Profiler._cpuByCategory;
    }
    static get nonTickCpu() {
        return this._nonTickCpu;
    }
    // ---------------------------------------------------------------------
    static push(name, functionType = "Other" /* ProfilerFunctionType.Other */) {
        this.callStack.push({
            name: name,
            startValue: Game.cpu.getUsed(),
            functionType: functionType
        });
        if (this.tracingTicksLeft > 0) {
            this.events.push({
                name: name,
                ph: TraceEventPhase.Start,
                pid: 0,
                tid: Game.time,
                ts: Game.cpu.getUsed() * 1000
            });
            this.events.push({
                name: name,
                ph: TraceEventPhase.Start,
                pid: 0,
                tid: 0,
                ts: Game.cpu.getUsed() * 1000 + this.tracingCpuOffset
            });
        }
    }
    static pop() {
        let call = _.last(this.callStack);
        let value = Game.cpu.getUsed() - call.startValue;
        let stat = this.data;
        //
        for (let callStackElem of this.callStack) {
            let statIndex = stat.subnodes.findIndex((node) => node.name === callStackElem.name);
            if (statIndex === -1) {
                stat.subnodes.push({
                    name: callStackElem.name,
                    value: 0,
                    count: 0,
                    subnodes: [],
                    functionType: callStackElem.functionType
                });
                statIndex = stat.subnodes.length - 1;
            }
            stat = stat.subnodes[statIndex];
        }
        //
        stat.value += value;
        ++stat.count;
        this.callStack.pop();
        if (this.tracingTicksLeft > 0) {
            this.events.push({
                name: call.name,
                ph: TraceEventPhase.End,
                pid: 0,
                tid: Game.time,
                ts: Game.cpu.getUsed() * 1000,
                args: undefined
            });
            this.events.push({
                name: call.name,
                ph: TraceEventPhase.End,
                pid: 0,
                tid: 0,
                ts: Game.cpu.getUsed() * 1000 + this.tracingCpuOffset,
                args: undefined
            });
        }
    }
    static profile(functionType = "Other" /* ProfilerFunctionType.Other */) {
        return function (target, propertyKey, descriptor) {
            let ctor = target;
            const className = !ctor.prototype
                ? ctor.constructor.name
                : ctor.prototype.constructor.name;
            if (propertyKey === 'constructor')
                return;
            let original = descriptor.value;
            if (!original || !_.isFunction(original))
                return;
            var fullName = className + '::' + propertyKey;
            if (fullName in Profiler._wrappedFunctions)
                return;
            descriptor.value = function (...args) {
                Profiler.push(fullName, functionType);
                const result = original.apply(this, args);
                Profiler.pop();
                return result;
            };
            Profiler._wrappedFunctions[fullName] = original;
        };
    }
    static serializeTraceEvents() {
        const serial = JSON.stringify(this.events);
        this.tracingCpuOffset = _.last(this.events).ts;
        this.events = [];
        if (this.serializedEvents.length > 0) {
            this.serializedEvents += ',';
        }
        this.serializedEvents += serial.substring(1, serial.length - 1);
    }
    // might not work in updated browsers, works in steam client
    static downloadTrace() {
        const code = 'Download trace hook <script>' +
            `(() => {` +
            `angular.element("section.console").scope().Console.clear();` +
            `var filename = 'trace.json';` +
            `var text = JSON.stringify({ traceEvents: [${this.serializedEvents}], displayTimeUnit: 'ms'});` +
            `const element = document.createElement('input');` +
            `element.nwsaveas = 'trace.json';` +
            `element.type='file';` +
            `document.body.appendChild(element);` +
            `element.click();` +
            `document.body.removeChild(element);` +
            `element.addEventListener('change', () => {` +
            `    const fs = nw.require('fs');` +
            `    fs.writeFileSync(element.value, text);` +
            `});` +
            `})();` +
            `</script>`;
        console.log(code.replace("\n", ""));
    }
    // ---------------------------------------------------------------------
    static preTick() {
        this.data = {
            name: '',
            value: Game.cpu.getUsed(),
            count: 1,
            subnodes: [],
            functionType: "Other" /* ProfilerFunctionType.Other */
        };
        this.callStack.length = 0;
        this._nonTickCpu = (this.expectedBucket || Game.cpu.bucket) - Game.cpu.bucket;
        //
        this.push('Main::Main');
    }
    static postTick() {
        this.pop();
        let finalizeStartCpu = Game.cpu.getUsed();
        let memoryParsingCPU = this.data.value;
        // Main::Main
        this.data.value = Game.cpu.getUsed() - this.data.value;
        //
        // flatten
        this._list = {};
        this._cpuByCategory = {};
        let iterations = 0;
        let toProcess = this.data.subnodes;
        while (toProcess.length > 0) {
            ++iterations;
            let node = toProcess.pop();
            for (let subnode of node.subnodes) {
                node.value -= subnode.value;
                toProcess.push(subnode);
            }
            this.list[node.name] = this.list[node.name] || {
                calls: 0,
                cpu: 0
            };
            this._cpuByCategory[node.functionType] = this._cpuByCategory[node.functionType] || 0;
            this.list[node.name].cpu += node.value;
            this.list[node.name].calls += node.count;
            this._cpuByCategory[node.functionType] += node.value;
        }
        // trace
        if (this.tracingTicksLeft > 0) {
            --this.tracingTicksLeft;
            this.serializeTraceEvents();
            if (this.tracingTicksLeft === 0) {
                this.downloadTrace();
                this.events = [];
                this.serializedEvents = '';
            }
            else {
                console.log(`Tracing ${this.tracingTicksLeft}...`);
            }
        }
        //
        this._cpuByCategory["MemoryParsing" /* ProfilerFunctionType.MemoryParsing */] = memoryParsingCPU;
        this._cpuByCategory["NonTick" /* ProfilerFunctionType.NonTick */] = this._nonTickCpu;
        this._cpuByCategory["Profiling" /* ProfilerFunctionType.Profiling */] = Game.cpu.getUsed() - finalizeStartCpu;
        //
        if (Memory.toggles.logStatsFlatten)
            console.log('Stats data length:', _.size(this.list), 'iterations:', iterations);
        //
        if (Game.cpu.bucket === 10000 && Config.isPixelsShard) {
            Game.cpu.generatePixel();
            this.expectedBucket = Math.min(Game.cpu.bucket - Game.cpu.getUsed() + Game.cpu.limit - PIXEL_CPU_COST, 10000);
        }
        else {
            this.expectedBucket = Math.min(Game.cpu.bucket - Game.cpu.getUsed() + Game.cpu.limit, 10000);
        }
    }
    // ---------------------------------------------------------------------
    static trace(ticks) {
        this.tracingTicksLeft = ticks;
        this.events = [];
        this.serializedEvents = '';
        this.tracingCpuOffset = 0;
    }
}
Profiler._wrappedFunctions = {};
Profiler._list = {};
Profiler.callStack = [];
//
Profiler.tracingTicksLeft = 0;
Profiler.tracingCpuOffset = 0;
Profiler.serializedEvents = '';
Profiler.events = [];
const profile = Profiler.profile;
// for access from console
global.profiler = Profiler;

Number.prototype.mod = function (n) {
    return ((this.valueOf() % n) + n) % n;
};
// Engine code sometimes iterates over arrays using for .. in
// Array.prototype.last = function()
//   {
//   return this[this.length-1];
//   };
Math.clamp = function (value, min, max) {
    return Math.min(Math.max(value, min), max);
};
PathFinder.CostMatrix.prototype.setArea = function (pos, range, value) {
    let left = Math.max(0, pos.x - range);
    let top = Math.max(0, pos.y - range);
    let right = Math.min(49, pos.x + range);
    let bottom = Math.min(49, pos.y + range);
    let terrain = Game.map.getRoomTerrain(pos.roomName);
    for (let x = left; x <= right; ++x)
        for (let y = top; y <= bottom; ++y)
            if ((terrain.get(x, y) & TERRAIN_MASK_WALL) === 0) {
                let currentValue = this.get(x, y);
                this.set(x, y, Math.max(currentValue, value));
            }
};
function check(obj, key, descriptor) {
    let original = descriptor.value;
    if (!original || typeof original !== "function")
        return;
    descriptor.value = function (...args) {
        try {
            let result = original.apply(this, args);
            return result;
        }
        catch (err) {
            console.log('<font color="#ff5555" type="highlight">', (err
                ? err instanceof Error
                    ? err.stack
                    : err
                : 'unknown error'), '</font>');
        }
    };
}
function errGuard(foo) {
    try {
        foo();
    }
    catch (err) {
        console.log('<font color="#ff5555" type="highlight">', (err
            ? err instanceof Error
                ? err.stack
                : err
            : 'unknown error'), '</font>');
    }
}
function getUsername() {
    if (_.size(Game.spawns) > 0)
        return _.find(Game.spawns).owner.username;
    if (_.size(Game.creeps) > 0)
        return _.find(Game.creeps).owner.username;
    if (_.size(Game.powerCreeps) > 0)
        return _.find(Game.powerCreeps).owner.username;
    if (_.size(Game.structures) > 0)
        return _.find(Game.structures).owner.username;
    if (_.size(Game.constructionSites) > 0)
        return _.find(Game.constructionSites).owner.username;
    return 'Robalian';
}
class Common {
    // ---------------------------------------------------------------------
    static getTickDuration() {
        return Memory.tickDuration.value;
    }
    static getRoomVisual(roomName) {
        if (!this.visualCache)
            this.visualCache = {};
        if (!this.visualCache[roomName] || this.visualCache[roomName].tick < Game.time) {
            this.visualCache[roomName] = {
                visual: (Game.rooms[roomName] ? Game.rooms[roomName].visual : new RoomVisual(roomName)),
                tick: Game.time
            };
        }
        return this.visualCache[roomName].visual;
    }
    static getOppositeDir(dir) {
        return ((dir + 3) % 8 + 1);
    }
    static getRandomDir() {
        return (Math.floor(Math.random() * 8) + 1);
    }
    colorToDir(color) {
        color = (color <= 8 ? color : COLOR_RED);
        return (color);
    }
    dirToColor(dir) {
        return (dir);
    }
    // ---------------------------------------------------------------------
    static findRoomsInRange(roomName, range) {
        let result = [];
        const startRoomStatus = Game.map.getRoomStatus(roomName).status;
        let nodes = [{
                roomName: roomName,
                depth: 0
            }];
        do {
            let node = nodes.shift();
            let exits = Game.map.describeExits(node.roomName);
            for (let exitName in exits) {
                let exit = exits[exitName];
                let newNode = {
                    roomName: exit,
                    depth: node.depth + 1
                };
                if (newNode.roomName === roomName)
                    continue;
                if (newNode.depth > range)
                    continue;
                if (result.includes(newNode.roomName))
                    continue;
                if (Game.map.getRoomStatus(newNode.roomName).status !== startRoomStatus)
                    continue;
                result.push(newNode.roomName);
                nodes.push(newNode);
            }
        } while (nodes.length > 0);
        return result;
    }
    // ---------------------------------------------------------------------
    static getRoomCoords(roomName) {
        let parsed = /^[WE]([0-9]+)[NS]([0-9]+)$/.exec(roomName);
        // simulation room
        if (!parsed)
            return {
                x: 1,
                y: 1
            };
        return {
            x: parseInt(parsed[1]),
            y: parseInt(parsed[2])
        };
    }
    static getRoomSector(roomName) {
        return roomName.replace(/^([WE][0-9]*)([0-9])([NS][0-9]*)([0-9])$/, '$10$30');
    }
    static getNextRoom(roomName, dir) {
        return Game.map.describeExits(roomName)[dir];
    }
    static isCenterRoom(roomName) {
        let pos = this.getRoomCoords(roomName);
        let x = pos.x % 10;
        let y = pos.y % 10;
        return (x >= 4 && x <= 6) && (y >= 4 && y <= 6);
    }
    static isPortalRoom(roomName) {
        let pos = this.getRoomCoords(roomName);
        return (pos.x % 10 === 5 && pos.y % 10 === 5);
    }
    static isSkRoom(roomName) {
        let pos = this.getRoomCoords(roomName);
        let x = pos.x % 10;
        let y = pos.y % 10;
        return (x >= 4 && x <= 6) && (y >= 4 && y <= 6) && !(x === 5 && y === 5);
    }
    static isControllerRoom(roomName) {
        let pos = this.getRoomCoords(roomName);
        let x = pos.x % 10;
        let y = pos.y % 10;
        return (x >= 1 && x <= 9) && (y >= 1 && y <= 9) && (x <= 3 || x >= 7 || y <= 3 || y >= 7);
    }
    static isHighway(roomName) {
        let pos = this.getRoomCoords(roomName);
        return (pos.x % 10 === 0 || pos.y % 10 === 0);
    }
    static isCrossway(roomName) {
        let pos = this.getRoomCoords(roomName);
        return (pos.x % 10 === 0 && pos.y % 10 === 0);
    }
    static isExit(x, y, roomName) {
        if (x !== 0 && y !== 0 && x !== 49 && y !== 49)
            return false;
        if ((Game.map.getRoomTerrain(roomName).get(x, y) & TERRAIN_MASK_WALL) > 0)
            return false;
        return true;
    }
    getExitDest(x, y, roomName) {
        if (x instanceof RoomPosition) {
            y = x.y;
            roomName = x.roomName;
            x = x.x;
        }
        let newX = (x === 0 ? 49 : x === 49 ? 0 : x);
        let newY = (x === 0 ? 49 : x === 49 ? 0 : x);
        let dir = newX < x ? RIGHT : newX > x ? LEFT : newY < y ? TOP : BOTTOM;
        return new RoomPosition(newX, newY, Common.getNextRoom(roomName, dir));
    }
    static getExitDir(from, to) {
        const key = _.findKey(Game.map.describeExits(from), e => e === to);
        return key ? parseInt(key) : undefined;
    }
    static getExitTiles(roomName, dir) {
        let terrain = Game.map.getRoomTerrain(roomName);
        let exitTiles = [];
        const addLeft = (dir === undefined || dir === LEFT);
        const addTop = (dir === undefined || dir === TOP);
        const addRight = (dir === undefined || dir === RIGHT);
        const addBottom = (dir === undefined || dir === BOTTOM);
        for (let i = 1; i < 49; ++i) {
            if (addLeft && (terrain.get(0, i) & TERRAIN_MASK_WALL) === 0)
                exitTiles.push(new RoomPosition(0, i, roomName));
            if (addTop && (terrain.get(i, 0) & TERRAIN_MASK_WALL) === 0)
                exitTiles.push(new RoomPosition(i, 0, roomName));
            if (addRight && (terrain.get(49, i) & TERRAIN_MASK_WALL) === 0)
                exitTiles.push(new RoomPosition(49, i, roomName));
            if (addBottom && (terrain.get(i, 49) & TERRAIN_MASK_WALL) === 0)
                exitTiles.push(new RoomPosition(i, 49, roomName));
        }
        return exitTiles;
    }
    static getDistanceCM(room) {
        let terrain = Game.map.getRoomTerrain(room.name);
        let distances = new Uint8Array(2500).fill(0);
        for (let y = 1; y < 49; ++y)
            for (let x = 1; x < 49; ++x) {
                let index = y * 50 + x;
                if (terrain.get(x, y) & TERRAIN_MASK_WALL)
                    distances[index] = 0;
                else if (room.lookForAt(LOOK_STRUCTURES, x, y).find(s => s.isObstacle() || s.structureType === STRUCTURE_RAMPART || s.structureType === STRUCTURE_PORTAL))
                    distances[index] = 0;
                else if (room.controller && room.controller.owner && Config.ALLIES.has(room.controller.owner.username) && room.lookForAt(LOOK_CONSTRUCTION_SITES, x, y).length > 0)
                    distances[index] = 0;
                else {
                    distances[index] = Math.min(distances[index - 50] + 1, distances[index - 1] + 1, distances[index - 51] + 1, distances[index - 49] + 1);
                }
            }
        for (let y = 48; y > 0; --y)
            for (let x = 48; x > 0; --x) {
                let index = y * 50 + x;
                distances[index] = Math.min(distances[index], distances[index + 50] + 1, distances[index + 1] + 1, distances[index + 51] + 1, distances[index + 49] + 1);
            }
        return distances;
    }
    static getDirectionalDistanceCM(room, ignoreCreeps) {
        let terrain = Game.map.getRoomTerrain(room.name);
        let distances = new Uint8Array(2500).fill(0);
        let sources = room.find(FIND_SOURCES);
        for (let y = 48; y > 0; --y)
            for (let x = 48; x > 0; --x) {
                let index = y * 50 + x;
                if (terrain.get(x, y) & TERRAIN_MASK_WALL)
                    distances[index] = 0;
                else if (room.lookForAt(LOOK_STRUCTURES, x, y).find(s => s.isObstacle() || s.structureType === STRUCTURE_RAMPART || s.structureType === STRUCTURE_PORTAL))
                    distances[index] = 0;
                else if (room.controller && room.controller.owner && Config.ALLIES.has(room.controller.owner.username) && room.lookForAt(LOOK_CONSTRUCTION_SITES, x, y).length > 0)
                    distances[index] = 0;
                else if (room.lookForAt(LOOK_CREEPS, x, y).find(c => !ignoreCreeps.includes(c)))
                    distances[index] = 0;
                else if (sources.some(s => s.pos.isNearTo(x, y)))
                    distances[index] = 0;
                else {
                    distances[index] = Math.min(distances[index + 50] + 1, distances[index + 1] + 1, distances[index + 51] + 1);
                }
            }
        return distances;
    }
    // returns top left corner of rally
    static findRally(room, creepCount, POI, ignoreCreeps) {
        let squareSize = Math.ceil(Math.sqrt(creepCount));
        let distances = Common.getDirectionalDistanceCM(room, ignoreCreeps);
        let bestIndex = undefined;
        let bestDistance = Infinity;
        for (let i = 0; i < 2500; ++i) {
            if (distances[i] < squareSize)
                continue;
            let distanceFromPOI = POI.getRangeTo(i % 50, Math.floor(i / 50));
            if (bestDistance > distanceFromPOI) {
                bestIndex = i;
                bestDistance = distanceFromPOI;
            }
        }
        if (bestIndex === undefined)
            return undefined;
        else
            return new RoomPosition(bestIndex % 50, Math.floor(bestIndex / 50), room.name);
    }
    static getRallyCreepPosition(rallyPos, rallySize, creepIndex) {
        const grid = {
            1: [
                { x: 0, y: 0 }
            ],
            2: [
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 1, y: 1 },
                { x: 0, y: 1 }
            ],
            3: [
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 2, y: 0 },
                { x: 2, y: 1 },
                { x: 1, y: 1 },
                { x: 2, y: 2 },
                { x: 1, y: 2 },
                { x: 0, y: 2 },
                { x: 0, y: 1 }
            ],
            4: [
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 2, y: 0 },
                { x: 3, y: 0 },
                { x: 3, y: 1 },
                { x: 2, y: 1 },
                { x: 1, y: 1 },
                { x: 1, y: 2 },
                { x: 2, y: 2 },
                { x: 3, y: 2 },
                { x: 3, y: 3 },
                { x: 2, y: 3 },
                { x: 1, y: 3 },
                { x: 0, y: 3 },
                { x: 0, y: 2 },
                { x: 0, y: 1 }
            ]
        };
        return new RoomPosition(rallyPos.x + grid[rallySize][creepIndex].x, rallyPos.y + grid[rallySize][creepIndex].y, rallyPos.roomName);
    }
    // ---------------------------------------------------------------------
    static excuseMe(pos, direction) {
        const nextX = pos.x + Common.offsetX[direction];
        const nextY = pos.y + Common.offsetY[direction];
        if (nextX > 49 || nextX < 0 || nextY > 49 || nextY < 0)
            return;
        const creeps = Game.rooms[pos.roomName].lookForAt(LOOK_CREEPS, nextX, nextY);
        if (creeps.length > 0 && creeps[0].my)
            creeps[0].memory.excuseMe = Common.getOppositeDir(direction);
        let powerCreeps = Game.rooms[pos.roomName].lookForAt(LOOK_POWER_CREEPS, nextX, nextY);
        if (powerCreeps.length > 0 && powerCreeps[0].my)
            powerCreeps[0].memory.excuseMe = Common.getOppositeDir(direction);
    }
    // ---------------------------------------------------------------------
    static calcTowerMultiplier(x1, y1, x2, y2) {
        const distance = Math.max(Math.abs(x2 - x1), Math.abs(y2 - y1));
        const clampedDistance = Math.clamp(distance, TOWER_OPTIMAL_RANGE, TOWER_FALLOFF_RANGE);
        const normalizedDistance = (clampedDistance - TOWER_OPTIMAL_RANGE) / (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);
        return 1.0 - normalizedDistance * TOWER_FALLOFF;
    }
    // ---------------------------------------------------------------------
    static hslToRgb(h, s, v) {
        var r, g, b, i, f, p, q, t;
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0:
                r = v;
                g = t;
                b = p;
                break;
            case 1:
                r = q;
                g = v;
                b = p;
                break;
            case 2:
                r = p;
                g = v;
                b = t;
                break;
            case 3:
                r = p;
                g = q;
                b = v;
                break;
            case 4:
                r = t;
                g = p;
                b = v;
                break;
            case 5:
                r = v;
                g = p;
                b = q;
                break;
        }
        let result = '#';
        let colorStr = Math.round(r * 255).toString(16);
        result += colorStr.length === 1 ? '0' + colorStr : colorStr;
        colorStr = Math.round(g * 255).toString(16);
        result += colorStr.length === 1 ? '0' + colorStr : colorStr;
        colorStr = Math.round(b * 255).toString(16);
        result += colorStr.length === 1 ? '0' + colorStr : colorStr;
        return result;
    }
    static getRandomColor() {
        let h = Math.random();
        let s = 1;
        let v = 1;
        return this.hslToRgb(h, s, v);
    }
}
Common.USERNAME = getUsername();
// ---------------------------------------------------------------------
Common.offsetX = [0, 0, 1, 1, 1, 0, -1, -1, -1];
Common.offsetY = [0, -1, -1, 0, 1, 1, 1, 0, -1];
Common.offset = {
    [TOP_LEFT]: { x: -1, y: -1 },
    [TOP]: { x: 0, y: -1 },
    [TOP_RIGHT]: { x: 1, y: -1 },
    [LEFT]: { x: -1, y: 0 },
    [RIGHT]: { x: 1, y: 0 },
    [BOTTOM_LEFT]: { x: -1, y: 1 },
    [BOTTOM]: { x: 0, y: 1 },
    [BOTTOM_RIGHT]: { x: 1, y: 1 }
};
Common.crosswiseOffset = {
    [TOP]: { x: 0, y: -1 },
    [LEFT]: { x: -1, y: 0 },
    [RIGHT]: { x: 1, y: 0 },
    [BOTTOM]: { x: 0, y: 1 }
};
Common.diagonalOffset = {
    [TOP_LEFT]: { x: -1, y: -1 },
    [TOP_RIGHT]: { x: 1, y: -1 },
    [BOTTOM_LEFT]: { x: 1, y: 0 },
    [BOTTOM_RIGHT]: { x: 0, y: 1 }
};
__decorate([
    profile()
], Common, "excuseMe", null);
var common = new Common;

class SegmentManager {
    static clearSegment(id) {
        if (this._segmentsToSave.length >= 10)
            return false;
        RawMemory.segments[id] = '';
        this._segmentsToSave.push(id);
        return true;
    }
    static *clearSegments() {
        this._segmentRequests.length = 0;
        for (let i = 0; i < 100; ++i) {
            if (!this.clearSegment(i)) {
                console.log(`clearing segments progress: ${i}%`);
                yield;
                this._segmentRequests.length = 0;
            }
        }
        console.log('finished clearing segments');
    }
    static *loadSegments() {
        for (let i = 0; i < 10; ++i) {
            RawMemory.setActiveSegments([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(j => i * 10 + j));
            yield;
            for (let id = i * 10; id <= i * 10 + 9; ++id) {
                const segmentData = RawMemory.segments[id];
                try {
                    this._segmentCache[id] = segmentData.length > 0 ? JSON.parse(segmentData) : null;
                }
                catch (e) {
                    console.log(`failed to parse segment ${id}<br/>${e}`);
                    this.invalidSegments.add(id);
                }
                this.maxLoadedSegment = id;
            }
            console.log(`loading segments progress: ${(i + 1) * 10}%`);
        }
    }
    static findFreeSegmentId() {
        for (let id = 0; id <= this.maxLoadedSegment; ++id) {
            if (this._segmentCache[id] !== null)
                continue;
            if (this.invalidSegments.has(id))
                continue;
            return id;
        }
        return undefined;
    }
    static getSegment(id) {
        if (this._segmentCache[id])
            return this._segmentCache[id];
        else
            return undefined;
    }
    static isSegmentLoaded(id) {
        return id <= this.maxLoadedSegment;
    }
    static setSegment(id, value) {
        if (this._segmentsToSave.length >= 10)
            return false;
        try {
            let serialized = JSON.stringify(value);
            this._segmentCache[id] = JSON.parse(serialized);
            RawMemory.segments[id] = serialized;
        }
        catch (e) {
            console.log("couldn't serialize value for segment " + id + "<br/>" + e);
            return false;
        }
        this._segmentsToSave.push(id);
        return true;
    }
    static preTick() {
        this._segmentRequests.length = 0;
        this._segmentsToSave.length = 0;
    }
    static postTick() {
        for (let id in RawMemory.segments)
            if (!this._segmentsToSave.includes(parseInt(id)))
                delete RawMemory.segments[id];
    }
}
SegmentManager.MAX_ACTIVE_SEGMENTS = 10;
SegmentManager._segmentRequests = [];
SegmentManager._segmentsToSave = [];
SegmentManager._segmentCache = {};
SegmentManager.invalidSegments = new Set();
SegmentManager.maxLoadedSegment = 0;
global.SegmentManager = SegmentManager;

class Stats {
    static registerSpending(roomName, operationName, energyAmount) {
        this.energySpending[roomName] = this.energySpending[roomName] || {};
        this.energySpending[roomName][operationName] = this.energySpending[roomName][operationName] || 0;
        this.energySpending[roomName][operationName] += energyAmount;
    }
    static registerOperationCpu(operationName, usedCpu, estimatedCpu, baseEstimatedCpu) {
        if (!Stats.operations[operationName]) {
            Stats.operations[operationName] = {
                usedCpu: usedCpu,
                estimatedCpu: estimatedCpu,
                defaultEstimatedCpu: baseEstimatedCpu
            };
        }
        else {
            Stats.operations[operationName].usedCpu += usedCpu;
            Stats.operations[operationName].estimatedCpu += estimatedCpu;
            Stats.operations[operationName].defaultEstimatedCpu += baseEstimatedCpu;
        }
    }
    static registerCreditChange(roomName, type, resource, creditsChange) {
        switch (type) {
            case 6 /* EMarketActivityType.AlterBuyOrder */:
                this.creditSpending.alteringBuyOrders[roomName] = this.creditSpending.alteringBuyOrders[roomName] || {};
                this.creditSpending.alteringBuyOrders[roomName][resource] = this.creditSpending.alteringBuyOrders[roomName][resource] || 0;
                this.creditSpending.alteringBuyOrders[roomName][resource] += creditsChange;
                break;
            case 7 /* EMarketActivityType.AlterSellOrder */:
                this.creditSpending.alteringSellOrders[roomName] = this.creditSpending.alteringSellOrders[roomName] || {};
                this.creditSpending.alteringSellOrders[roomName][resource] = this.creditSpending.alteringSellOrders[roomName][resource] || 0;
                this.creditSpending.alteringSellOrders[roomName][resource] += creditsChange;
                break;
            case 4 /* EMarketActivityType.CreateBuyOrder */:
                this.creditSpending.creatingBuyOrders[roomName] = this.creditSpending.creatingBuyOrders[roomName] || {};
                this.creditSpending.creatingBuyOrders[roomName][resource] = this.creditSpending.creatingBuyOrders[roomName][resource] || 0;
                this.creditSpending.creatingBuyOrders[roomName][resource] += creditsChange;
                break;
            case 5 /* EMarketActivityType.CreateSellOrder */:
                this.creditSpending.creatingSellOrders[roomName] = this.creditSpending.creatingSellOrders[roomName] || {};
                this.creditSpending.creatingSellOrders[roomName][resource] = this.creditSpending.creatingSellOrders[roomName][resource] || 0;
                this.creditSpending.creatingSellOrders[roomName][resource] += creditsChange;
                break;
            case 1 /* EMarketActivityType.TransactionBuy */:
                this.creditSpending.buyTransactions[roomName] = this.creditSpending.buyTransactions[roomName] || {};
                this.creditSpending.buyTransactions[roomName][resource] = this.creditSpending.buyTransactions[roomName][resource] || 0;
                this.creditSpending.buyTransactions[roomName][resource] += creditsChange;
                break;
            case 0 /* EMarketActivityType.TransactionSell */:
                this.creditSpending.sellTransactions[roomName] = this.creditSpending.sellTransactions[roomName] || {};
                this.creditSpending.sellTransactions[roomName][resource] = this.creditSpending.sellTransactions[roomName][resource] || 0;
                this.creditSpending.sellTransactions[roomName][resource] += creditsChange;
                break;
            case 3 /* EMarketActivityType.TransactionForceBuy */:
                this.creditSpending.forceBuyTransactions[roomName] = this.creditSpending.forceBuyTransactions[roomName] || {};
                this.creditSpending.forceBuyTransactions[roomName][resource] = this.creditSpending.forceBuyTransactions[roomName][resource] || 0;
                this.creditSpending.forceBuyTransactions[roomName][resource] += creditsChange;
                break;
            case 2 /* EMarketActivityType.TransactionForceSell */:
                this.creditSpending.forceSellTransactions[roomName] = this.creditSpending.forceSellTransactions[roomName] || {};
                this.creditSpending.forceSellTransactions[roomName][resource] = this.creditSpending.forceSellTransactions[roomName][resource] || 0;
                this.creditSpending.forceSellTransactions[roomName][resource] += creditsChange;
                break;
        }
    }
    static preTick() {
        this.globalAge = (this.globalAge || 0) + 1;
        this.operations = {};
    }
    static getDebugStats() {
        if (!Memory.toggles || !Memory.toggles.debugStats)
            return {};
        let workingMines = 0;
        let notWorkingMines = 0;
        let closingMines = 0;
        let containerCount = 0;
        let expectedContainerCount = 0;
        let avgHits = 0;
        let lowestHits = Infinity;
        for (let roomName in Memory.myRooms) {
            let myRoom = Game.rooms[roomName].myRoom;
            // not loaded yet
            if (!myRoom)
                continue;
            for (let outpost of myRoom.activeOutposts) {
                if (Game.rooms[outpost.roomName]) {
                    for (let mine of outpost.operationMine) {
                        let isWorking = mine.isWorking();
                        if (outpost.isActive && isWorking)
                            ++workingMines;
                        else if (outpost.isActive)
                            ++notWorkingMines;
                        else
                            ++closingMines;
                        if (outpost.isActive) {
                            ++expectedContainerCount;
                            if (mine.container) {
                                ++containerCount;
                                avgHits += mine.container.hits;
                                if (mine.container.hits < lowestHits)
                                    lowestHits = mine.container.hits;
                            }
                        }
                    }
                    if (outpost.operationExtraction) {
                        ++expectedContainerCount;
                        let container = outpost.operationExtraction.minerSpot.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_CONTAINER);
                        if (container) {
                            ++containerCount;
                            avgHits += container.hits;
                            if (container.hits < lowestHits)
                                lowestHits = container.hits;
                        }
                    }
                }
            }
        }
        avgHits = containerCount > 0 ? avgHits / containerCount : 0;
        return {
            containerCount: containerCount,
            expectedContainerCount: expectedContainerCount,
            avgHits: avgHits,
            lowestHits: lowestHits,
            workingMines: workingMines,
            notWorkingMines: notWorkingMines,
            closingMines: closingMines
        };
    }
    static postTick() {
        if (Game.time >= this.nextSpendingMeasureTime) {
            this.lastEnergySpending = this.energySpending;
            this.energySpending = {};
            this.nextSpendingMeasureTime = Game.time + this.spendingMeasurePeriod;
        }
        if (Game.time >= this.nextCreditSpendingMeasureTime) {
            this.lastCreditSpending = this.creditSpending;
            this.creditSpending = {
                alteringBuyOrders: {},
                alteringSellOrders: {},
                creatingBuyOrders: {},
                creatingSellOrders: {},
                buyTransactions: {},
                sellTransactions: {},
                forceBuyTransactions: {},
                forceSellTransactions: {}
            };
            this.nextCreditSpendingMeasureTime = Game.time + this.spendingMeasurePeriod;
        }
        if (Game.time >= this.nextPlayerDataUpdate) {
            this.players = {};
            for (let roomName in GIntel.rooms) {
                let roomIntel = GIntel.rooms[roomName];
                let player = roomIntel.owner || '>>>UNOWNED<<<';
                this.players[player] = this.players[player] || { energy: 0, knownRooms: 0 };
                this.players[player].energy += roomIntel.storedEnergy;
                this.players[player].knownRooms++;
            }
            this.nextPlayerDataUpdate = Game.time + this.playerDataUpdatePeriod;
        }
        let results = {
            globalAge: this.globalAge,
            profiling: {
                bucket: Game.cpu.bucket,
                limit: Game.cpu.limit,
                list: Profiler.list,
                cpuByCategory: Profiler.cpuByCategory,
                heapStatistics: Game.cpu.getHeapStatistics(),
                memory: RawMemory.get().length
            },
            gcl: Game.gcl,
            gpl: Game.gpl,
            credits: Game.market.credits,
            scheduler: {
                operation: this.operations
            },
            market: {
                buyAvg: Memory.market && Memory.market.buyAvg,
                sellAvg: Memory.market && Memory.market.sellAvg,
                value: Memory.market && Memory.market.value,
                stddev: Memory.market && Memory.market.stddev,
                buyMax: Memory.market && Memory.market.buyPricesMax,
                sellMin: Memory.market && Memory.market.sellPricesMin,
                creditSpending: this.lastCreditSpending
            },
            resources: _(GEmpire.myRooms)
                .filter(mr => Game.rooms[mr.roomName])
                .mapKeys(mr => mr.roomName)
                .mapValues((obj1, roomName) => _(RESOURCES_ALL)
                .mapKeys(r => r)
                .mapValues((obj2, r) => (Game.rooms[roomName].storage && Game.rooms[roomName].storage.store[r] || 0) + (Game.rooms[roomName].terminal && Game.rooms[roomName].terminal.store[r] || 0))
                .value())
                .value(),
            spending: this.lastEnergySpending || {},
            players: this.players || {},
            debug: this.getDebugStats()
        };
        SegmentManager.setSegment(Config.segments.stats, results);
    }
}
Stats.spendingMeasurePeriod = 100;
Stats.energySpending = {};
Stats.nextSpendingMeasureTime = Game.time;
Stats.playerDataUpdatePeriod = 100;
Stats.nextPlayerDataUpdate = Game.time;
Stats.marketActivityUpdatePeriod = 100;
Stats.creditSpending = {
    sellTransactions: {},
    buyTransactions: {},
    forceSellTransactions: {},
    forceBuyTransactions: {},
    creatingBuyOrders: {},
    creatingSellOrders: {},
    alteringBuyOrders: {},
    alteringSellOrders: {}
};
Stats.nextCreditSpendingMeasureTime = Game.time;

const codeToBodypart = {
    C: CARRY,
    W: WORK,
    A: ATTACK,
    R: RANGED_ATTACK,
    T: TOUGH,
    M: MOVE,
    H: HEAL,
    X: CLAIM
};
const bodypartToCode = _.invert(codeToBodypart);
class CreepBody {
    constructor(arg1, arg2) {
        if (arg1 instanceof Creep)
            this.initFromCreep(arg1);
        else
            this.initFromData(arg1, arg2 || []);
    }
    initFromData(serializedBody, boosts) {
        const self = this;
        self.serializedBody = serializedBody;
        self.boosts = new Set(boosts);
        self.parts = [];
        self.cost = 0;
        for (let bp of BODYPARTS_ALL)
            self[bp] = 0;
        const error = 'Invalid input at parseBody: "' + serializedBody + '"';
        let N = 0;
        let bodypartGroup;
        for (let i = 0; i < serializedBody.length; ++i) {
            let c = serializedBody.charAt(i);
            let cCode = c.charCodeAt(0);
            if (cCode >= 48 && cCode <= 57) {
                N = N * 10 + (cCode - 48);
            }
            else if (c === '[' && !bodypartGroup) {
                bodypartGroup = [];
            }
            else if (c === '[') {
                throw new Error(error);
            }
            else if (c === ']' && bodypartGroup) {
                N = N || 1;
                for (let j = 0; j < N; ++j)
                    for (let bodypart of bodypartGroup) {
                        self.parts.push(bodypart);
                        self.cost += BODYPART_COST[bodypart];
                        ++self[bodypart];
                    }
                N = 0;
                bodypartGroup = undefined;
            }
            else if (c === ']') {
                throw new Error(error);
            }
            else if (codeToBodypart[c] && bodypartGroup) {
                bodypartGroup.push(codeToBodypart[c]);
            }
            else if (codeToBodypart[c]) {
                N = N || 1;
                for (let j = 0; j < N; ++j) {
                    const bodypart = codeToBodypart[c];
                    self.parts.push(bodypart);
                    self.cost += BODYPART_COST[bodypart];
                    ++self[bodypart];
                }
                N = 0;
            }
            else {
                throw new Error(error);
            }
        }
        self.spawnTime = self.parts.length * CREEP_SPAWN_TIME;
        this.updateBodypartPowers();
    }
    initFromCreep(creep) {
        const self = this;
        self.serializedBody = '';
        self.boosts = new Set();
        self.parts = [];
        self.cost = 0;
        for (let bp of BODYPARTS_ALL)
            self[bp] = 0;
        for (let bodypart of creep.body) {
            ++self[bodypart.type];
            self.parts.push(bodypart.type);
            self.serializedBody += bodypartToCode[bodypart.type];
            self.cost += BODYPART_COST[bodypart.type];
            if (bodypart.boost && !self.boosts.has(bodypart.boost))
                self.boosts.add(bodypart.boost);
        }
        self.spawnTime = self.parts.length * CREEP_SPAWN_TIME;
        this.updateBodypartPowers();
    }
    updateBodypartPowers() {
        let dismantleMultiplier = 1;
        let rangedAttackMultiplier = 1;
        let attackMultiplier = 1;
        let healMultiplier = 1;
        let toughMultiplier = 1;
        for (let boost of this.boosts) {
            switch (boost) {
                case RES_ZH:
                case RES_ZH2O:
                case RES_XZH2O:
                    dismantleMultiplier = BOOSTS.work[boost].dismantle;
                    break;
                case RES_LO:
                case RES_LHO2:
                case RES_XLHO2:
                    healMultiplier = BOOSTS.heal[boost].heal;
                    break;
                case RES_KO:
                case RES_KHO2:
                case RES_XKHO2:
                    rangedAttackMultiplier = BOOSTS.ranged_attack[boost].rangedAttack;
                    break;
                case RES_UH:
                case RES_UH2O:
                case RES_XUH2O:
                    attackMultiplier = BOOSTS.attack[boost].attack;
                    break;
                case RES_GO:
                case RES_GHO2:
                case RES_XGHO2:
                    toughMultiplier = BOOSTS.tough[boost].damage;
                    break;
            }
        }
        this.dismantlePower = DISMANTLE_POWER * this[WORK] * dismantleMultiplier;
        this.rangedAttackPower = RANGED_ATTACK_POWER * this[RANGED_ATTACK] * rangedAttackMultiplier;
        this.attackPower = ATTACK_POWER * this[ATTACK] * attackMultiplier;
        this.healPower = HEAL_POWER * this[HEAL] * healMultiplier;
        this.toughMultiplier = toughMultiplier;
    }
}
function getCreepCost(parts) {
    let cost = 0;
    for (let partName in parts)
        cost += parts[partName] * BODYPART_COST[partName];
    return cost;
}
function getBodypartBoostMod(bodypart) {
    if (!bodypart)
        return 0;
    let availableBoosts = BOOSTS[bodypart.type];
    let boostMultipliers = availableBoosts[bodypart.boost];
    if (!boostMultipliers)
        return 1;
    else
        return Object.values(boostMultipliers)[0];
}
function getBodypartPower(bodypart, creep) {
    let result = 0;
    let bodypartBoosts = BOOSTS[bodypart];
    for (let bp of creep.body) {
        if (bp.type === bodypart) {
            if (bp.boost) {
                result += _.find(bodypartBoosts[bp.boost]);
            }
            else {
                ++result;
            }
        }
    }
    return result;
}

function generateRandomKey(length) {
    const characters = 'abcdef0123456789';
    let result = '';
    for (let i = 0; i < length; ++i)
        result += characters.charAt(Math.floor(Math.random() * characters.length));
    return result;
}
function rollingAvg(currentAvg, newValue, rollingPeriod) {
    return (currentAvg * (rollingPeriod - 1) + newValue) / rollingPeriod;
}
function collectEnergy(creep, resourceType, myRoom, operationName) {
    Profiler.push('Utils::collect');
    let result = true;
    let room = Game.rooms[myRoom.roomName];
    if (!room || room.find(FIND_MY_SPAWNS).length === 0) {
        let source = creep.pos.findClosestByRange(room.find(FIND_SOURCES_ACTIVE));
        if (source) {
            if (creep.harvest(source) === ERR_NOT_IN_RANGE)
                creep.goTo(source.pos, 1);
        }
    }
    else {
        let distributionPoint = myRoom.getDistributionPoint(resourceType);
        if (distributionPoint && distributionPoint instanceof Resource) {
            if (creep.pos.inRangeTo(distributionPoint, 1)) {
                creep.pickup(distributionPoint);
                Stats.registerSpending(myRoom.roomName, operationName, Math.min(creep.store.getFreeCapacity(), distributionPoint.amount));
                creep.giveWay();
            }
            else {
                creep.goTo(distributionPoint.pos, 1);
            }
        }
        else if (distributionPoint && !(distributionPoint instanceof Resource)) {
            if (creep.pos.inRangeTo(distributionPoint, 1)) {
                creep.withdraw(distributionPoint, resourceType);
                Stats.registerSpending(myRoom.roomName, operationName, Math.min(creep.store.getFreeCapacity(), distributionPoint.store.energy));
                creep.giveWay();
            }
            else {
                creep.goTo(distributionPoint.pos, 1);
            }
        }
        else {
            creep.smokeBreak();
            result = false;
        }
    }
    Profiler.pop();
    return result;
}

class CombatData {
    static init() {
        this.towerPower = {};
        this.attackPoints = {};
        this.hostileCreepDamage = {};
        this.hostileCreepInfluence = {};
        this.attackPointReservations = {};
        this.drawCombatData = {};
    }
    static getTowerPower(roomName) {
        if (this.towerPower[roomName] && Game.time - this.towerPower[roomName].tick < 10)
            return this.towerPower[roomName].value;
        let roomIntel = GIntel.rooms[roomName];
        let room = Game.rooms[roomName];
        if (room) {
            this.towerPower[roomName] = {
                value: new Float32Array(2500).fill(0),
                tick: Game.time
            };
            let towers = room.find(FIND_STRUCTURES).filter(s => s.structureType === STRUCTURE_TOWER && s.store.energy >= TOWER_ENERGY_COST && (s.isActive() || roomIntel.isSkRoom));
            for (let tower of towers) {
                for (let y = 0; y < 50; ++y) {
                    for (let x = 0; x < 50; ++x) {
                        let i = y * 50 + x;
                        let power = Common.calcTowerMultiplier(x, y, tower.pos.x, tower.pos.y);
                        this.towerPower[roomName].value[i] += power;
                    }
                }
            }
            return this.towerPower[roomName].value;
        }
        else if (roomIntel) {
            let minTowerPower = roomIntel.towers * (1.0 - TOWER_FALLOFF);
            this.towerPower[roomName] = {
                value: new Float32Array(2500).fill(minTowerPower),
                tick: Game.time
            };
            return this.towerPower[roomName].value;
        }
        else {
            return undefined;
        }
    }
    static getHostileCreepDamage(roomName) {
        if (this.hostileCreepDamage[roomName] && this.hostileCreepDamage[roomName].tick === Game.time)
            return this.hostileCreepDamage[roomName].value;
        let room = Game.rooms[roomName];
        if (room) {
            this.hostileCreepDamage[roomName] = {
                value: new Uint16Array(2500),
                tick: Game.time
            };
            const meleeRange = 1;
            const rangedRange = 3;
            for (let h of room.findHostileCreeps()) {
                let mPower = getBodypartPower(ATTACK, h);
                if (mPower > 0) {
                    const left = Math.max(0, h.pos.x - meleeRange);
                    const top = Math.max(0, h.pos.y - meleeRange);
                    const right = Math.min(49, h.pos.x + meleeRange);
                    const bottom = Math.min(49, h.pos.y + meleeRange);
                    for (let i = left; i <= right; ++i)
                        for (let j = top; j <= bottom; ++j)
                            this.hostileCreepDamage[roomName].value[j * 50 + i] += mPower * ATTACK_POWER;
                }
                let rPower = getBodypartPower(RANGED_ATTACK, h);
                if (rPower > 0) {
                    const left = Math.max(0, h.pos.x - rangedRange);
                    const top = Math.max(0, h.pos.y - rangedRange);
                    const right = Math.min(49, h.pos.x + rangedRange);
                    const bottom = Math.min(49, h.pos.y + rangedRange);
                    for (let i = left; i <= right; ++i)
                        for (let j = top; j <= bottom; ++j)
                            this.hostileCreepDamage[roomName].value[j * 50 + i] += rPower * RANGED_ATTACK_POWER;
                }
            }
            return this.hostileCreepDamage[roomName].value;
        }
        else {
            return undefined;
        }
    }
    static getHostileCreepInfluence(roomName) {
        if (this.hostileCreepInfluence[roomName] && this.hostileCreepInfluence[roomName].tick === Game.time)
            return this.hostileCreepInfluence[roomName].value;
        let room = Game.rooms[roomName];
        if (room) {
            this.hostileCreepInfluence[roomName] = {
                value: new Uint16Array(2500).fill(0),
                tick: Game.time
            };
            let terrain = Game.map.getRoomTerrain(roomName).getRawBuffer();
            let checked = new Uint16Array(2500);
            let rInfluence = new Uint16Array(2500);
            let mInfluence = new Uint16Array(2500);
            let hostileId = 1;
            for (let h of room.findHostileCreeps()) {
                let mPower = getBodypartPower(ATTACK, h) * ATTACK_POWER;
                let rPower = getBodypartPower(RANGED_ATTACK, h) * RANGED_ATTACK_POWER;
                if (mPower === 0 && rPower === 0)
                    continue;
                let nodes = [{
                        x: h.pos.x,
                        y: h.pos.y,
                        index: h.pos.y * 50 + h.pos.x,
                        depth: 0
                    }];
                checked[nodes[0].index] = hostileId;
                while (nodes.length > 0) {
                    let node = nodes.shift();
                    if (mPower > 0) {
                        const left = Math.max(0, node.x - 1);
                        const top = Math.max(0, node.y - 1);
                        const right = Math.min(49, node.x + 1);
                        const bottom = Math.min(49, node.y + 1);
                        for (let i = left; i <= right; ++i)
                            for (let j = top; j <= bottom; ++j)
                                if (mInfluence[j * 50 + i] !== hostileId) {
                                    let isSwampy = (terrain[j * 50 + i] & TERRAIN_MASK_SWAMP) > 0 && !room.lookForAt(LOOK_STRUCTURES, i, j).find(s => s.structureType === STRUCTURE_ROAD);
                                    if (node.depth <= 1 || isSwampy) {
                                        this.hostileCreepInfluence[roomName].value[j * 50 + i] += mPower;
                                    }
                                    mInfluence[j * 50 + i] = hostileId;
                                }
                    }
                    if (rPower > 0) {
                        const left = Math.max(0, node.x - 3);
                        const top = Math.max(0, node.y - 3);
                        const right = Math.min(49, node.x + 3);
                        const bottom = Math.min(49, node.y + 3);
                        for (let i = left; i <= right; ++i)
                            for (let j = top; j <= bottom; ++j)
                                if (rInfluence[j * 50 + i] !== hostileId) {
                                    let isSwampy = (terrain[j * 50 + i] & TERRAIN_MASK_SWAMP) > 0 && !room.lookForAt(LOOK_STRUCTURES, i, j).find(s => s.structureType === STRUCTURE_ROAD);
                                    if (node.depth <= 1 || isSwampy) {
                                        this.hostileCreepInfluence[roomName].value[j * 50 + i] += rPower;
                                    }
                                    rInfluence[j * 50 + i] = hostileId;
                                }
                    }
                    if (node.depth + 1 < 5 && ((terrain[node.index] & TERRAIN_MASK_SWAMP) === 0 || room.lookForAt(LOOK_STRUCTURES, node.x, node.y).find(s => s.structureType === STRUCTURE_ROAD))) {
                        for (let i = TOP; i <= TOP_LEFT; ++i) {
                            let newNodeX = node.x + Common.offsetX[i];
                            let newNodeY = node.y + Common.offsetY[i];
                            let newNodeIndex = newNodeY * 50 + newNodeX;
                            if (newNodeX < 0 || newNodeX > 49 || newNodeY < 0 || newNodeY > 49)
                                continue;
                            if (checked[newNodeIndex] === hostileId)
                                continue;
                            checked[newNodeIndex] = hostileId;
                            let structures = room.lookForAt(LOOK_STRUCTURES, newNodeX, newNodeY);
                            if ((terrain[newNodeIndex] & TERRAIN_MASK_WALL) > 0 && !structures.find(s => s.structureType === STRUCTURE_ROAD))
                                continue;
                            if (structures.find(s => s.isObstacle()))
                                continue;
                            nodes.push({
                                x: newNodeX,
                                y: newNodeY,
                                index: newNodeIndex,
                                depth: node.depth + 1
                            });
                        }
                    }
                }
                ++hostileId;
            }
            return this.hostileCreepInfluence[roomName].value;
        }
        else {
            return undefined;
        }
    }
    static getAttackPoints(roomName, keepStorage, keepTerminal) {
        if (this.attackPoints[roomName] && Game.time - this.attackPoints[roomName].tick < 10)
            return this.attackPoints[roomName].value;
        let room = Game.rooms[roomName];
        if (room) {
            this.attackPoints[roomName] = {
                value: [],
                tick: Game.time
            };
            let terrain = Game.map.getRoomTerrain(roomName);
            let checked = new Uint8Array(2500);
            // make value arrays
            let rangedValue = new Float64Array(2500);
            let meleeValue = new Float64Array(2500);
            let structures = room.find(FIND_STRUCTURES);
            if (Common.isCenterRoom(roomName))
                structures = structures.filter(s => s.structureType !== STRUCTURE_EXTRACTOR);
            if (keepStorage)
                structures = structures.filter(s => s.structureType !== STRUCTURE_STORAGE);
            if (keepTerminal)
                structures = structures.filter(s => s.structureType !== STRUCTURE_TERMINAL);
            for (let s of structures) {
                if (s.structureType in this.structureWeight) {
                    let left = Math.max(0, s.pos.x - ATTACK_RANGE);
                    let top = Math.max(0, s.pos.y - ATTACK_RANGE);
                    let right = Math.min(49, s.pos.x + ATTACK_RANGE);
                    let bottom = Math.min(49, s.pos.y + ATTACK_RANGE);
                    for (let x = left; x <= right; ++x) {
                        for (let y = top; y <= bottom; ++y) {
                            const i = y * 50 + x;
                            const newValue = this.structureWeight[s.structureType] / s.hits;
                            if (meleeValue[i] < newValue)
                                meleeValue[i] = newValue;
                        }
                    }
                    left = Math.max(0, s.pos.x - RANGED_ATTACK_RANGE);
                    top = Math.max(0, s.pos.y - RANGED_ATTACK_RANGE);
                    right = Math.min(49, s.pos.x + RANGED_ATTACK_RANGE);
                    bottom = Math.min(49, s.pos.y + RANGED_ATTACK_RANGE);
                    for (let x = left; x <= right; ++x) {
                        for (let y = top; y <= bottom; ++y) {
                            const i = y * 50 + x;
                            const distance = Math.max(Math.abs(s.pos.x - x), Math.abs(s.pos.y - y));
                            rangedValue[i] += this.structureWeight[s.structureType] * RANGED_MASS_ATTACK_POWER[distance] / s.hits;
                        }
                    }
                }
            }
            // start floodfill from exits
            let nodes = [];
            for (let i = 1; i < 49; ++i) {
                if ((terrain.get(0, i) & TERRAIN_MASK_WALL) === 0)
                    nodes.push({ x: 0, y: i, canFitQuad: true });
                if ((terrain.get(i, 0) & TERRAIN_MASK_WALL) === 0)
                    nodes.push({ x: i, y: 0, canFitQuad: true });
                if ((terrain.get(49, i) & TERRAIN_MASK_WALL) === 0)
                    nodes.push({ x: 49, y: i, canFitQuad: true });
                if ((terrain.get(i, 49) & TERRAIN_MASK_WALL) === 0)
                    nodes.push({ x: i, y: 49, canFitQuad: true });
            }
            while (nodes.length > 0) {
                let node = nodes.shift();
                let canFitQuad = node.canFitQuad;
                if (canFitQuad) {
                    const quadOffsets = [
                        { x: 1, y: 0 },
                        { x: 0, y: 1 },
                        { x: 1, y: 1 }
                    ];
                    for (let o of quadOffsets) {
                        let quadSpotX = node.x + o.x;
                        let quadSpotY = node.y + o.y;
                        if (quadSpotX < 0 || quadSpotX > 49 || quadSpotY < 0 || quadSpotY > 49)
                            continue;
                        if ((terrain.get(quadSpotX, quadSpotY) & TERRAIN_MASK_WALL) > 0
                            || room.lookForAt(LOOK_STRUCTURES, quadSpotX, quadSpotY).find(s => s.isObstacle())) {
                            canFitQuad = false;
                            break;
                        }
                    }
                }
                for (let dir = TOP; dir <= TOP_LEFT; ++dir) {
                    let newX = node.x + Common.offsetX[dir];
                    let newY = node.y + Common.offsetY[dir];
                    let newIndex = newY * 50 + newX;
                    if (newX < 0 || newX > 49 || newY < 0 || newY > 49)
                        continue;
                    if (room.lookForAt(LOOK_STRUCTURES, newX, newY).find(s => s.isObstacle()))
                        continue;
                    if (checked[newIndex] > 1 || !canFitQuad && checked[newIndex] > 0)
                        continue;
                    checked[newIndex] = canFitQuad ? 2 : 1;
                    if ((terrain.get(newX, newY) & TERRAIN_MASK_WALL) > 0)
                        continue;
                    nodes.push({
                        x: newX,
                        y: newY,
                        canFitQuad: canFitQuad
                    });
                }
                // attack points on exits don't count
                if (node.x === 0 || node.x === 49 || node.y === 0 || node.y === 49)
                    continue;
                const index = node.y * 50 + node.x;
                const canAttack = rangedValue[index] > 0;
                if (canAttack) {
                    const canQuadAttack = index + 1 < 2500 && rangedValue[index + 1] > 0
                        && index + 50 < 2500 && rangedValue[index + 50] > 0
                        && index + 51 < 2500 && rangedValue[index + 51] > 0;
                    let attackPointOnPos = this.attackPoints[roomName].value.find(ap => ap.pos.x === node.x && ap.pos.y === node.y);
                    if (attackPointOnPos) {
                        if (!attackPointOnPos.canFitQuad)
                            attackPointOnPos.canFitQuad = canFitQuad && canQuadAttack;
                    }
                    else {
                        this.attackPoints[roomName].value.push({
                            pos: new RoomPosition(node.x, node.y, roomName),
                            canFitQuad: canFitQuad && canQuadAttack,
                            melee: meleeValue[index],
                            ranged: rangedValue[index]
                        });
                    }
                }
            }
            return this.attackPoints[roomName].value;
        }
        return undefined;
    }
    static preTick() {
        this.attackPointReservations = {};
        this.hostileCreepDamage = {};
    }
    static postTick() {
        const quadCircleStyle = { radius: 0.3, fill: null, stroke: '#ffffff', strokeWidth: 0.05, opacity: 0.5 };
        const singleCircleStyle = { radius: 0.15, fill: null, stroke: '#ffffff', strokeWidth: 0.05, opacity: 0.5 };
        const textStyle = { align: 'center', opacity: 0.5, font: 0.5 };
        for (let roomName in this.drawCombatData) {
            let visual = new RoomVisual(roomName);
            if (this.drawCombatData[roomName].attackPoints) {
                let attackPoints = this.getAttackPoints(roomName, false, false);
                if (attackPoints)
                    for (let attackPoint of attackPoints) {
                        visual.circle(attackPoint.pos.x, attackPoint.pos.y, attackPoint.canFitQuad ? quadCircleStyle : singleCircleStyle);
                    }
            }
            if (this.drawCombatData[roomName].deathzone) {
                let towerPower = this.getTowerPower(roomName);
                let creepDamage = this.getHostileCreepInfluence(roomName);
                for (let i = 0; i < 2500; ++i)
                    if ((towerPower && towerPower[i] * TOWER_POWER_ATTACK || 0) + (creepDamage && creepDamage[i] || 0) >= this.drawCombatData[roomName].deathzone)
                        visual.text('\u{26A0}\u{FE0F}', i % 50, Math.floor(i / 50), textStyle);
            }
        }
    }
}
CombatData.structureWeight = {
    [STRUCTURE_SPAWN]: 2000,
    [STRUCTURE_TERMINAL]: 2000,
    [STRUCTURE_TOWER]: 1000,
    [STRUCTURE_STORAGE]: 1000,
    [STRUCTURE_INVADER_CORE]: 1000,
    [STRUCTURE_LAB]: 500,
    [STRUCTURE_EXTENSION]: 200,
    [STRUCTURE_LINK]: 200,
    [STRUCTURE_POWER_SPAWN]: 100,
    [STRUCTURE_NUKER]: 100,
    [STRUCTURE_OBSERVER]: 100,
    [STRUCTURE_FACTORY]: 100,
    [STRUCTURE_EXTRACTOR]: 100,
    [STRUCTURE_RAMPART]: 1,
    [STRUCTURE_WALL]: 1
};
CombatData.preferredTargets = new Set([
    STRUCTURE_SPAWN,
    STRUCTURE_TERMINAL,
    STRUCTURE_TOWER,
    STRUCTURE_STORAGE,
    STRUCTURE_INVADER_CORE,
    STRUCTURE_LAB
]);
__decorate([
    profile("Other" /* ProfilerFunctionType.Other */)
], CombatData, "getTowerPower", null);
__decorate([
    profile("Other" /* ProfilerFunctionType.Other */)
], CombatData, "getHostileCreepDamage", null);
__decorate([
    profile("Other" /* ProfilerFunctionType.Other */)
], CombatData, "getHostileCreepInfluence", null);
__decorate([
    profile("Other" /* ProfilerFunctionType.Other */)
], CombatData, "getAttackPoints", null);
CombatData.init();

class CostMatrixCache {
    static makeKey(roomName, offroad, ignoreRoads, stayUnderRampart) {
        return roomName
            + '.'
            + (offroad ? '1' : '0')
            + (ignoreRoads ? '1' : '0')
            + (stayUnderRampart ? '1' : '0');
    }
    static preTick() {
        for (let key in this._cache)
            if (Game.time > this._cache[key].expires)
                delete this._cache[key];
    }
    static postTick() {
    }
    static get(key) {
        if (this._cache[key])
            return this._cache[key].costMatrix.clone();
        else
            return null;
    }
    static set(key, costMatrix, timeout) {
        this._cache[key] = {
            expires: Game.time + timeout,
            costMatrix: costMatrix.clone()
        };
    }
}
CostMatrixCache._cache = {};
class PatherDebug {
    static addRecent(costMatrix) {
        let id = generateRandomKey(10);
        this._recentCostMatrices.push({
            id: id,
            costMatrix: costMatrix
        });
        if (this._recentCostMatrices.length > this.RecentCostMatrixCount)
            this._recentCostMatrices.shift();
        return id;
    }
    static stopView() {
        this._viewed = undefined;
    }
    static view(id) {
        let matrix = this._recentCostMatrices.find(cm => cm.id === id);
        if (!matrix)
            return ERROR_STR[ERR_NOT_FOUND];
        this._viewed = matrix.costMatrix;
        return ERROR_STR[OK];
    }
    static draw() {
        if (!this._viewed)
            return;
        for (let roomName in this._viewed) {
            let visual = Common.getRoomVisual(roomName);
            let costMatrix = this._viewed[roomName];
            for (let y = 0; y < 50; ++y) {
                for (let x = 0; x < 50; ++x) {
                    let value = costMatrix.get(x, y);
                    if (value === 255)
                        visual.rect(x - 0.5, y - 0.5, 1, 1, { fill: '#aa0000' });
                    else if (value > 0)
                        visual.text(value.toString(), x, y, { font: 0.5, color: '#ffffff', opacity: 0.5 });
                }
            }
        }
    }
}
PatherDebug.RecentCostMatrixCount = 100;
PatherDebug._recentCostMatrices = [];
class PatherUtils {
    static addStructures(costMatrix, room, roadCost) {
        let obstacleCost = 0xff;
        const structures = room.find(FIND_STRUCTURES);
        for (let s of structures) {
            const currentCost = costMatrix.get(s.pos.x, s.pos.y);
            if (s.structureType === STRUCTURE_RAMPART) {
                if (!room.controller || !s.my && (!Config.ALLIES.has(s.owner.username) || !s.isPublic) && !Config.RAMPART_PASSAGE.has(s.owner.username))
                    costMatrix.set(s.pos.x, s.pos.y, Math.max(currentCost, obstacleCost));
            }
            else if (s.structureType === STRUCTURE_ROAD) {
                costMatrix.set(s.pos.x, s.pos.y, Math.max(currentCost, roadCost));
            }
            else if (s.structureType === STRUCTURE_CONTAINER) {
                costMatrix.set(s.pos.x, s.pos.y, Math.max(currentCost, 5));
            }
            else if (s.structureType !== STRUCTURE_PORTAL) {
                costMatrix.set(s.pos.x, s.pos.y, obstacleCost);
            }
        }
        const roomIntel = GIntel.rooms[room.name];
        if (roomIntel && roomIntel.isFriendly) {
            const constructionSites = room.find(FIND_CONSTRUCTION_SITES);
            for (let c of constructionSites)
                if (!c.my || c.structureType !== STRUCTURE_ROAD && c.structureType !== STRUCTURE_CONTAINER && c.structureType !== STRUCTURE_RAMPART)
                    costMatrix.set(c.pos.x, c.pos.y, 0xff);
        }
    }
    static visualizePath(creepPos, path) {
        let fromPos = creepPos;
        for (let pathStep of path)
            if (fromPos.roomName === pathStep.roomName) {
                Common.getRoomVisual(fromPos.roomName).line(fromPos, pathStep, { color: '#ffffff', lineStyle: "dashed" });
                fromPos = pathStep;
            }
    }
}
class Pather {
    static get pathCache() {
        return Pather._pathCache;
    }
    static preTick() {
        Pather._obstacles.length = 0;
        Pather._moved = Pather._moved || {};
        for (let creepName in Pather._moved) {
            const creep = Game.creeps[creepName];
            const powerCreep = Game.powerCreeps[creepName];
            if ((!creep || !creep.pos.isEqualTo(Pather._moved[creepName])) && (!powerCreep || !powerCreep.pos.isEqualTo(Pather._moved[creepName]))) {
                const creepMemory = Memory.creeps[creepName];
                if (creepMemory)
                    creepMemory.excuseMe = undefined;
                const powerCreepMemory = Memory.powerCreeps[creepName];
                if (powerCreepMemory)
                    powerCreepMemory.excuseMe = undefined;
                delete Pather._moved[creepName];
            }
        }
    }
    static addMoved(creep) {
        Pather._moved[creep.name] = creep.pos;
    }
    static addObstacle(pos) {
        Pather._obstacles.push(pos);
    }
    static get obstacles() {
        return Pather._obstacles;
    }
    // ---------------------------------------------------------------------
    static getOptsHash(opts) {
        return ((+opts.dontIgnoreCreeps)
            | (+opts.ignoreHostileCreeps << 1)
            | (+opts.offroad << 2)
            | (+opts.ignoreRoads << 3)
            | (+opts.avoidUnsafeRooms << 4)
            | (+opts.avoidSourceKeepers << 5)
            | (+opts.avoidHostileRooms << 6)
            | (+opts.forceRecalc << 7)
            | (+opts.noCache << 8)
            | (+opts.noStuckDetection << 9)
            | ((opts.obstacles ? opts.obstacles.length : 0) << 20));
    }
    static getPathCacheKey(origin, goal, opts) {
        return origin.serialize() + '->' + goal.serialize()
            + (opts.offroad ? '1' : '0')
            + (opts.ignoreRoads ? '1' : '0')
            + (opts.avoidSourceKeepers ? '1' : '0')
            + (opts.avoidUnsafeRooms ? '1' : '0')
            + (opts.avoidHostileRooms ? '1' : '0')
            + '{' + (opts.obstacles ? opts.obstacles.length : 0) + '}';
    }
    static getPathCache(key) {
        if (!Pather.pathCache)
            Pather._pathCache = {};
        if (!Pather._pathCache[key])
            return undefined;
        Pather._pathCache[key].tick = Game.time;
        return _.clone(Pather._pathCache[key].path);
    }
    static postTick() {
        for (let key in Pather._pathCache)
            if (Game.time - Pather._pathCache[key].tick > Pather.PathCacheTimeout)
                delete Pather._pathCache[key];
        for (let key in Pather._bannedPaths)
            if (Pather._bannedPaths[key] < Game.time)
                delete Pather._bannedPaths[key];
        for (let creepName in Pather.goToMemory)
            if (!Game.creeps[creepName] && !Game.powerCreeps[creepName])
                delete Pather.goToMemory[creepName];
    }
    // ---------------------------------------------------------------------
    static isHostile(roomName) {
        const roomIntel = GIntel.rooms[roomName];
        return roomIntel
            && (roomIntel.towers > 0 || roomIntel.safeMode && Pather.isUnsafe(roomName))
            && (roomIntel.isCenterRoom || roomIntel.owner && !roomIntel.isMy && !roomIntel.isFriendly);
    }
    static isUnsafe(roomName) {
        const roomIntel = GIntel.rooms[roomName];
        return roomIntel && !roomIntel.isSafe;
    }
    static findRoute(from, to, opts) {
        let linearDistance = Game.map.getRoomLinearDistance(from, to);
        let fromRoomStatus = Game.map.getRoomStatus(from);
        let routeCallback = (roomName, fromRoomName) => {
            Profiler.push('Pather::routeCallback', "Pathing" /* ProfilerFunctionType.Pathing */);
            let roomStatus = Game.map.getRoomStatus(roomName);
            let result;
            if (Game.map.getRoomLinearDistance(from, roomName) > linearDistance + 3)
                return Infinity;
            else if (roomStatus.status !== fromRoomStatus.status)
                result = Infinity;
            else if (to !== roomName && from !== roomName && opts.avoidUnsafeRooms && Pather.isUnsafe(roomName))
                result = Infinity;
            else if (to !== roomName && from !== roomName && opts.avoidHostileRooms && Pather.isHostile(roomName))
                result = Infinity;
            else if (to !== roomName && from !== roomName && _.find(Game.flags, f => f.pos.roomName === roomName && f.color === COLOR_YELLOW && f.secondaryColor === COLOR_GREY))
                return Infinity;
            else
                result = 1;
            Profiler.pop();
            return result;
        };
        let allowedRooms = [];
        let route = Game.map.findRoute(from, to, { routeCallback: routeCallback });
        if (route !== ERR_NO_PATH) {
            allowedRooms = route.map(info => info.room);
            allowedRooms.unshift(from);
            if (opts.widen) {
                let originalRoute = [...allowedRooms];
                for (let roomName of originalRoute) {
                    let exits = Game.map.describeExits(roomName);
                    for (let key in exits)
                        if (!allowedRooms.includes(exits[key]) && routeCallback(exits[key]) !== Infinity)
                            allowedRooms.push(exits[key]);
                }
            }
        }
        else
            console.log("couldn't find route: " + from + '->' + to);
        return allowedRooms;
    }
    // ---------------------------------------------------------------------
    static getRoomCallback(origin, goal, route, opts, out) {
        return (roomName) => {
            ++out.roomsReached;
            if (route && !route.includes(roomName)) {
                return false;
            }
            let goalRoomName = goal && goal.roomName;
            if (opts.avoidHostileRooms
                && origin.roomName !== roomName
                && goalRoomName !== roomName
                && Pather.isHostile(roomName)) {
                return false;
            }
            if (opts.avoidUnsafeRooms
                && origin.roomName !== roomName
                && goalRoomName !== roomName
                && Pather.isUnsafe(roomName)) {
                return false;
            }
            if (origin.roomName !== roomName
                && goalRoomName !== roomName
                && _.find(Game.flags, f => f.pos.roomName === roomName && f.color === COLOR_YELLOW && f.secondaryColor === COLOR_GREY)) {
                return false;
            }
            Profiler.push('Pather::roomCallback', "Pathing" /* ProfilerFunctionType.Pathing */);
            let room = Game.rooms[roomName];
            const matrixCacheKey = CostMatrixCache.makeKey(roomName, opts.offroad, opts.ignoreRoads, opts.stayUnderRampart);
            let costMatrix = CostMatrixCache.get(matrixCacheKey);
            if (!costMatrix) {
                costMatrix = new PathFinder.CostMatrix();
                // stay under rampart
                if (room && room.myRoom && opts.stayUnderRampart) {
                    let hostiles = room.findHostileCreeps();
                    for (let y = 1; y < 49; ++y)
                        for (let x = 1; x < 49; ++x) {
                            let structuresOnTile = room.lookForAt(LOOK_STRUCTURES, x, y);
                            if (structuresOnTile.find(s => s.structureType === STRUCTURE_RAMPART))
                                costMatrix.set(x, y, structuresOnTile.find(s => s.structureType === STRUCTURE_ROAD) ? 1 : 5);
                            else if (hostiles.some(h => h.getActiveBodyparts(ATTACK) && h.pos.inRangeTo(x, y, 1) || h.getActiveBodyparts(RANGED_ATTACK) && h.pos.inRangeTo(x, y, 3)))
                                costMatrix.set(x, y, 0xff);
                            else
                                costMatrix.set(x, y, 250);
                        }
                }
                if (room) {
                    let roadCost = (opts.offroad || !opts.ignoreRoads) ? 1 : 2;
                    PatherUtils.addStructures(costMatrix, room, roadCost);
                }
                // portals
                if (!opts.allowPortals && GIntel.rooms[roomName] && GIntel.rooms[roomName].portals) {
                    for (let portal of GIntel.rooms[roomName].portals) {
                        costMatrix.set(portal.pos.x, portal.pos.y, 0xff);
                    }
                }
                //
                if (room) {
                    CostMatrixCache.set(matrixCacheKey, costMatrix, 100);
                }
            }
            if (room) {
                // creeps
                if (opts.dontIgnoreCreeps) {
                    for (let c of room.find(FIND_CREEPS))
                        costMatrix._bits[c.pos.x * 50 + c.pos.y] = 0xff;
                }
                else if (!opts.ignoreHostileCreeps && (!room.intel.isMy || !room.intel.safeMode)) {
                    for (let c of room.find(FIND_HOSTILE_CREEPS))
                        costMatrix._bits[c.pos.x * 50 + c.pos.y] = 0xff;
                }
            }
            // avoid sourceKeepers
            if (opts.avoidSourceKeepers && GIntel.rooms[roomName] && GIntel.rooms[roomName].sourceKeeperSpots && goal) {
                let scoutedRoom = GIntel.rooms[roomName];
                for (let tilePos of scoutedRoom.sourceKeeperSpots) {
                    if (!goal.inRangeTo(tilePos, 3) && !origin.inRangeTo(tilePos, 3))
                        costMatrix.setArea(tilePos, 3, 0xff);
                }
            }
            // obstacles
            if (opts.obstacles) {
                for (let o of opts.obstacles)
                    if (o.roomName === roomName)
                        costMatrix._bits[o.x * 50 + o.y] = 0xff;
            }
            for (let o of Pather._obstacles)
                if (o.roomName === roomName)
                    costMatrix._bits[o.x * 50 + o.y] = 0xff;
            //
            if (opts.maxRooms === 1) {
                let exits = Common.getExitTiles(roomName);
                for (let e of exits)
                    costMatrix._bits[e.x * 50 + e.y] = 0xff;
            }
            out.costMatrices[roomName] = costMatrix;
            Profiler.pop();
            return costMatrix;
        };
    }
    static findPath(origin, goal, opts, creepName) {
        opts = opts || {};
        if (opts.avoidSourceKeepers === undefined)
            opts.avoidSourceKeepers = true;
        if (opts.avoidHostileRooms === undefined)
            opts.avoidHostileRooms = true;
        let route;
        let roomCallbackOut = {
            roomsReached: 0,
            costMatrices: {}
        };
        let pathFinderOpts = {
            roomCallback: Pather.getRoomCallback(origin, goal.pos, route, opts, roomCallbackOut),
            flee: opts.flee,
            plainCost: opts.offroad ? 1 : 2,
            swampCost: opts.offroad ? 1 : 10,
            maxOps: opts.maxOps || 10000,
            maxCost: opts.maxCost,
            maxRooms: opts.maxRooms
        };
        let searchResult = PathFinder.search(origin, goal, pathFinderOpts);
        if (searchResult.incomplete && opts.ensurePath) {
            let routeOpts = {
                avoidHostileRooms: opts.avoidHostileRooms,
                avoidUnsafeRooms: opts.avoidUnsafeRooms,
                widen: true
            };
            route = Pather.findRoute(origin.roomName, goal.pos.roomName, routeOpts);
            roomCallbackOut.roomsReached = 0;
            pathFinderOpts.roomCallback = Pather.getRoomCallback(origin, goal.pos, route, opts, roomCallbackOut);
            pathFinderOpts.maxRooms = 64;
            pathFinderOpts.maxOps = 20000;
            searchResult = PathFinder.search(origin, goal, pathFinderOpts);
        }
        if (searchResult.incomplete) {
            let debugId = PatherDebug.addRecent(roomCallbackOut.costMatrices);
            let targetRoomCM = roomCallbackOut.costMatrices[goal.pos.roomName];
            let targetCMValue = targetRoomCM ? targetRoomCM.get(goal.pos.x, goal.pos.y) : undefined;
            if (Memory.toggles.logFailedPathfinding) {
                console.log('path incomplete:'
                    + ' ' + origin.link() + '-> (' + goal.pos.link() + ', range=' + goal.range + ')'
                    + ', ops=' + searchResult.ops
                    + ', cost=' + searchResult.cost
                    + ', length=' + searchResult.path.length
                    + ', roomsReached=' + roomCallbackOut.roomsReached
                    + ', last step: ' + ((searchResult.path && searchResult.path.length > 0) ? _.last(searchResult.path).link() : 'none')
                    + ', debugId: ' + debugId
                    + (route ? ', route: ' + JSON.stringify(route) : '')
                    + (creepName ? ', creepName: ' + creepName : '')
                    + ', targetCachedCMValue: ' + (_.isUndefined(targetCMValue) ? '?' : targetCMValue));
            }
        }
        else if (opts.debug && Memory.toggles.logPathfindingDebug) {
            let debugId = PatherDebug.addRecent(roomCallbackOut.costMatrices);
            console.log('debug pathfinding: '
                + ' ' + origin.link() + '-> (' + goal.pos.link() + ', range=' + goal.range + ')'
                + ', ops=' + searchResult.ops
                + ', cost=' + searchResult.cost
                + ', length=' + searchResult.path.length
                + ', debugId: ' + debugId
                + (route ? ', route: ' + JSON.stringify(route) : '')
                + (creepName ? ', creepName: ' + creepName : ''));
        }
        return searchResult;
    }
    static findPathToClosest(origin, goals, opts, creepName) {
        opts = opts || {};
        if (opts.avoidSourceKeepers === undefined)
            opts.avoidSourceKeepers = true;
        if (opts.avoidHostileRooms === undefined)
            opts.avoidHostileRooms = true;
        let roomCallbackOut = {
            roomsReached: 0,
            costMatrices: {}
        };
        let pathFinderOpts = {
            roomCallback: Pather.getRoomCallback(origin, undefined, undefined, opts, roomCallbackOut),
            flee: opts.flee,
            plainCost: opts.offroad ? 1 : 2,
            swampCost: opts.offroad ? 1 : 10,
            maxOps: opts.maxOps || 5000,
            maxCost: opts.maxCost,
            maxRooms: opts.maxRooms
        };
        let searchResult = PathFinder.search(origin, goals, pathFinderOpts);
        if (searchResult.incomplete) {
            let debugId = PatherDebug.addRecent(roomCallbackOut.costMatrices);
            if (Memory.toggles.logFailedPathfinding) {
                console.log('path incomplete:'
                    + ' ' + origin.link() + '-> (' + goals.map(goal => '{pos: ' + goal.pos.link() + ', range' + goal.range + '}').join(', ') + ')'
                    + ', ops=' + searchResult.ops
                    + ', cost=' + searchResult.cost
                    + ', length=' + searchResult.path.length
                    + ', roomsReached=' + roomCallbackOut.roomsReached
                    + ', last step: ' + ((searchResult.path && searchResult.path.length > 0) ? _.last(searchResult.path).link() : 'none')
                    + ', debugId: ' + debugId
                    + (creepName ? ', creepName: ' + creepName : ''));
            }
        }
        else if (opts.debug && Memory.toggles.logPathfindingDebug) {
            let debugId = PatherDebug.addRecent(roomCallbackOut.costMatrices);
            console.log('debug pathfinding: '
                + ' ' + origin.link() + '-> (' + goals.map(goal => '{pos: ' + goal.pos.link() + ', range' + goal.range + '}').join(', ') + ')'
                + ', ops=' + searchResult.ops
                + ', cost=' + searchResult.cost
                + ', length=' + searchResult.path.length
                + ', debugId: ' + debugId
                + (creepName ? ', creepName: ' + creepName : ''));
        }
        return searchResult;
    }
    // ---------------------------------------------------------------------
    static flee(creep, targets, opts) {
        opts = opts || {};
        if (opts.avoidSourceKeepers === undefined)
            opts.avoidSourceKeepers = true;
        if (opts.dontIgnoreCreeps === undefined)
            opts.dontIgnoreCreeps = true;
        opts.flee = true;
        let searchResult = Pather.findPathToClosest(creep.pos, targets, opts, creep.name);
        if (searchResult.path.length > 0) {
            let direction = creep.pos.getDirectionTo(searchResult.path[0]);
            creep.move(direction);
        }
    }
    static goTo(creep, goal, range, opts) {
        let result = OK;
        opts = opts || {};
        let inRange = creep.pos.inRangeTo(goal, range);
        if (inRange && !opts.flee)
            return result;
        if (opts.avoidSourceKeepers === undefined)
            opts.avoidSourceKeepers = true;
        if (opts.avoidHostileRooms === undefined)
            opts.avoidHostileRooms = true;
        let optsHash = Pather.getOptsHash(opts);
        if (!Pather.goToMemory[creep.name]) {
            Pather.goToMemory[creep.name] = {
                lastPos: creep.pos,
                goal: goal,
                optsHash: optsHash,
                path: [],
                range: range,
                stuck: 0
            };
        }
        let goToMemory = Pather.goToMemory[creep.name];
        // stuck detection
        let moved = goToMemory.path.length > 0 && creep.pos.isEqualTo(goToMemory.path[0]) || (creep.pos.x === 0 || creep.pos.y === 0 || creep.pos.x === 49 || creep.pos.y === 49);
        if (!moved && creep.fatigue === 0 || creep.pos.isExit())
            ++goToMemory.stuck;
        else
            goToMemory.stuck = 0;
        // if stuck, move randomly
        let ticksTillStuck = 3;
        if (!opts.noStuckDetection && goToMemory.stuck > ticksTillStuck) {
            let direction = Common.getRandomDir();
            creep.move(direction);
            goToMemory.stuck = 0;
            goToMemory.path = [];
            opts.noCache = true;
            if (creep.fatigue === 0)
                Common.excuseMe(creep.pos, direction);
        }
        else {
            // update path in memory
            if (goToMemory.path.length > 0 && moved)
                goToMemory.path.shift();
            // room edge
            if (goToMemory.path.length > 0 && creep.pos.isEqualTo(goToMemory.path[0]))
                goToMemory.path.shift();
            // get new path
            if (goToMemory.path.length === 0 || !goToMemory.goal.isEqualTo(goal) || goToMemory.range !== range || goToMemory.optsHash !== optsHash) {
                let path;
                const pathCacheKey = Pather.getPathCacheKey(creep.pos, goal, opts);
                // get cached path
                if (!opts.forceRecalc)
                    path = Pather.getPathCache(pathCacheKey);
                if (!path || path.length === 0 || Math.random() < 0.05) {
                    let searchResult;
                    // don't recalculate banned path
                    if (pathCacheKey in Pather._bannedPaths) {
                        searchResult = { path: [], incomplete: true, ops: 0, cost: 0 };
                        creep.say('\u{26D4}', false);
                        creep.giveWay();
                    }
                    // recalculate path
                    else {
                        searchResult = Pather.findPath(creep.pos, { pos: goal, range: range }, opts, creep.name);
                    }
                    path = searchResult.path;
                    if (Memory.toggles.visualPathfinding) {
                        PatherUtils.visualizePath(creep.pos, searchResult.path);
                    }
                    if (searchResult.incomplete) {
                        result = ERR_NO_PATH;
                        Pather._bannedPaths[pathCacheKey] = Game.time + Pather.banTime;
                    }
                    if (!opts.flee && !opts.noCache && !searchResult.incomplete && path.length >= Pather.PathCacheMinimumLength) {
                        Pather.pathCache[pathCacheKey] = {
                            tick: Game.time,
                            path: _.clone(searchResult.path)
                        };
                    }
                }
                goToMemory.path = path;
                goToMemory.optsHash = optsHash;
            }
            // move
            if (goToMemory.path.length > 0) {
                let direction = creep.pos.getDirectionTo(goToMemory.path[0]);
                creep.move(direction, true);
            }
        }
        goToMemory.lastPos = creep.pos;
        goToMemory.goal = goal;
        goToMemory.range = range;
        goToMemory.optsHash = optsHash;
        return result;
    }
    static sneakGoTo(creeps, goal, range, opts) {
        const textStyle = { font: 0.5, color: '#444444' };
        let wait = false;
        for (let i = creeps.length - 1; i > 0; --i) {
            let creep = creeps[i];
            creep.room.visual.text(i.toString(), creep.pos.x, creep.pos.y + 0.25, textStyle);
            if (wait && Game.time % 2 === 1)
                creeps[i].giveWay(true);
            else if (creeps[i].pos.isNearTo(creeps[i - 1])) {
                creeps[i - 1].pull(creeps[i]);
                creeps[i].move(creeps[i - 1]);
            }
            else {
                creeps[i].goTo(creeps[i - 1].pos, 0);
                if (creeps[i].pos.roomName === creeps[i - 1].pos.roomName)
                    wait = true;
            }
        }
        creeps[0].room.visual.text('0', creeps[0].pos.x, creeps[0].pos.y + 0.25, textStyle);
        if (!wait || Game.time % 2 === 0)
            Pather.goTo(creeps[0], goal, range, opts);
    }
}
Pather.PathCacheTimeout = 600;
Pather.PathCacheMinimumLength = 10;
// ---------------------------------------------------------------------
Pather._obstacles = [];
// ---------------------------------------------------------------------
Pather.banTime = 30;
// path key, expiration time
Pather._bannedPaths = {};
// ---------------------------------------------------------------------
Pather.goToMemory = {};
__decorate([
    profile("Pathing" /* ProfilerFunctionType.Pathing */)
], Pather, "postTick", null);
__decorate([
    profile("Pathing" /* ProfilerFunctionType.Pathing */)
], Pather, "findRoute", null);
__decorate([
    profile("Pathing" /* ProfilerFunctionType.Pathing */)
], Pather, "findPath", null);
__decorate([
    profile("Pathing" /* ProfilerFunctionType.Pathing */)
], Pather, "findPathToClosest", null);
__decorate([
    profile("Pathing" /* ProfilerFunctionType.Pathing */)
], Pather, "flee", null);
__decorate([
    profile("Pathing" /* ProfilerFunctionType.Pathing */)
], Pather, "goTo", null);
class CombatPather {
    static getSquadPosition(leaderPos, index) {
        let x = leaderPos.x + index % 2;
        let y = leaderPos.y + Math.floor(index / 2);
        let roomCoords = Common.getRoomCoords(leaderPos.roomName);
        let horizontalDir = leaderPos.roomName[0];
        let verticalDir = leaderPos.roomName[1 + roomCoords.x.toString().length];
        if (x >= 50) {
            x -= 50;
            roomCoords.x += 1;
        }
        if (x < 0) {
            x += 50;
            roomCoords.x -= 1;
        }
        if (y >= 50) {
            y -= 50;
            roomCoords.y += 1;
        }
        if (y < 0) {
            y += 50;
            roomCoords.y -= 1;
        }
        let roomName = horizontalDir + roomCoords.x + verticalDir + roomCoords.y;
        return new RoomPosition(x, y, roomName);
    }
    static moveDuo(creep0, creep1, direction) {
        if (creep1.pos.isNearTo(creep0)) {
            creep0.pull(creep1);
            creep1.move(creep0);
            creep0.move(direction, true);
        }
        else {
            creep1.goTo(creep0.pos, 1);
            if (creep0.pos.isExit())
                creep0.move(direction, true);
        }
    }
    // @ts-ignore: Unused code
    static fastRegenExploit(groupedCreeps) {
        let fatigued = [];
        let rested = [];
        for (let c of groupedCreeps) {
            if (c.fatigue > 0)
                fatigued.push(c);
            else
                rested.push(c);
        }
        let arrows = ['\u{1F871}', '\u{1F875}', '\u{1F872}', '\u{1F876}', '\u{1F873}', '\u{1F877}', '\u{1F870}', '\u{1F874}'];
        while (fatigued.length > 0 && rested.length > 0) {
            let f = fatigued.shift();
            let r = rested.shift();
            f.pull(r);
            r.room.visual.text(arrows[r.pos.getDirectionTo(f.pos) - 1], r.pos.x, r.pos.y, { align: 'center', font: 0.5, color: '#55ff55', opacity: 1 });
            fatigued.push(r);
        }
    }
    static moveQuad(leader, direction, members) {
        const squad = [leader, ...members];
        let areGroupedUp = true;
        for (let i = 0; i < squad.length; ++i) {
            const creep = squad[i];
            const targetPos = this.getSquadPosition(leader.pos, i);
            if (creep.pos.isExit()) // && creep.pos.inInterroomRangeTo(targetPos, 1))
                continue;
            if (creep.pos.isEqualTo(targetPos))
                continue;
            creep.room.visual.text('\u{1F61F}', creep.pos.x, creep.pos.y, { align: 'center', opacity: 0.5 });
            areGroupedUp = false;
        }
        if (areGroupedUp) {
            if (direction !== undefined) {
                let canMove = [leader, ...members].every(m => {
                    if (m.fatigue > 0)
                        return false;
                    if (m.pos.isExit())
                        return true;
                    let nextPos = m.pos.nextPosition(direction);
                    if (nextPos.lookFor(LOOK_CREEPS).find(c => !c.my))
                        return false;
                    if (nextPos.lookFor(LOOK_STRUCTURES).find(s => s.isObstacle()))
                        return false;
                    return true;
                });
                if (canMove) {
                    for (let creep of squad)
                        creep.move(direction, true);
                }
                else {
                    this.fastRegenExploit(squad);
                }
            }
        }
        else {
            let terrain = Game.map.getRoomTerrain(leader.pos.roomName);
            let canGroupUp = true;
            for (let i = 0; i < members.length; ++i) {
                let member = members[i];
                let squadPos = this.getSquadPosition(leader.pos, i + 1);
                let isWall = ((terrain.get(squadPos.x, squadPos.y) & TERRAIN_MASK_WALL) > 0);
                if (isWall)
                    canGroupUp = false;
                if (squadPos.isExit())
                    canGroupUp = false;
                if (member.pos.isEqualTo(squadPos) || isWall)
                    member.giveWay(true);
                else
                    member.goTo(squadPos, 0, { debug: true });
            }
            if (!canGroupUp || squad.some(member => member.pos.isExit())) // leader.pos.isExit())
                leader.move(direction, true);
            else
                leader.giveWay(true);
        }
    }
    static getRoomCallback(origin, goal, opts, out) {
        return (roomName) => {
            ++out.roomsReached;
            Profiler.push('CombatPather::roomCallback', "Pathing" /* ProfilerFunctionType.Pathing */);
            let room = Game.rooms[roomName];
            const avoidDamagePlainCost = 15;
            const avoidDamageSwampCost = 60;
            const avoidDamagePlainNextToRampCost = 60;
            const avoidDamageSwampNextToRampCost = 240;
            const swampCost = 5;
            const roadCost = 1;
            let matrixCacheKey = CostMatrixCache.makeKey(roomName, false, true, false);
            let costMatrix = CostMatrixCache.get(matrixCacheKey);
            if (!costMatrix) {
                costMatrix = new PathFinder.CostMatrix();
                //
                if (room) {
                    PatherUtils.addStructures(costMatrix, room, roadCost);
                    let myConstructionSites = room.find(FIND_MY_CONSTRUCTION_SITES);
                    for (let cs of myConstructionSites)
                        if (OBSTACLE_STRUCTURE_TYPES.has(cs.structureType))
                            costMatrix.set(cs.pos.x, cs.pos.y, 0xff);
                }
                // portals
                if (GIntel.rooms[roomName] && GIntel.rooms[roomName].portals) {
                    for (let portal of GIntel.rooms[roomName].portals) {
                        costMatrix.set(portal.pos.x, portal.pos.y, 0xff);
                    }
                }
                if (room)
                    CostMatrixCache.set(matrixCacheKey, costMatrix, 10);
            }
            if (room) {
                // creeps
                if (opts.dontIgnoreCreeps) {
                    let ignorePositions = [origin];
                    if (opts.squadMembers) {
                        for (let member of opts.squadMembers) {
                            ignorePositions.push(member.pos);
                        }
                    }
                    if (goal.range === 0) {
                        ignorePositions.push(goal.pos);
                        if (opts.squadMembers && opts.squadMembers.length > 1) {
                            if (goal.pos.x < 49)
                                ignorePositions.push(new RoomPosition(goal.pos.x + 1, goal.pos.y, goal.pos.roomName));
                            if (goal.pos.y < 49)
                                ignorePositions.push(new RoomPosition(goal.pos.x, goal.pos.y + 1, goal.pos.roomName));
                            if (goal.pos.x < 49 && goal.pos.y < 49)
                                ignorePositions.push(new RoomPosition(goal.pos.x + 1, goal.pos.y + 1, goal.pos.roomName));
                        }
                    }
                    for (let c of room.find(FIND_CREEPS)) {
                        if (ignorePositions.some(pos => c.pos.isEqualTo(pos)))
                            continue;
                        if (c.pos.inRangeTo(goal, 1))
                            continue;
                        if (c.pos.inRangeTo(origin, 1))
                            continue;
                        costMatrix.set(c.pos.x, c.pos.y, 0xff);
                    }
                }
                // hostile creeps and tower damage
                if (opts.avoidDamage) {
                    const roomIntel = GIntel.rooms[roomName];
                    let terrain = Game.map.getRoomTerrain(roomName).getRawBuffer();
                    let towerPower = (roomIntel && roomIntel.isFriendly) ? undefined : CombatData.getTowerPower(roomName);
                    let creepDamage = CombatData.getHostileCreepInfluence(roomName);
                    for (let y = 0; y < 50; ++y) {
                        for (let x = 0; x < 50; ++x) {
                            const index = y * 50 + x;
                            const terrainFlags = terrain[index];
                            if (terrainFlags & TERRAIN_MASK_WALL)
                                continue;
                            const rampartOnTile = room.lookForAt(LOOK_STRUCTURES, x, y).find(s => s.structureType === STRUCTURE_RAMPART && s.isMy());
                            let damageOnTile = 0;
                            if (!rampartOnTile) {
                                if (creepDamage)
                                    damageOnTile += creepDamage[index];
                                if (towerPower)
                                    damageOnTile += towerPower[index] * TOWER_POWER_ATTACK;
                            }
                            if (damageOnTile <= opts.avoidDamage)
                                continue;
                            let isNextToRamp = false;
                            for (let i = TOP; i <= TOP_RIGHT; ++i) {
                                const xx = x + Common.offsetX[i];
                                const yy = y + Common.offsetY[i];
                                if (xx < 1 || xx > 48 || yy < 1 || yy > 48)
                                    continue;
                                if (room.lookForAt(LOOK_STRUCTURES, xx, yy).find(s => s.structureType === STRUCTURE_RAMPART)) {
                                    isNextToRamp = true;
                                    break;
                                }
                            }
                            const cmIndex = x * 50 + y;
                            const currentValue = costMatrix._bits[cmIndex];
                            if (terrainFlags & TERRAIN_MASK_SWAMP)
                                costMatrix._bits[cmIndex] = Math.max(currentValue, isNextToRamp ? avoidDamageSwampNextToRampCost : avoidDamageSwampCost);
                            else
                                costMatrix._bits[cmIndex] = Math.max(currentValue, isNextToRamp ? avoidDamagePlainNextToRampCost : avoidDamagePlainCost);
                        }
                    }
                }
            }
            //
            if (opts.maxRooms === 1) {
                let exits = Common.getExitTiles(roomName);
                for (let e of exits)
                    costMatrix._bits[e.x * 50 + e.y] = 0xff;
            }
            // obstacles
            if (opts.obstacles) {
                for (let o of opts.obstacles)
                    if (o.roomName === roomName)
                        costMatrix._bits[o.x * 50 + o.y] = 0xff;
            }
            // avoid narrow paths
            if (opts.avoidNarrowPaths) {
                const closeToWallCost = 0xff;
                let terrain = Game.map.getRoomTerrain(roomName).getRawBuffer();
                for (let x = 0; x < 49; ++x)
                    for (let y = 0; y < 49; ++y) {
                        const cmIndex = x * 50 + y;
                        let cost = costMatrix._bits[cmIndex];
                        const terrainIndex = y * 50 + x;
                        let terrain00 = terrain[terrainIndex];
                        let terrain10 = terrain[terrainIndex + 1];
                        let terrain01 = terrain[terrainIndex + 50];
                        let terrain11 = terrain[terrainIndex + 51];
                        if ((terrain00 & TERRAIN_MASK_WALL) > 0)
                            cost = 0xff;
                        else if ((terrain10 & TERRAIN_MASK_WALL) > 0 || (terrain01 & TERRAIN_MASK_WALL) > 0 || (terrain11 & TERRAIN_MASK_WALL) > 0)
                            cost = Math.max(cost, closeToWallCost);
                        else if ((terrain00 & TERRAIN_MASK_SWAMP) > 0 || (terrain10 & TERRAIN_MASK_SWAMP) > 0 || (terrain01 & TERRAIN_MASK_SWAMP) > 0 || (terrain11 & TERRAIN_MASK_SWAMP) > 0)
                            cost = Math.max(cost, swampCost);
                        cost = Math.max(cost, costMatrix._bits[cmIndex + 1], costMatrix._bits[cmIndex + 50], costMatrix._bits[cmIndex + 51]);
                        costMatrix._bits[cmIndex] = cost;
                    }
            }
            out.costMatrices[roomName] = costMatrix;
            Profiler.pop();
            return costMatrix;
        };
    }
    static findPath(origin, goal, opts, creepName) {
        opts = opts || {};
        let roomCallbackOut = {
            roomsReached: 0,
            costMatrices: {}
        };
        let pathFinderOpts = {
            roomCallback: CombatPather.getRoomCallback(origin, goal, opts, roomCallbackOut),
            flee: opts.flee,
            plainCost: 1,
            swampCost: 5,
            maxOps: 5000,
            maxRooms: opts.maxRooms
        };
        let searchResult = PathFinder.search(origin, goal, pathFinderOpts);
        if (searchResult.incomplete) {
            let debugId = PatherDebug.addRecent(roomCallbackOut.costMatrices);
            if (Memory.toggles.logFailedPathfinding) {
                let targetRoomCM = roomCallbackOut.costMatrices[goal.pos.roomName];
                let targetCMValue = targetRoomCM ? targetRoomCM.get(goal.pos.x, goal.pos.y) : undefined;
                console.log('path incomplete:'
                    + ' ' + origin.link() + '-> (' + goal.pos.link() + ', range=' + goal.range + ')'
                    + ', ops=' + searchResult.ops
                    + ', cost=' + searchResult.cost
                    + ', length=' + searchResult.path.length
                    + ', roomsReached=' + roomCallbackOut.roomsReached
                    + ', last step: ' + ((searchResult.path && searchResult.path.length > 0) ? _.last(searchResult.path).link() : 'none')
                    + ', debugId: ' + debugId
                    + (creepName ? ', creepName: ' + creepName : '')
                    + ', targetCachedCMValue: ' + (_.isUndefined(targetCMValue) ? '?' : targetCMValue));
            }
        }
        else if (opts.debug && Memory.toggles.logPathfindingDebug) {
            let debugId = PatherDebug.addRecent(roomCallbackOut.costMatrices);
            console.log('debug pathfinding:'
                + ' ' + origin.link() + '-> (' + goal.pos.link() + ', range=' + goal.range + ')'
                + ', ops=' + searchResult.ops
                + ', cost=' + searchResult.cost
                + ', length=' + searchResult.path.length
                + ', debugId: ' + debugId
                + (creepName ? ', creepName: ' + creepName : ''));
        }
        return searchResult;
    }
    static goTo(creep, goal, range, opts) {
        let result = OK;
        opts = opts || {};
        let inRange = creep.pos.inRangeTo(goal, range) && (!opts.squadMembers || opts.squadMembers.every(c => c.pos.inRangeTo(goal, range + 1)));
        if (inRange && !opts.flee && !opts.squadMembers)
            return result;
        if (!Pather.goToMemory[creep.name]) {
            Pather.goToMemory[creep.name] = {
                lastPos: creep.pos,
                goal: goal,
                optsHash: 0,
                path: [],
                range: range,
                stuck: 0
            };
        }
        let goToMemory = Pather.goToMemory[creep.name];
        // stuck detection
        let moved = goToMemory.path.length > 0 && creep.pos.isEqualTo(goToMemory.path[0]) || (creep.pos.x === 0 || creep.pos.y === 0 || creep.pos.x === 49 || creep.pos.y === 49);
        if (!inRange && !moved && creep.fatigue === 0 && (!opts.squadMembers || opts.squadMembers.every(m => m.fatigue === 0)))
            ++goToMemory.stuck;
        else
            goToMemory.stuck = 0;
        // if stuck, move randomly
        let ticksTillStuck = 3;
        if (goToMemory.stuck > ticksTillStuck) {
            let direction = Common.getRandomDir();
            if (!opts.squadMembers || opts.squadMembers.length === 0)
                creep.move(direction, true);
            else if (opts.squadMembers.length === 1)
                CombatPather.moveDuo(creep, opts.squadMembers[0], direction);
            else
                CombatPather.moveQuad(creep, direction, opts.squadMembers);
            goToMemory.stuck = 0;
            goToMemory.path = [];
            if (creep.fatigue === 0)
                Common.excuseMe(creep.pos, direction);
        }
        else {
            // update path in memory
            if (goToMemory.path.length > 0 && moved)
                goToMemory.path.shift();
            // room edge
            if (goToMemory.path.length > 0 && creep.pos.isEqualTo(goToMemory.path[0]))
                goToMemory.path.shift();
            // danger zone - repath
            let inDangerZone = creep.room.findHostileCreeps().some(h => {
                if (h.pos.inRangeTo(creep.pos, 5) && h.getActiveBodyparts(RANGED_ATTACK) > 0)
                    return true;
                if (h.pos.inRangeTo(creep.pos, 3) && h.getActiveBodyparts(ATTACK) > 0)
                    return true;
                return false;
            });
            // get new path
            if (inDangerZone || goToMemory.path.length === 0 || !goToMemory.goal.isEqualTo(goal) || goToMemory.range !== range || goToMemory.optsHash !== 0) {
                let searchResult = CombatPather.findPath(creep.pos, { pos: goal, range: range }, opts, creep.name);
                if (Memory.toggles.visualPathfinding) {
                    PatherUtils.visualizePath(creep.pos, searchResult.path);
                }
                if (searchResult.incomplete)
                    result = ERR_NO_PATH;
                goToMemory.path = searchResult.path;
                goToMemory.optsHash = 0;
            }
            // move
            if (goToMemory.path.length > 0) {
                let direction = creep.pos.getDirectionTo(goToMemory.path[0]);
                if (!opts.squadMembers || opts.squadMembers.length === 0)
                    creep.move(direction, true);
                else if (opts.squadMembers.length === 1)
                    CombatPather.moveDuo(creep, opts.squadMembers[0], direction);
                else
                    CombatPather.moveQuad(creep, direction, opts.squadMembers);
            }
            else if (opts.squadMembers && opts.squadMembers.length > 2) {
                CombatPather.moveQuad(creep, undefined, opts.squadMembers);
            }
        }
        goToMemory.lastPos = creep.pos;
        goToMemory.goal = goal;
        goToMemory.range = range;
        goToMemory.optsHash = 0;
        return result;
    }
}
__decorate([
    profile("Pathing" /* ProfilerFunctionType.Pathing */)
], CombatPather, "findPath", null);
__decorate([
    profile("Pathing" /* ProfilerFunctionType.Pathing */)
], CombatPather, "goTo", null);
global.Pather = Pather;
global.CombatPather = CombatPather;
global.CostMatrixCache = CostMatrixCache;
global.PatherDebug = PatherDebug;

var Priority = function (tier, operationPriority) {
    return (30 - tier) * 100 + operationPriority;
};
const StartedSquadPriority = Priority(0, 13);
const FlagSpawnPriority = Priority(0, 10);

class BaseOperation {
    constructor(empire) {
        this.empire = empire;
        this.creeps = [];
        this._spawnRequests = undefined;
        this.shouldUpdateEstimatedStats = true;
        this.estimatedStats = {
            baseCpu: 0,
            cpu: 0,
            energyPerTick: 0,
            spawnTime: 0
        };
    }
    // ---------------------------------------------------------------------
    initForTick() {
        let startCpu = Game.cpu.getUsed();
        this._spawnRequests = undefined;
        this.creeps = [];
        let deceasedCreepCount = 0;
        for (let creepName of this.memory.creeps) {
            let creep = Game.creeps[creepName];
            if (creep) {
                this.creeps.push(creep);
            }
            else {
                this.onCreepDeath(creepName);
                ++deceasedCreepCount;
            }
        }
        if (deceasedCreepCount > 0) {
            this.memory.creeps = this.memory.creeps.filter(creepName => Game.creeps[creepName]);
            this._spawnRequests = undefined;
        }
        this.onInitForTick();
        this.cpuUsedThisTick = Game.cpu.getUsed() - startCpu;
    }
    onInitForTick() {
    }
    getSpawnRequests() {
        if (this._spawnRequests === undefined) {
            this._spawnRequests = this.getSpawnRequestsInternal();
        }
        return this._spawnRequests;
    }
    onSpawn(requestId, creepName) {
        this.memory.creeps.push(creepName);
        this._spawnRequests = undefined;
    }
    dismissCreep(creep, recycle, repurpose) {
        let creepIndex = this.memory.creeps.findIndex(name => name === creep.name);
        if (creepIndex !== -1) {
            this.empire.idle.addCreep(creep, recycle, repurpose);
            this.memory.creeps.splice(creepIndex, 1);
            this._spawnRequests = undefined;
        }
    }
    onCreepDeath(creepName) {
    }
    // ---------------------------------------------------------------------
    getEstimatedStats() {
        if (this.shouldUpdateEstimatedStats) {
            this.updateEstimatedStats();
            this.shouldUpdateEstimatedStats = false;
        }
        return this.estimatedStats;
    }
    get room() {
        return Game.rooms[this.roomName];
    }
    get spawnRoom() {
        return Game.rooms[this.spawnRoomName];
    }
    // ---------------------------------------------------------------------
    boostCreep(creep) {
        let myRoom = this.spawnRoom.myRoom;
        let moved = false;
        creep.memory.boosts = creep.memory.boosts.filter(b => {
            if (!creep.body.find(bp => bp.type === BOOST_TO_BODYPART[b])) {
                console.log(creep.name, 'requested', b, 'even though it doesn\'t have', BOOST_TO_BODYPART[b]);
                return false;
            }
            return !creep.body.find(bp => bp.boost === b);
        });
        for (let boost of creep.memory.boosts) {
            myRoom.requestBoost(creep, boost);
            let lab = creep.room.find(FIND_MY_STRUCTURES).find(s => {
                if (s.structureType !== STRUCTURE_LAB)
                    return false;
                if (s.mineralType !== boost)
                    return false;
                let bodypartsAmount = creep.getActiveBodyparts(BOOST_TO_BODYPART[boost]);
                if (s.mineralAmount < bodypartsAmount * LAB_BOOST_MINERAL)
                    return false;
                if (s.energy < bodypartsAmount * LAB_BOOST_ENERGY)
                    return false;
                return true;
            });
            if (!lab)
                continue;
            if (creep.pos.isNearTo(lab.pos)) {
                lab.boostCreep(creep);
            }
            else {
                creep.goTo(lab.pos, 1);
                moved = true;
                break;
            }
        }
        if (!moved)
            creep.giveWay();
        if (creep.memory.boosts.length === 0)
            delete creep.memory.boosts;
    }
    // ---------------------------------------------------------------------
    kill() {
        for (let creep of this.creeps) {
            this.dismissCreep(creep, true, false);
        }
    }
    // ---------------------------------------------------------------------
    updateCpuUsage(used) {
        const rollingPeriod = 500;
        const estimatedStats = this.getEstimatedStats();
        const newValue = ((this.memory.cpu || estimatedStats.baseCpu) * (rollingPeriod - 1) + used) / rollingPeriod;
        this.memory.cpu = Math.max(estimatedStats.baseCpu, newValue);
        this.estimatedStats.cpu = this.memory.cpu;
    }
    run() {
        let startCpu = Game.cpu.getUsed();
        this.onRun();
        this.cpuUsedThisTick += Game.cpu.getUsed() - startCpu;
        this.updateCpuUsage(this.cpuUsedThisTick);
        const estimatedStats = this.getEstimatedStats();
        Stats.registerOperationCpu(this.constructor.name, this.cpuUsedThisTick, this.memory.cpu, estimatedStats.baseCpu);
    }
}
__decorate([
    profile()
], BaseOperation.prototype, "initForTick", null);
__decorate([
    profile()
], BaseOperation.prototype, "run", null);

class BaseRoomOperation extends BaseOperation {
    constructor(parentRoom) {
        super(parentRoom.empire);
        this.parentRoom = parentRoom;
    }
    get roomName() {
        return this.parentRoom.roomName;
    }
    get spawnRoomName() {
        return this.parentRoom.roomName;
    }
    get roomLayout() {
        return this.parentRoom.layout;
    }
    get roomPlan() {
        return this.roomLayout.roomPlan;
    }
    resetTargetScale() {
        this.memory.targetScale = this.getMinimumScale();
    }
    setTargetScale(value) {
        this.memory.targetScale = value;
    }
    get targetScale() {
        return this.memory.targetScale;
    }
}

class OperationStorage extends BaseRoomOperation {
    static create() {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0
        };
        return memory;
    }
    constructor(parentRoom) {
        super(parentRoom);
        this._lastRoomEnergy = -1;
        this._lastRoomEnergyCapacity = -1;
        this._storedEnergy = -1;
        this._storedPower = -1;
        this._updateTerminalDistributionRequests = true;
        this._updateTowerDistributionRequests = true;
        this._terminalDistributionRequests = [];
        this._towerDistributionRequests = [];
        this._spawnDistributionRequests = [];
        this._extensionDistributionRequests = [];
        this.creepComposition = {
            body: undefined,
            distributorCount: 0,
            energyCapacityAvailable: 0,
            RCL: 0,
            abandon: false
        };
    }
    get memory() {
        return this.parentRoom.memory.storage;
    }
    onInitForTick() {
        if (!this.storemanPos && this.roomPlan) {
            this.storemanPos = [
                new RoomPosition(this.roomPlan.pos.x - 1, this.roomPlan.pos.y - 1, this.roomPlan.pos.roomName),
                new RoomPosition(this.roomPlan.pos.x + 1, this.roomPlan.pos.y - 1, this.roomPlan.pos.roomName),
                new RoomPosition(this.roomPlan.pos.x + 1, this.roomPlan.pos.y + 1, this.roomPlan.pos.roomName),
                new RoomPosition(this.roomPlan.pos.x - 1, this.roomPlan.pos.y + 1, this.roomPlan.pos.roomName)
            ];
        }
        //
        this._collectionPoint = undefined;
        this.piles = this.room.find(FIND_DROPPED_RESOURCES, { filter: r => r.pos.inRangeTo(this.roomLayout.roomPlan.core[8].storage[0], 2) });
    }
    getMinimumScale() {
        return this.roomLayout.towers.length === 0 ? 0.0 : 1.0;
    }
    getMaximumScale() {
        return this.getMinimumScale();
    }
    updateCreepComposition() {
        if (this.creepComposition.RCL !== this.room.controller.level
            || this.creepComposition.energyCapacityAvailable !== this.room.energyCapacityAvailable
            || this.creepComposition.abandon !== this.parentRoom.abandon) {
            let RCL = this.room.controller.level;
            let maxCreepScale = Math.floor(this.room.energyCapacityAvailable / (2 * BODYPART_COST[CARRY] + BODYPART_COST[MOVE]));
            let creepScale = Math.min(16, maxCreepScale, this.parentRoom.abandon ? Infinity : 8 * EXTENSION_ENERGY_CAPACITY[RCL] / CARRY_CAPACITY / 2);
            this.creepComposition.RCL = RCL;
            this.creepComposition.energyCapacityAvailable = this.room.energyCapacityAvailable;
            this.creepComposition.distributorCount = OperationStorage.distributorCount[RCL];
            this.creepComposition.body = new CreepBody(`${creepScale}[CCM]`);
            this.shouldUpdateEstimatedStats = true;
        }
    }
    updateEstimatedStats() {
        this.estimatedStats.energyPerTick = -this.creepComposition.body.cost * this.creepComposition.distributorCount / CREEP_LIFE_TIME;
        this.estimatedStats.spawnTime = this.creepComposition.body.spawnTime * this.creepComposition.distributorCount;
        this.estimatedStats.baseCpu = 0.4;
    }
    getDesiredBank() {
        const RCL = this.room.controller.level;
        if (this.room.energyCapacityAvailable < SPAWN_ENERGY_CAPACITY * this.roomPlan.core[RCL].spawn.length + EXTENSION_ENERGY_CAPACITY[RCL] * this.roomPlan.core[RCL].extension.length)
            return OperationStorage.targetBank[RCL - 1];
        else
            return OperationStorage.targetBank[RCL];
    }
    getSpawnRequestsInternal() {
        let distributorsNeeded = this.creepComposition.distributorCount;
        if (this.parentRoom.operator.creep && this.parentRoom.operator.creep.powers[PWR_OPERATE_EXTENSION]) {
            if (this.parentRoom.operator.creep.powers[PWR_OPERATE_SPAWN])
                distributorsNeeded = 3;
            else
                distributorsNeeded = 2;
        }
        else if (this.getEnergy() < Math.min(this.getDesiredBank(), 10000)) {
            distributorsNeeded = 2;
        }
        distributorsNeeded -= this.creeps.length;
        if (distributorsNeeded <= 0)
            return [];
        //
        let result = [];
        for (let i = 0; i < distributorsNeeded; ++i) {
            result.push({
                id: generateRandomKey(5),
                nameBase: Config.CreepNames.Distributor,
                priority: Priority(0, 18 /* SpawnPriority.DISTRIBUTION */),
                parts: this.creepComposition.body,
                minEnergy: 150,
                memory: {
                    role: 5 /* CreepRole.Storeman */,
                    distributionTasks: []
                },
                boostOptions: [null],
                noRepurpose: false,
                operation: this
            });
        }
        return result;
    }
    updateTerminalDistributionRequests() {
        this._updateTerminalDistributionRequests = true;
    }
    updateTowerDistributionRequests() {
        this._updateTowerDistributionRequests = true;
    }
    isWorking() {
        return this.creeps.length > 0;
    }
    getCollectionPoint() {
        if (this._collectionPoint)
            return this._collectionPoint;
        if (this.parentRoom.abandon && this.room.terminal)
            this._collectionPoint = this.room.terminal.pos;
        else if (!this.roomLayout.storage || !this.roomLayout.storage.isActive() || this.roomLayout.storage.store.getFreeCapacity() === 0)
            this._collectionPoint = this.roomPlan.core[8].container[0];
        else
            this._collectionPoint = this.roomPlan.core[8].storage[0];
        return this._collectionPoint;
    }
    getDistributionPoint(resourceType) {
        let pile = this.piles.find(p => p.resourceType === resourceType);
        if (pile)
            return pile;
        if (this.roomLayout.coreContainer && this.roomLayout.coreContainer.store[resourceType])
            return this.roomLayout.coreContainer;
        if (this.roomLayout.storage && this.roomLayout.storage.store[resourceType] && this.roomLayout.storage.store.getFreeCapacity() < 50000)
            return this.roomLayout.storage;
        let targetTerminalStock = (Config.TARGET_STOCK[resourceType] && Config.TARGET_STOCK[resourceType].terminal || 0);
        if (!this.parentRoom.abandon && this.roomLayout.terminal && this.roomLayout.terminal.store[resourceType] && (this.roomLayout.terminal.store[resourceType] > targetTerminalStock && targetTerminalStock !== 0))
            return this.roomLayout.terminal;
        if (this.roomLayout.storage && this.roomLayout.storage.store[resourceType])
            return this.roomLayout.storage;
        if (this.roomLayout.terminal && this.roomLayout.terminal.store[resourceType])
            return this.roomLayout.terminal;
        return null;
    }
    getEnergy() {
        return (this.roomLayout.storage && this.roomLayout.storage.store[RESOURCE_ENERGY] || 0)
            + (this.roomLayout.terminal && this.roomLayout.terminal.store[RESOURCE_ENERGY] || 0)
            + (this.roomLayout.coreContainer && this.roomLayout.coreContainer.store[RESOURCE_ENERGY] || 0)
            + _.sum(this.piles, p => p.resourceType === RESOURCE_ENERGY ? p.amount : 0);
    }
    getDistributionRequests() {
        var _a;
        let cpuStart = Game.cpu.getUsed();
        if (Memory.toggles.logDistributionCPU)
            OperationStorage.distributionCPU = OperationStorage.distributionCPU || {};
        else
            OperationStorage.distributionCPU = undefined;
        let distributionRequests = [];
        // terminal <=> storage
        if (this._updateTerminalDistributionRequests) {
            this._terminalDistributionRequests = [];
            this._storedEnergy = (this.roomLayout.terminal ? this.roomLayout.terminal.store.energy : 0) + (this.roomLayout.storage ? this.roomLayout.storage.store.energy : 0);
            this._storedPower = (this.roomLayout.terminal ? this.roomLayout.terminal.store.power : 0) + (this.roomLayout.storage ? this.roomLayout.storage.store.power : 0);
            this._updateTerminalDistributionRequests = false;
            if (this._terminalDistributionRequests.length === 0
                && this.roomLayout.terminal
                && this.roomLayout.terminal.isActive()
                && this.roomLayout.storage
                && this.roomLayout.storage.isActive()) {
                const shuffledResources = _.shuffle(RESOURCES_ALL);
                for (let resourceType of shuffledResources) {
                    let targetStock = Config.TARGET_STOCK[resourceType];
                    let storageStock = (this.roomLayout.storage.store[resourceType] || 0);
                    let terminalStock = (this.roomLayout.terminal.store[resourceType] || 0);
                    let targetTerminalStock = (targetStock && targetStock.terminal !== undefined) ? targetStock.terminal : -1;
                    if (this.parentRoom.abandon)
                        targetTerminalStock = -1; // force all resources to be moved to terminal
                    // fill terminal until it has target stock, move undefined resources to terminal
                    if ((terminalStock < targetTerminalStock || targetTerminalStock === -1) && storageStock > 0) {
                        let amount = Math.min(targetTerminalStock === -1 ? Infinity : targetTerminalStock - terminalStock, storageStock);
                        const distributorCapacity = this.creepComposition.body[CARRY] * CARRY_CAPACITY;
                        const requestCount = Math.min(Math.ceil(amount / distributorCapacity), this.creepComposition.distributorCount);
                        for (let i = 0; i < requestCount; ++i) {
                            let requestAmount = Math.min(distributorCapacity, amount);
                            this._terminalDistributionRequests.push({
                                amount: requestAmount,
                                resource: resourceType,
                                structureId: this.roomLayout.terminal.id,
                                priority: 5 /* DistributionPriority.TERMINAL */
                            });
                            amount -= requestAmount;
                        }
                    }
                    // move from terminal to storage if terminal is above target stock, keep undefined resources in terminal
                    else if (terminalStock > targetTerminalStock && this.roomLayout.storage.store.getFreeCapacity() > 50000 && targetTerminalStock !== -1) {
                        this._terminalDistributionRequests.push({
                            amount: -(terminalStock - targetTerminalStock),
                            resource: resourceType,
                            structureId: this.roomLayout.terminal.id,
                            priority: 5 /* DistributionPriority.TERMINAL */
                        });
                    }
                }
            }
            distributionRequests.push(...this._terminalDistributionRequests);
        }
        if (Memory.toggles.logDistributionCPU) {
            const key = 'terminal';
            OperationStorage.distributionCPU[key] = (OperationStorage.distributionCPU[key] || 0) + Game.cpu.getUsed() - cpuStart;
            cpuStart = Game.cpu.getUsed();
        }
        // towers
        if (this._updateTowerDistributionRequests) {
            this._towerDistributionRequests = [];
            this._updateTowerDistributionRequests = false;
            for (let tower of this.roomLayout.towers)
                if (tower.energy < tower.energyCapacity * 0.75) {
                    this._towerDistributionRequests.push({
                        amount: tower.energyCapacity - tower.energy,
                        resource: RESOURCE_ENERGY,
                        structureId: tower.id,
                        priority: 8 /* DistributionPriority.TOWER */
                    });
                }
        }
        distributionRequests.push(...this._towerDistributionRequests);
        if (Memory.toggles.logDistributionCPU) {
            const key = 'towers';
            OperationStorage.distributionCPU[key] = (OperationStorage.distributionCPU[key] || 0) + Game.cpu.getUsed() - cpuStart;
            cpuStart = Game.cpu.getUsed();
        }
        let updateSpawnsAndExtensions = (this._lastRoomEnergy !== this.room.energyAvailable || this._lastRoomEnergyCapacity !== this._lastRoomEnergyCapacity);
        // spawns
        if (updateSpawnsAndExtensions) {
            this._spawnDistributionRequests = [];
            for (let spawn of this.roomLayout.spawns)
                if (spawn.energy < spawn.energyCapacity) {
                    this._spawnDistributionRequests.push({
                        amount: spawn.energyCapacity - spawn.energy,
                        resource: RESOURCE_ENERGY,
                        structureId: spawn.id,
                        priority: 10 /* DistributionPriority.SPAWN */
                    });
                }
        }
        distributionRequests.push(...this._spawnDistributionRequests);
        if (Memory.toggles.logDistributionCPU) {
            const key = 'spawns';
            OperationStorage.distributionCPU[key] = (OperationStorage.distributionCPU[key] || 0) + Game.cpu.getUsed() - cpuStart;
            cpuStart = Game.cpu.getUsed();
        }
        // extensions
        if (updateSpawnsAndExtensions) {
            let operatorWillHandleIt = this.parentRoom.operator.creep
                && this.parentRoom.operator.creep.pos.roomName === this.roomName
                && this.parentRoom.operator.creep.powers[PWR_OPERATE_EXTENSION]
                && this.parentRoom.operator.creep.powers[PWR_OPERATE_EXTENSION].level > 0
                && _.every(this.roomLayout.spawns, s => s.spawning && this.parentRoom.operator.creep.powers[PWR_OPERATE_EXTENSION].cooldown < s.spawning.remainingTime);
            if (operatorWillHandleIt) {
                this._extensionDistributionRequests = [];
            }
            else {
                this._extensionDistributionRequests = [];
                let checkIsActive = (this.roomLayout.extensions.length > CONTROLLER_STRUCTURES.extension[this.room.controller.level]);
                for (let extension of this.roomLayout.extensions) {
                    if (extension.energy >= extension.energyCapacity)
                        continue;
                    if (checkIsActive && !extension.isActive())
                        continue;
                    this._extensionDistributionRequests.push({
                        structureId: extension.id,
                        amount: extension.energyCapacity - extension.energy,
                        resource: RESOURCE_ENERGY,
                        priority: 9 /* DistributionPriority.EXTENSION */
                    });
                }
            }
        }
        distributionRequests.push(...this._extensionDistributionRequests);
        if (Memory.toggles.logDistributionCPU) {
            const key = 'extensions';
            OperationStorage.distributionCPU[key] = (OperationStorage.distributionCPU[key] || 0) + Game.cpu.getUsed() - cpuStart;
            cpuStart = Game.cpu.getUsed();
        }
        this._lastRoomEnergy = this.room.energyAvailable;
        this._lastRoomEnergyCapacity = this._lastRoomEnergyCapacity;
        // core link
        if (this.roomLayout.coreLink && this.roomLayout.coreLink.energy > 0) {
            distributionRequests.push({
                amount: -this.roomLayout.coreLink.energy,
                resource: RESOURCE_ENERGY,
                structureId: this.roomLayout.coreLink.id,
                priority: 12 /* DistributionPriority.LINK */
            });
        }
        if (Memory.toggles.logDistributionCPU) {
            const key = 'coreLink';
            OperationStorage.distributionCPU[key] = (OperationStorage.distributionCPU[key] || 0) + Game.cpu.getUsed() - cpuStart;
            cpuStart = Game.cpu.getUsed();
        }
        // power spawn
        const powerSpawn = this.roomLayout.powerSpawn;
        if (powerSpawn
            && powerSpawn.power < powerSpawn.powerCapacity / 2
            && this._storedPower > 0) {
            distributionRequests.push({
                amount: powerSpawn.powerCapacity - powerSpawn.power,
                resource: RESOURCE_POWER,
                structureId: this.roomLayout.powerSpawn.id,
                priority: 1 /* DistributionPriority.POWER_SPAWN */
            });
        }
        if (powerSpawn
            && powerSpawn.power > 0
            && powerSpawn.energy < powerSpawn.energyCapacity / 2
            && this._storedEnergy > Config.POWER_PROCESSING_ENERGY_THRESHOLD) {
            distributionRequests.push({
                amount: powerSpawn.energyCapacity - powerSpawn.energy,
                resource: RESOURCE_ENERGY,
                structureId: powerSpawn.id,
                priority: 1 /* DistributionPriority.POWER_SPAWN */
            });
        }
        if (Memory.toggles.logDistributionCPU) {
            const key = 'powerSpawn';
            OperationStorage.distributionCPU[key] = (OperationStorage.distributionCPU[key] || 0) + Game.cpu.getUsed() - cpuStart;
            cpuStart = Game.cpu.getUsed();
        }
        if (this.roomLayout.storage && this.roomLayout.storage.isActive() && this.roomLayout.storage.store.getFreeCapacity() > 0) {
            // containers
            let coreContainer = this.roomLayout.coreContainer;
            let coreContainerResource = coreContainer && _.findKey(coreContainer.store);
            if (coreContainerResource) {
                distributionRequests.push({
                    amount: -coreContainer.store[coreContainerResource],
                    resource: coreContainerResource,
                    structureId: coreContainer.id,
                    priority: 6 /* DistributionPriority.CONTAINERS */
                });
            }
            let labContainer = this.roomLayout.labContainer;
            let labContainerResource = labContainer && _.findKey(labContainer.store);
            if (labContainerResource) {
                distributionRequests.push({
                    amount: -labContainer.store[labContainerResource],
                    resource: labContainerResource,
                    structureId: labContainer.id,
                    priority: 6 /* DistributionPriority.CONTAINERS */
                });
            }
            if (Memory.toggles.logDistributionCPU) {
                const key = 'containers';
                OperationStorage.distributionCPU[key] = (OperationStorage.distributionCPU[key] || 0) + Game.cpu.getUsed() - cpuStart;
                cpuStart = Game.cpu.getUsed();
            }
            // tombstones
            let tombstones = this.room.find(FIND_TOMBSTONES, { filter: t => _.findKey(t.store) && t.pos.inRangeTo(this.roomPlan.pos, 5) });
            for (let t of tombstones) {
                for (let resource in t.store) {
                    distributionRequests.push({
                        amount: -t.store[resource],
                        resource: resource,
                        structureId: t.id,
                        priority: 6 /* DistributionPriority.CONTAINERS */
                    });
                }
            }
            if (Memory.toggles.logDistributionCPU) {
                const key = 'tombstones';
                OperationStorage.distributionCPU[key] = (OperationStorage.distributionCPU[key] || 0) + Game.cpu.getUsed() - cpuStart;
                cpuStart = Game.cpu.getUsed();
            }
            // piles
            if (((_a = this.room.storage) === null || _a === void 0 ? void 0 : _a.store.getFreeCapacity()) > 0) {
                for (let p of this.piles) {
                    distributionRequests.push({
                        amount: p.amount,
                        resource: p.resourceType,
                        structureId: this.roomLayout.storage.id,
                        priority: 6 /* DistributionPriority.CONTAINERS */
                    });
                }
            }
            if (Memory.toggles.logDistributionCPU) {
                const key = 'piles';
                OperationStorage.distributionCPU[key] = (OperationStorage.distributionCPU[key] || 0) + Game.cpu.getUsed() - cpuStart;
                cpuStart = Game.cpu.getUsed();
            }
        }
        // labs
        distributionRequests.push(...this.parentRoom.getLabDistributionRequests());
        if (Memory.toggles.logDistributionCPU) {
            const key = 'labs';
            OperationStorage.distributionCPU[key] = (OperationStorage.distributionCPU[key] || 0) + Game.cpu.getUsed() - cpuStart;
            cpuStart = Game.cpu.getUsed();
        }
        // factory
        distributionRequests.push(...this.parentRoom.getFactoryDistributionRequests());
        if (Memory.toggles.logDistributionCPU) {
            const key = 'factory';
            OperationStorage.distributionCPU[key] = (OperationStorage.distributionCPU[key] || 0) + Game.cpu.getUsed() - cpuStart;
            cpuStart = Game.cpu.getUsed();
        }
        // nuker
        if (this.roomLayout.nuker
            && this.roomLayout.storage
            && this.roomLayout.nuker.pos.lookFor(LOOK_FLAGS).find(f => f.color === COLOR_YELLOW)) {
            if (this.roomLayout.nuker.energy < this.roomLayout.nuker.energyCapacity
                && this.roomLayout.storage.store.energy > Config.NUKER_LOADING_ENERGY_THRESHOLD) {
                distributionRequests.push({
                    structureId: this.roomLayout.nuker.id,
                    amount: this.roomLayout.nuker.energyCapacity - this.roomLayout.nuker.energy,
                    resource: RESOURCE_ENERGY,
                    priority: 1 /* DistributionPriority.NUKER */
                });
            }
            if (this.roomLayout.nuker.ghodium < this.roomLayout.nuker.ghodiumCapacity) {
                distributionRequests.push({
                    structureId: this.roomLayout.nuker.id,
                    amount: this.roomLayout.nuker.ghodiumCapacity - this.roomLayout.nuker.ghodium,
                    resource: RESOURCE_GHODIUM,
                    priority: 1 /* DistributionPriority.NUKER */
                });
            }
            if (this.roomLayout.nuker.ghodium === this.roomLayout.nuker.ghodiumCapacity
                && this.roomLayout.nuker.energy === this.roomLayout.nuker.energyCapacity) {
                this.roomLayout.nuker.pos.lookFor(LOOK_FLAGS).find(f => f.color === COLOR_YELLOW).remove();
            }
        }
        if (Memory.toggles.logDistributionCPU) {
            const key = 'nuker';
            OperationStorage.distributionCPU[key] = (OperationStorage.distributionCPU[key] || 0) + Game.cpu.getUsed() - cpuStart;
            cpuStart = Game.cpu.getUsed();
        }
        return distributionRequests;
    }
    assignDistributionTasks() {
        let creepsLFW = this.creeps.filter(creep => {
            let creepMemory = creep.memory;
            if (creep.spawning)
                return false;
            if (_.findKey(creep.carry))
                return false;
            if (!creepMemory.distributionTasks)
                creepMemory.distributionTasks = [];
            if (creepMemory.distributionTasks.length > 0)
                return false;
            return true;
        });
        if (creepsLFW.length === 0)
            return;
        let distributionRequests = this.getDistributionRequests();
        if (distributionRequests.length === 0)
            return;
        distributionRequests = distributionRequests.filter(dr => {
            let alreadyTaken = this.creeps.some(c => !c.spawning && !!c.memory.distributionTasks.find(dt => dt && dt.structureId === dr.structureId && dr.resource === dt.resource && dr.amount === dt.amount));
            if (alreadyTaken)
                return false;
            let hasResources = dr.amount < 0 || this.getDistributionPoint(dr.resource);
            if (!hasResources)
                return false;
            return true;
        });
        if (distributionRequests.length === 0)
            return;
        let creepsLFWData = creepsLFW.map(c => ({
            pos: c.pos,
            carryCapacity: c.store.getFreeCapacity()
        }));
        let failSafe = 100;
        let highestPriorityRequests;
        let highestPriorityRequestPos;
        let lastHighestPriority = undefined;
        let creepI = 0;
        let didntFindPath = 0;
        while (failSafe && creepsLFW.length > 0 && distributionRequests.length > 0) {
            let currentCreep = creepsLFW[creepI];
            let currentCreepData = creepsLFWData[creepI];
            let highestPriority = _.max(distributionRequests, dr => dr.priority).priority;
            if (highestPriority !== lastHighestPriority) {
                highestPriorityRequests = distributionRequests.filter(dr => dr.priority === highestPriority);
                highestPriorityRequestPos = highestPriorityRequests.map(dr => ({ pos: Game.getObjectById(dr.structureId).pos, range: 1 }));
                lastHighestPriority = highestPriority;
            }
            // let nodes = creepsLFWData.map((c, i) => ({
            //   index: i,
            //   pos: c.pos
            //   }));
            // while (failSafe && nodes.length > 0)
            //   {
            //   let node = nodes.shift();
            //   }
            let searchResult = Pather.findPathToClosest(currentCreepData.pos, highestPriorityRequestPos);
            if (searchResult.incomplete)
                ++didntFindPath;
            else {
                didntFindPath = 0;
                let pathToClosest = searchResult.path;
                let posInRangeToClosest = (pathToClosest.length > 0 ? _.last(pathToClosest) : currentCreepData.pos);
                currentCreepData.pos = posInRangeToClosest;
                highestPriorityRequests = highestPriorityRequests.filter((dr, index) => {
                    if (currentCreepData.carryCapacity <= 0)
                        return true;
                    let structure = Game.getObjectById(dr.structureId);
                    if (!structure.pos.isNearTo(posInRangeToClosest))
                        return true;
                    _.remove(highestPriorityRequestPos, pos => structure.pos.isEqualTo(pos));
                    _.remove(distributionRequests, dr);
                    let currentCreepMemory = currentCreep.memory;
                    currentCreepMemory.distributionTasks.push(dr);
                    currentCreepMemory.requiredResources = currentCreepMemory.requiredResources || {};
                    currentCreepMemory.requiredResources[dr.resource] = (currentCreepMemory.requiredResources[dr.resource] || 0) + Math.max(0, dr.amount);
                    currentCreepData.carryCapacity -= Math.abs(dr.amount);
                    if (currentCreepData.carryCapacity <= 0) {
                        creepsLFW.splice(creepI, 1);
                        creepsLFWData.splice(creepI, 1);
                    }
                    return false;
                });
            }
            if (creepsLFW.length > 0 && didntFindPath >= creepsLFW.length) {
                console.log(this.roomName, 'Pather.findPathToClosest failed', 'creeps:', creepsLFW.map(c => c.name), 'orders:', highestPriorityRequests.map(o => Game.getObjectById(o.structureId).structureType + ' ' + o.amount));
                break;
            }
            creepI = (creepI + 1) % creepsLFW.length;
            --failSafe;
        }
        if (!failSafe)
            console.log(this.roomName, 'failsafe failed', 'creeps:', creepsLFW.map(c => c.name), 'orders:', highestPriorityRequests.map(o => Game.getObjectById(o.structureId).structureType + ' ' + o.amount));
    }
    storemanFunc(creep) {
        let transfered = false;
        let creepMemory = creep.memory;
        let creepCarryCapacity = creep.store.getFreeCapacity();
        if (creepCarryCapacity === 0)
            creepMemory.requiredResources = undefined;
        // packing up
        if (creepMemory.requiredResources) {
            let withdrawResource = _.findKey(creepMemory.requiredResources);
            while (withdrawResource && (creep.carry[withdrawResource] || !this.getDistributionPoint(withdrawResource))) {
                creepMemory.requiredResources[withdrawResource] = undefined;
                withdrawResource = _.findKey(creepMemory.requiredResources);
            }
            if (withdrawResource) {
                let distributionPoint = this.getDistributionPoint(withdrawResource);
                if (creep.pos.isNearTo(distributionPoint.pos)) {
                    if (distributionPoint instanceof Resource)
                        creep.pickup(distributionPoint);
                    else {
                        const amount = Math.min(creepCarryCapacity, creepMemory.requiredResources[withdrawResource], distributionPoint.store[withdrawResource]);
                        creep.withdraw(distributionPoint, withdrawResource, amount);
                        this.updateTerminalDistributionRequests();
                    }
                    creep.giveWay(true);
                }
                else {
                    creep.goTo(distributionPoint.pos, 1);
                }
            }
            else
                creepMemory.requiredResources = undefined;
        }
        // distributing
        if (!creepMemory.requiredResources && creepMemory.distributionTasks.length > 0) {
            let task = creepMemory.distributionTasks[0];
            while (creepMemory.distributionTasks.length > 0 && (!task || !Game.getObjectById(task.structureId) || task.amount > 0 && !creep.carry[task.resource])) {
                creepMemory.distributionTasks.shift();
                task = creepMemory.distributionTasks[0];
            }
            if (task) {
                let target = Game.getObjectById(task.structureId);
                if (creep.pos.isNearTo(target.pos)) {
                    if (task.amount > 0) {
                        creep.transfer(target, task.resource, Math.min(creep.carry[task.resource], task.amount, target.store.getFreeCapacity(task.resource)));
                        transfered = true;
                        switch (target.structureType) {
                            case STRUCTURE_TERMINAL:
                                this.updateTerminalDistributionRequests();
                                break;
                            case STRUCTURE_TOWER:
                                this.updateTowerDistributionRequests();
                                break;
                        }
                    }
                    else {
                        creep.withdraw(target, task.resource, Math.min(creepCarryCapacity, -task.amount));
                        if (target.structureType === STRUCTURE_TERMINAL)
                            this.updateTerminalDistributionRequests();
                    }
                    creepMemory.distributionTasks.shift();
                }
                else {
                    let result = creep.goTo(target.pos, 1);
                    if (result === ERR_NO_PATH)
                        creepMemory.distributionTasks.shift();
                }
            }
        }
        // resting
        if (creepMemory.distributionTasks.length === 0) {
            // store excess resources
            const collectionPoint = this.getCollectionPoint();
            const creepFirstResource = _.findKey(creep.carry);
            const collectionStructure = collectionPoint === null || collectionPoint === void 0 ? void 0 : collectionPoint.lookFor(LOOK_STRUCTURES).find(s => s.hasStore() && s.store.getFreeCapacity(creepFirstResource) > 0);
            if (creepFirstResource && !transfered) {
                if (!creep.pos.isNearTo(collectionPoint))
                    creep.goTo(collectionPoint, 1);
                else if (collectionStructure) {
                    creep.transfer(collectionStructure, creepFirstResource);
                    this.updateTerminalDistributionRequests();
                }
                else if (!creep.pos.isEqualTo(collectionPoint))
                    creep.goTo(collectionPoint, 0);
                else
                    creep.drop(creepFirstResource);
            }
            // go to rest pos
            else if (!this.storemanPos.find(p => p.isEqualTo(creep.pos))) {
                let restPosAvailable = this.storemanPos.filter(p => !p.lookFor(LOOK_CREEPS).find(c => c.my && c.memory.role === 5 /* CreepRole.Storeman */));
                if (restPosAvailable.length > 0) {
                    let restPos = _.min(restPosAvailable, p => creep.pos.getRangeTo(p));
                    creep.goTo(restPos, 0);
                }
                else {
                    creep.say('no space', false);
                    console.log('no space, collection point', collectionPoint.link());
                    creep.giveWay(true);
                }
            }
            else {
                creep.giveWay(true);
            }
        }
    }
    onRun() {
        this.updateCreepComposition();
        this.assignDistributionTasks();
        for (let creep of this.creeps)
            if (!creep.spawning)
                this.storemanFunc(creep);
    }
}
OperationStorage.distributorCount = { 1: 0, 2: 0, 3: 2, 4: 2, 5: 2, 6: 3, 7: 4, 8: 4 };
OperationStorage.targetBank = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 10000, 5: 100000, 6: 200000, 7: 300000, 8: 400000 };
__decorate([
    Profiler.profile()
], OperationStorage.prototype, "onInitForTick", null);
__decorate([
    profile("DistributionLogic" /* ProfilerFunctionType.DistributionLogic */)
], OperationStorage.prototype, "getDistributionRequests", null);
__decorate([
    profile("DistributionLogic" /* ProfilerFunctionType.DistributionLogic */)
], OperationStorage.prototype, "assignDistributionTasks", null);
__decorate([
    profile("DistributionLogic" /* ProfilerFunctionType.DistributionLogic */)
], OperationStorage.prototype, "storemanFunc", null);
__decorate([
    check,
    profile()
], OperationStorage.prototype, "onRun", null);

var ReactionProgress;
(function (ReactionProgress) {
    ReactionProgress[ReactionProgress["Picked"] = 1] = "Picked";
    ReactionProgress[ReactionProgress["Filled"] = 2] = "Filled";
    ReactionProgress[ReactionProgress["Done"] = 3] = "Done";
    ReactionProgress[ReactionProgress["Emptied"] = 4] = "Emptied";
})(ReactionProgress || (ReactionProgress = {}));
var ReactionType;
(function (ReactionType) {
    ReactionType[ReactionType["Normal"] = 0] = "Normal";
    ReactionType[ReactionType["Reverse"] = 1] = "Reverse";
})(ReactionType || (ReactionType = {}));
class LabManager {
    static create() {
        let memory = {
            boostRequests: [],
            unboostRequests: []
        };
        return memory;
    }
    constructor(memory, parentRoom) {
        this.memory = memory;
        this.parentRoom = parentRoom;
        if (!this.memory.unboostRequests)
            this.memory.unboostRequests = [];
    }
    get room() {
        return Game.rooms[this.parentRoom.roomName];
    }
    initForTick() {
        this._sourceLabs = undefined;
        this.memory.boostRequests = this.memory.boostRequests.filter(r => {
            if (!Game.creeps[r.creepName])
                return false;
            if (!Memory.creeps[r.creepName].boosts)
                return false;
            if (!Memory.creeps[r.creepName].boosts.includes(r.boost))
                return false;
            return true;
        });
        if (!this.parentRoom.layout.labContainer)
            this.memory.unboostRequests = [];
        else {
            this.memory.unboostRequests = this.memory.unboostRequests.filter(r => {
                if (!Game.creeps[r.creepName])
                    return false;
                if (!Game.getObjectById(r.labId))
                    return false;
                if (Game.getObjectById(r.labId).cooldown > Game.creeps[r.creepName].ticksToLive)
                    return false;
                if (!Memory.creeps[r.creepName].boosts)
                    return false;
                return true;
            });
        }
        //
        let boostLabs = _(this.memory.boostRequests).filter(br => br.labId !== undefined).map(br => Game.getObjectById(br.labId));
        let components = RECIPES[this.memory.currentReaction];
        if (this.memory.reactionProgress === ReactionProgress.Picked && (this._fillExpire || 0) < Game.time)
            this.memory.reactionProgress = undefined;
        if (this.memory.reactionProgress === ReactionProgress.Picked && this.memory.sourceLabs) {
            let areFilled = true;
            if (this.memory.currentReactionType === ReactionType.Normal) {
                for (let i = 0; i < this.sourceLabs.length; ++i) {
                    let lab = this.sourceLabs[i];
                    if (!lab || lab.mineralType !== components[i] || lab.mineralAmount < LabManager.BATCH_SIZE) {
                        areFilled = false;
                        break;
                    }
                }
            }
            else {
                let targetAmount = Math.floor(LabManager.BATCH_SIZE / (this.parentRoom.layout.labs.length - this.sourceLabs.length));
                for (let lab of this.parentRoom.layout.labs) {
                    if (this.sourceLabs.includes(lab))
                        continue;
                    if (!lab || lab.mineralType !== this.memory.currentReaction || lab.mineralAmount < targetAmount) {
                        areFilled = false;
                        break;
                    }
                }
            }
            if (areFilled)
                this.memory.reactionProgress = ReactionProgress.Filled;
        }
        if (this.memory.reactionProgress === ReactionProgress.Done && this.parentRoom.layout.labs.every(l => l.mineralAmount === 0 || boostLabs.includes(l))) {
            this.memory.reactionProgress = undefined;
            this.memory.sourceLabs = undefined;
        }
    }
    get sourceLabs() {
        if (this._sourceLabs !== undefined)
            return this._sourceLabs;
        if (this.memory.sourceLabs === undefined)
            this._sourceLabs = [];
        else {
            if (this.memory.sourceLabs.some(labId => !Game.getObjectById(labId))) {
                this.memory.reactionProgress = undefined;
                this.memory.sourceLabs = undefined;
            }
            else
                this._sourceLabs = this.memory.sourceLabs.map(labId => Game.getObjectById(labId));
        }
        return this._sourceLabs;
    }
    getDistributionRequests() {
        const result = [];
        // fill boost labs
        for (let boostRequest of this.memory.boostRequests) {
            if (!Game.getObjectById(boostRequest.labId)) {
                let foundLab = this.parentRoom.layout.labs.find(l => !this.sourceLabs.includes(l) && !this.memory.boostRequests.find(bl => bl.labId === l.id && bl.boost !== boostRequest.boost));
                if (foundLab)
                    boostRequest.labId = foundLab.id;
            }
            //
            let lab = Game.getObjectById(boostRequest.labId);
            if (!lab)
                continue;
            if (lab.energy < boostRequest.amount * LAB_BOOST_ENERGY) {
                result.push({
                    amount: boostRequest.amount * LAB_BOOST_ENERGY - lab.energy,
                    priority: 11 /* DistributionPriority.BOOST_LAB */,
                    resource: RESOURCE_ENERGY,
                    structureId: lab.id
                });
            }
            if (lab.mineralAmount === 0 || lab.mineralType === boostRequest.boost && lab.mineralAmount < boostRequest.amount * LAB_BOOST_MINERAL) {
                result.push({
                    amount: boostRequest.amount * LAB_BOOST_MINERAL - lab.mineralAmount,
                    priority: 11 /* DistributionPriority.BOOST_LAB */,
                    resource: boostRequest.boost,
                    structureId: lab.id
                });
            }
            else if (lab.mineralAmount > 0 && lab.mineralType !== boostRequest.boost) {
                result.push({
                    amount: -lab.mineralAmount,
                    priority: 11 /* DistributionPriority.BOOST_LAB */,
                    resource: lab.mineralType,
                    structureId: lab.id
                });
            }
        }
        switch (this.memory.reactionProgress) {
            // fill source labs after compound for batch is picked
            case ReactionProgress.Picked:
                {
                    if (this.memory.currentReactionType === ReactionType.Normal) {
                        let components = RECIPES[this.memory.currentReaction];
                        for (let i = 0; i < this.sourceLabs.length; ++i) {
                            let sourceLab = this.sourceLabs[i];
                            let component = components[i];
                            if (sourceLab.mineralAmount === 0 || sourceLab.mineralType === component && sourceLab.mineralAmount < LabManager.BATCH_SIZE) {
                                result.push({
                                    amount: LabManager.BATCH_SIZE - sourceLab.mineralAmount,
                                    priority: 7 /* DistributionPriority.REACTION_LAB */,
                                    resource: component,
                                    structureId: sourceLab.id
                                });
                            }
                            else if (sourceLab.mineralAmount > 0 && sourceLab.mineralType !== component) {
                                result.push({
                                    amount: -sourceLab.mineralAmount,
                                    priority: 7 /* DistributionPriority.REACTION_LAB */,
                                    resource: sourceLab.mineralType,
                                    structureId: sourceLab.id
                                });
                            }
                        }
                    }
                    else {
                        let targetAmount = Math.floor(LabManager.BATCH_SIZE / (this.parentRoom.layout.labs.length - this.sourceLabs.length));
                        for (let lab of this.parentRoom.layout.labs) {
                            if (this.sourceLabs.includes(lab))
                                continue;
                            if (lab.mineralAmount === 0 || lab.mineralType === this.memory.currentReaction && lab.mineralAmount < targetAmount) {
                                result.push({
                                    amount: targetAmount - lab.mineralAmount,
                                    priority: 7 /* DistributionPriority.REACTION_LAB */,
                                    resource: this.memory.currentReaction,
                                    structureId: lab.id
                                });
                            }
                            else if (lab.mineralAmount > 0 && lab.mineralType !== this.memory.currentReaction) {
                                result.push({
                                    amount: -lab.mineralAmount,
                                    priority: 7 /* DistributionPriority.REACTION_LAB */,
                                    resource: lab.mineralType,
                                    structureId: lab.id
                                });
                            }
                        }
                    }
                    break;
                }
            // remove coumponds that aren't part of reaction and boosting
            case ReactionProgress.Filled:
                {
                    let components = RECIPES[this.memory.currentReaction];
                    for (let lab of this.parentRoom.layout.labs) {
                        if (lab.mineralAmount === 0)
                            continue;
                        if (lab.mineralType === this.memory.currentReaction)
                            continue;
                        if (this.sourceLabs.includes(lab) && (this.memory.currentReactionType !== ReactionType.Reverse || components.includes(lab.mineralType)))
                            continue;
                        if (this.memory.boostRequests.find(br => br.labId === lab.id))
                            continue;
                        result.push({
                            amount: -lab.mineralAmount,
                            priority: 11 /* DistributionPriority.BOOST_LAB */,
                            resource: lab.mineralType,
                            structureId: lab.id
                        });
                    }
                    break;
                }
            // empty labs after batch
            case ReactionProgress.Done:
            default:
                {
                    for (let lab of this.parentRoom.layout.labs) {
                        if (lab.mineralAmount === 0)
                            continue;
                        if (this.memory.boostRequests.find(br => br.labId === lab.id))
                            continue;
                        result.push({
                            amount: -lab.mineralAmount,
                            priority: 7 /* DistributionPriority.REACTION_LAB */,
                            resource: lab.mineralType,
                            structureId: lab.id
                        });
                    }
                    break;
                }
        }
        return result;
    }
    requestBoost(creep, boost) {
        if (this.memory.boostRequests.find(r => r.creepName === creep.name && r.boost === boost))
            return;
        const bodypart = BOOST_TO_BODYPART[boost];
        let bodypartAmount = creep.getActiveBodyparts(bodypart);
        this.memory.boostRequests.push({
            creepName: creep.name,
            boost: boost,
            amount: bodypartAmount
        });
    }
    requestUnboost(creep) {
        if (!this.parentRoom.layout.labContainer)
            return false;
        if (this.memory.unboostRequests.find(r => r.creepName === creep.name))
            return true;
        let unboostLab = _(this.parentRoom.layout.labs)
            .filter(l => l.pos.isNearTo(this.parentRoom.layout.labContainer.pos) && l.cooldown < creep.ticksToLive)
            .min(l => l.cooldown);
        if (typeof unboostLab === 'number')
            return false;
        this.memory.unboostRequests.push({
            creepName: creep.name,
            labId: unboostLab.id
        });
        return true;
    }
    pickReaction() {
        if (this.parentRoom.evacResources && !this.parentRoom.abandon)
            return;
        if (!this.parentRoom.layout.storage)
            return;
        if (!this.parentRoom.layout.terminal)
            return;
        if (this.parentRoom.layout.labs.length < 3)
            return;
        let currentReactionCandidates = [];
        this.memory.currentReaction = undefined;
        for (let compoundList of Config.BOOST_PRIORITY) {
            for (let compound of compoundList) {
                let targetQuantity = Config.TARGET_STOCK[compound] && (Config.TARGET_STOCK[compound].storage + Config.TARGET_STOCK[compound].terminal) || 0;
                let currentQuantity = this.room.storage.store[compound] + this.room.terminal.store[compound];
                if (currentQuantity >= targetQuantity)
                    continue;
                let areComponentsAvailable = true;
                let components = RECIPES[compound];
                for (let component of components) {
                    let storedAmount = GEmpire.getStoredResource(component);
                    if (storedAmount < LabManager.BATCH_SIZE) {
                        areComponentsAvailable = false;
                        break;
                    }
                }
                if (!areComponentsAvailable)
                    continue;
                currentReactionCandidates.push(compound);
            }
            if (currentReactionCandidates.length > 0)
                break;
        }
        if (currentReactionCandidates.length > 0) {
            let weights = currentReactionCandidates.map(resource => 1 / (GEmpire.getStoredResource(resource) || 1));
            let totalWeight = 0;
            for (let i = 0; i < currentReactionCandidates.length; ++i)
                totalWeight += weights[i];
            let sum = 0;
            let rnd = _.random(0, totalWeight, true);
            for (let i = 0; i < currentReactionCandidates.length; ++i) {
                sum += weights[i];
                if (sum >= rnd) {
                    this.memory.currentReaction = currentReactionCandidates[i];
                    break;
                }
            }
            this.memory.currentReaction = _.sample(currentReactionCandidates);
            this.memory.currentReactionType = ReactionType.Normal;
            this.memory.sourceLabs = this.parentRoom.layout.labs
                .filter(l => this.parentRoom.layout.labs.every(otherL => otherL.pos.inRangeTo(l, 2)))
                .slice(0, 2)
                .map(l => l.id);
            this.memory.reactionProgress = ReactionProgress.Picked;
            this._fillExpire = Game.time + LabManager.FILL_TIMEOUT;
        }
    }
    pickReverseReaction() {
        if (this.parentRoom.evacResources)
            return;
        if (!this.parentRoom.layout.storage)
            return;
        if (!this.parentRoom.layout.terminal)
            return;
        if (this.parentRoom.layout.labs.length < 3)
            return;
        this.memory.currentReaction = undefined;
        for (let resourceType of COMPOUNDS_ALL) {
            let storedResource = (this.parentRoom.layout.storage.store[resourceType] || 0) + (this.parentRoom.layout.terminal.store[resourceType] || 0);
            let targetStock = Config.TARGET_STOCK[resourceType] ? Config.TARGET_STOCK[resourceType].storage + Config.TARGET_STOCK[resourceType].terminal : 0;
            if (targetStock === 0 && storedResource >= LabManager.BATCH_SIZE || storedResource > targetStock + 2 * LabManager.BATCH_SIZE) {
                this.memory.currentReaction = resourceType;
                this.memory.currentReactionType = ReactionType.Reverse;
                this.memory.sourceLabs = this.parentRoom.layout.labs
                    .filter(l => this.parentRoom.layout.labs.every(otherL => otherL.pos.inRangeTo(l, 2)))
                    .slice(0, 2)
                    .map(l => l.id);
                this.memory.reactionProgress = ReactionProgress.Picked;
                this._fillExpire = Game.time + LabManager.FILL_TIMEOUT;
                break;
            }
        }
    }
    react() {
        if (this.memory.reactionProgress === ReactionProgress.Filled) {
            let boostLabs = _(this.memory.boostRequests).filter(br => br.labId !== undefined).map(br => Game.getObjectById(br.labId));
            let invalidInputLabs = false;
            for (let lab of this.parentRoom.layout.labs) {
                if (lab.cooldown)
                    continue;
                if (this.sourceLabs.includes(lab))
                    continue;
                if (boostLabs.includes(lab))
                    continue;
                if (this.memory.unboostRequests.find(l => l.labId === lab.id))
                    continue;
                if (lab.mineralType === this.memory.currentReaction || lab.mineralAmount === 0) {
                    let reactionResult;
                    if (this.memory.currentReactionType === ReactionType.Normal)
                        reactionResult = lab.runReaction(this.sourceLabs[0], this.sourceLabs[1]);
                    else
                        reactionResult = lab.reverseReaction(this.sourceLabs[0], this.sourceLabs[1]);
                    if (reactionResult === ERR_INVALID_ARGS) {
                        invalidInputLabs = true;
                        break;
                    }
                }
            }
            let isDone = false;
            if (this.memory.currentReactionType === ReactionType.Normal) {
                for (let sourceLab of this.sourceLabs)
                    if (sourceLab.mineralAmount < LAB_REACTION_AMOUNT)
                        isDone = true;
                for (let lab of this.parentRoom.layout.labs)
                    if (lab.mineralType === this.memory.currentReaction && lab.mineralAmount === lab.mineralCapacity)
                        isDone = true;
            }
            else {
                for (let sourceLab of this.sourceLabs)
                    if (sourceLab.mineralAmount === sourceLab.mineralCapacity)
                        isDone = true;
                let stillCooking = 0;
                for (let lab of this.parentRoom.layout.labs) {
                    if (lab.mineralType === this.memory.currentReaction) {
                        ++stillCooking;
                        if (lab.mineralAmount < LAB_REACTION_AMOUNT) {
                            isDone = true;
                            break;
                        }
                    }
                }
                if (stillCooking === 0)
                    isDone = true;
            }
            if (invalidInputLabs || isDone)
                this.memory.reactionProgress = ReactionProgress.Done;
        }
    }
    getCpuUsage() {
        if (this.memory.reactionProgress === ReactionProgress.Filled)
            return (this.parentRoom.layout.labs.length - 2) * 0.2 / REACTION_TIME[this.memory.currentReaction];
        else
            return 0;
    }
    run() {
        if (!this.memory.reactionProgress && _.random(0, 9) === 0) {
            this.pickReaction();
            if (!this.memory.reactionProgress)
                this.pickReverseReaction();
        }
        this.react();
    }
}
LabManager.BATCH_SIZE = LAB_MINERAL_CAPACITY;
LabManager.FILL_TIMEOUT = 100;
__decorate([
    profile()
], LabManager.prototype, "initForTick", null);
__decorate([
    check,
    profile()
], LabManager.prototype, "run", null);

class Console {
    get common() {
        return common;
    }
    getActiveOutposts() {
        let result = '';
        let myRooms = GEmpire.myRooms;
        for (let myRoom of myRooms) {
            result += myRoom.roomName + ': ';
            result += myRoom.activeOutposts.map(o => o.isActive ? o.roomName : o.roomName + ' (closing)').join(', ');
            result += '<br/>';
        }
        return result;
    }
    abortClosingOutposts() {
        let myRooms = GEmpire.myRooms;
        for (let myRoom of myRooms)
            for (let outpost of myRoom.activeOutposts)
                if (!outpost.isActive)
                    for (let mine of outpost.operationMine)
                        for (let creep of mine.creeps)
                            creep.suicide();
        return 'OK';
    }
    visualizeCM(roomName, costMatrix) {
        let visual = Common.getRoomVisual(roomName);
        if (costMatrix instanceof PathFinder.CostMatrix) {
            for (let y = 0; y < 50; ++y) {
                for (let x = 0; x < 50; ++x) {
                    let value = costMatrix.get(x, y);
                    visual.text(value.toString(), x, y, { font: 0.5, color: '#ffffff', opacity: 0.5 });
                }
            }
        }
        else {
            for (let i = 0; i < 2500; ++i) {
                let x = i % 50;
                let y = Math.floor(i / 50);
                visual.text(costMatrix[i].toString(), x, y, { font: 0.5, color: '#ffffff', opacity: 0.5 });
            }
        }
        return 'OK';
    }
    get flags() {
        let result = Object.values(Game.flags)
            .map(flag => flag.name + ' at ' + flag.pos.link() + '<br/>')
            .sort((a, b) => a.localeCompare(b))
            .join('');
        return result;
    }
    get constructionSites() {
        let result = Object.values(Game.constructionSites)
            .map(cs => cs.structureType + ' at ' + cs.pos.link() + '<br/>')
            .sort((a, b) => a.localeCompare(b))
            .join('');
        return result;
    }
    removeConstructionSites(roomName) {
        if (!roomName)
            return 'No roomName given';
        let room = Game.rooms[roomName];
        if (!room)
            return 'Room ' + roomName + ' is not visible';
        let constructionSites = room.find(FIND_CONSTRUCTION_SITES);
        for (let cs of constructionSites)
            cs.remove();
        return 'OK';
    }
    removeBuildings(roomName) {
        if (!roomName)
            return 'No roomName given';
        let room = Game.rooms[roomName];
        if (!room)
            return 'Room ' + roomName + ' is not visible';
        let structures = room.find(FIND_STRUCTURES, {
            filter: (s) => {
                return s instanceof OwnedStructure && !s.my ||
                    s.structureType !== STRUCTURE_SPAWN &&
                        s.structureType !== STRUCTURE_CONTROLLER;
            }
        });
        structures.forEach((s) => {
            s.destroy();
        });
        return 'OK';
    }
    removeCreeps(roomName) {
        for (let name in Game.creeps)
            if (Game.creeps[name].pos.roomName === roomName)
                Game.creeps[name].suicide();
        return 'OK';
    }
    killAll() {
        for (let name in Game.creeps)
            Game.creeps[name].suicide();
        return 'OK';
    }
    clearWatch() {
        const lines = [
            `<script>`,
            `const memory = angular.element($('.memory-watch')).scope().MemoryMain;`,
            `const prefixes = ['flags.', 'creeps.', 'powerCreeps.', 'spawns.',];`,
            `const toRemove = memory.watches.filter(w => _.some(prefixes, p => w.path.startsWith(p)));`,
            `toRemove.forEach(w => memory.removeWatch(w.path));`,
            `</script>`
        ];
        console.log(lines.join(''));
    }
    clearOutdatedMemory() {
        delete Memory.toggles['upgradeStats'];
        for (let roomName in Memory.myRooms) {
            let myRoomMemory = Memory.myRooms[roomName];
            delete myRoomMemory['Config'];
            delete myRoomMemory['extensionModule'];
            delete myRoomMemory['extractionModules'];
            delete myRoomMemory['fortificationsModule'];
            delete myRoomMemory['mineModules'];
            delete myRoomMemory['upgradeModule'];
            delete myRoomMemory['spawnManager'];
            delete myRoomMemory['outpostBlacklist'];
            for (let mineId in myRoomMemory.mines)
                delete myRoomMemory.mines[mineId]['creepComposition'];
            delete myRoomMemory.storage['labModuleId'];
            delete myRoomMemory.storage['ConfigId'];
            delete myRoomMemory.storage['extensionModuleId'];
            delete myRoomMemory.defend['fortifiactionModuleId'];
            delete myRoomMemory.defend['ConfigId'];
            delete myRoomMemory.upgrade['lastCheck'];
            for (let outpostRoomName in myRoomMemory.outposts) {
                let outpost = myRoomMemory.outposts[outpostRoomName];
                delete outpost['mineModules'];
                delete outpost['extractionModule'];
                delete outpost['extraction'];
                delete outpost['SKExtraction'];
                delete outpost.peacekeeping['clearTask'];
                if (outpost.SKClear) {
                    delete outpost.SKClear['routes'];
                    delete outpost.SKClear['SKMinesHash'];
                }
                for (let mine of outpost.mines)
                    delete mine['creepComposition'];
            }
        }
        for (let roomName in Memory.rooms) {
            delete Memory.rooms[roomName]['deposit'];
        }
    }
    get usedSegments() {
        let usedSegments = [];
        for (let roomName in Memory.myRooms) {
            let myRoomMemory = Memory.myRooms[roomName];
            usedSegments.push(myRoomMemory.layoutSegmentId);
        }
        usedSegments.push(99);
        return usedSegments;
    }
    stringify(v, maxDepth = 3) {
        let alreadyReferencedObjects = [];
        const recStringify = (value, depth) => {
            switch (typeof value) {
                case 'undefined':
                    return 'undefined';
                case 'boolean':
                case 'number':
                    return value.toString();
                case 'string':
                    return '"' + value.toString() + '"';
                case 'object':
                    if (value === null)
                        return "null";
                    else if (value instanceof RoomPosition) {
                        return value.link();
                    }
                    else if (alreadyReferencedObjects.includes(value))
                        return "*";
                    else {
                        alreadyReferencedObjects.push(value);
                        if (value instanceof Array) {
                            if (value.length === 0)
                                return "[]";
                            else if (depth > maxDepth)
                                return "[ ... ]";
                            else {
                                let leftPad = new Array(depth).fill("  ").join("");
                                let itemLeftPad = new Array(depth + 1).fill("  ").join("");
                                return "[<br/>"
                                    + value.map(item => itemLeftPad + recStringify(item, depth + 1)).join(',<br/>') + "<br/>"
                                    + leftPad + "]";
                            }
                        }
                        else {
                            let entries = Object.entries(value);
                            if (entries.length === 0)
                                return "{}";
                            else if (depth > maxDepth)
                                return "{ ... }";
                            else {
                                let leftPad = new Array(depth).fill("  ").join("");
                                let itemLeftPad = new Array(depth + 1).fill("  ").join("");
                                return "{<br/>"
                                    + entries.map(entry => itemLeftPad + entry[0] + ': ' + recStringify(entry[1], depth + 1)).join(',<br/>') + "<br/>"
                                    + leftPad + "}";
                            }
                        }
                    }
                default:
                    return '';
            }
        };
        return recStringify(v, 0);
        /*
        let alreadyReferencedObjects: any[] = [];
        const replacer = (key: string, value: any) => {
          if (typeof value === 'object') {
            if (value instanceof RoomPosition) {
              return value.link();
            }
            else if (alreadyReferencedObjects.includes(value))
              return "*";
            else {
              alreadyReferencedObjects.push(value);
              return value;
            }
          }
          else {
            return value;
          }
        };
        return JSON.stringify(v, replacer, 2);
        */
    }
    memory(maxDepth) {
        if (!maxDepth)
            maxDepth = 1;
        let result = '';
        let indent = '  ';
        let memoryR = (object, name, depth) => {
            for (let i = 0; i < depth; ++i)
                result += indent;
            let stringified = JSON.stringify(object);
            result += name + ': ' + (stringified ? stringified.length : '?') + '<br/>';
            for (let key in object)
                if (depth + 1 <= maxDepth)
                    memoryR(object[key], key, depth + 1);
        };
        memoryR(Memory, 'Memory', 0);
        return result;
    }
    scanMarket() {
        let orders = Game.market.getAllOrders(order => {
            return (order.resourceType in RESOURCES_ALL);
        });
        let logResult = '';
        let buyOrders = orders.filter(order => order.type === ORDER_BUY);
        buyOrders.sort((a, b) => b.price - a.price);
        let sellOrders = orders.filter(order => order.type === ORDER_SELL);
        sellOrders.sort((a, b) => a.price - b.price);
        let logOrder = function (order) {
            const isNPC = Common.isHighway(order.roomName);
            logResult += '<font color="' + RESOURCE_COLORS[order.resourceType] + '" type="highlight">'
                + order.type + ' ' + order.resourceType
                + ' price: ' + order.price
                + ' roomName: ' + order.roomName
                + (isNPC ? '--NPC--' : '')
                + '</font><br/>';
        };
        logResult += 'buy orders -------------------------<br/>';
        buyOrders.forEach(logOrder);
        logResult += 'sell orders ------------------------<br/>';
        sellOrders.forEach(logOrder);
        logResult += '------------------------------------<br/>';
        return logResult;
    }
    lastIncomingTransactions() {
        let incomingTransactionsLog = '';
        for (let transaction of Game.market.incomingTransactions) {
            incomingTransactionsLog += '<font color="' + RESOURCE_COLORS[transaction.resourceType] + '" type="highlight">'
                + transaction.amount + '*' + transaction.resourceType + ', '
                + transaction.from + ' (' + (transaction.sender ? transaction.sender.username : '?') + ') -> ' + transaction.to
                + '</font><br/>';
        }
        console.log(incomingTransactionsLog);
    }
    lastOutgoingTransactions() {
        let outgoingTransactionsLog = '';
        for (let transaction of Game.market.outgoingTransactions) {
            outgoingTransactionsLog += '<font color="' + RESOURCE_COLORS[transaction.resourceType] + '" type="highlight">'
                + transaction.amount + '*' + transaction.resourceType + ', '
                + transaction.from + ' -> ' + transaction.to + ' (' + (transaction.recipient ? transaction.recipient.username : '?') + ')'
                + '</font><br/>';
        }
        console.log(outgoingTransactionsLog);
    }
    get reactions() {
        let myRooms = GEmpire.myRooms;
        let result = '';
        for (let myRoom of myRooms) {
            let reactionType = myRoom.labManager.memory.currentReactionType;
            let reaction = myRoom.labManager.memory.currentReaction;
            let reactionStatus = myRoom.labManager.memory.reactionProgress;
            let reactionStatusStr = "";
            switch (reactionStatus) {
                case ReactionProgress.Picked:
                    reactionStatusStr = "Picked";
                    break;
                case ReactionProgress.Filled:
                    reactionStatusStr = "Running";
                    break;
                case ReactionProgress.Done:
                    reactionStatusStr = "Done";
                    break;
                case ReactionProgress.Emptied:
                    reactionStatusStr = "Emptied";
                    break;
                default:
                    reactionStatusStr = "Abandoned";
                    break;
            }
            if (!reaction) {
                result += myRoom.roomName + ': none<br/>';
            }
            else {
                result += '<font color="' + RESOURCE_COLORS[reaction] + '" type="highlight">'
                    + myRoom.roomName + ': ' + (reactionType === ReactionType.Reverse ? 'reverse ' : '') + reaction + ' (' + reactionStatusStr + ')'
                    + '</font><br/>';
            }
        }
        return result;
    }
    resetLabReaction(myRoomName) {
        if (!Memory.myRooms[myRoomName])
            return myRoomName + "is not my room";
        Memory.myRooms[myRoomName].labManager.reactionProgress = undefined;
        return "OK";
    }
    creepOwner(creepName) {
        let result = [];
        let recursiveFind = function (o, path) {
            if (!_.isObject(o) && !_.isArray(o))
                return;
            for (let p in o) {
                if (!o[p])
                    continue;
                if (p === 'creeps' && o[p].includes(creepName))
                    result.push(path);
                else if (p !== 'creeps')
                    recursiveFind(o[p], path + '.' + p);
            }
        };
        for (let roomName in Memory.myRooms)
            recursiveFind(Memory.myRooms[roomName], roomName);
        for (let flagName in Memory.flags)
            recursiveFind(Memory.flags[flagName], flagName);
        for (let key in Memory.operations)
            recursiveFind(Memory.operations[key], key);
        return result;
    }
    send(resource, targetRoom) {
        let result;
        let sourceRoom = _.find(Game.rooms, r => r.name !== targetRoom && r.terminal && r.terminal.my && r.terminal.store.getUsedCapacity(resource) > 0);
        if (!sourceRoom) {
            result = ERR_NOT_FOUND;
        }
        else {
            let amount = resource === RES_ENERGY
                ? Math.floor(sourceRoom.terminal.store.getUsedCapacity(resource) * 1000 / (1000 + Game.market.calcTransactionCost(1000, sourceRoom.name, targetRoom)))
                : sourceRoom.terminal.store.getUsedCapacity(resource);
            result = sourceRoom.terminal.send(resource, amount, targetRoom);
        }
        return ERROR_STR[result];
    }
    get orphans() {
        let orphans = [];
        for (let creepName in Game.creeps)
            if (this.creepOwner(creepName).length === 0)
                orphans.push(creepName);
        return orphans;
    }
    killOrphans() {
        for (let creepName in Game.creeps)
            if (this.creepOwner(creepName).length === 0) {
                console.log('suiciding', creepName);
                Game.creeps[creepName].suicide();
            }
    }
    dismissOrphans() {
        for (let creepName in Game.creeps)
            if (this.creepOwner(creepName).length === 0) {
                Game.creeps[creepName].memory = {
                    recycle: true,
                    repurpose: true
                };
            }
    }
    killDoubleOwnedCreeps() {
        for (let creepName in Game.creeps)
            if (this.creepOwner(creepName).length > 1) {
                const creep = Game.creeps[creepName];
                if (creep.spawning) {
                    console.log('canceling ', creepName);
                    const spawn = creep.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_SPAWN);
                    spawn.spawning.cancel();
                }
                else {
                    console.log('suiciding', creepName);
                    creep.suicide();
                }
            }
    }
    get nukes() {
        let result = '';
        for (let roomName in Game.rooms)
            if (Game.rooms[roomName].myRoom) {
                for (let nuke of Game.rooms[roomName].find(FIND_NUKES))
                    result += nuke.pos.link() + '<br/>';
            }
        return result;
    }
    launchNuke(x, y, roomName) {
        let pos = new RoomPosition(x, y, roomName);
        let launchRoom = _.find(Game.rooms, room => {
            if (!room.myRoom)
                return false;
            if (room.controller.level < 8)
                return false;
            if (Game.map.getRoomLinearDistance(room.name, pos.roomName) > NUKE_RANGE)
                return false;
            let nuker = room.myRoom.layout.nuker;
            if (!nuker || nuker.cooldown || nuker.energy < nuker.energyCapacity || nuker.ghodium < nuker.ghodiumCapacity)
                return false;
            return true;
        });
        if (!launchRoom)
            return 'No nukers available';
        let result = launchRoom.myRoom.layout.nuker.launchNuke(pos);
        return ERROR_STR[result];
    }
    loadNukers(roomName) {
        let launchRooms = _.filter(Game.rooms, room => {
            if (!room.myRoom)
                return false;
            if (room.controller.level < 8)
                return false;
            if (Game.map.getRoomLinearDistance(room.name, roomName) > NUKE_RANGE)
                return false;
            let nuker = room.myRoom.layout.nuker;
            if (!nuker)
                return false;
            return true;
        });
        if (launchRooms.length === 0)
            return 'No nukers available';
        let result = '';
        for (let room of launchRooms) {
            let nuker = room.myRoom.layout.nuker;
            if (nuker.energy === nuker.energyCapacity && nuker.ghodium === nuker.ghodiumCapacity)
                result += room.name + ' ready</br>';
            else if (nuker.pos.lookFor(LOOK_FLAGS).find(f => f.color === COLOR_YELLOW))
                result += room.name + ' loading</br>';
            else {
                room.createFlag(nuker.pos, undefined, COLOR_YELLOW, COLOR_YELLOW);
                result += room.name + ' started loading</br>';
            }
        }
        return result;
    }
    creepPos(creepName) {
        return Game.creeps[creepName] && Game.creeps[creepName].pos.link();
    }
    creepGoToMemory(creepName) {
        let goToMemory = Pather.goToMemory[creepName];
        if (!goToMemory)
            return undefined;
        let result = '';
        for (let p in goToMemory) {
            if (p === 'path')
                result += 'path: [<br/>  ' + goToMemory.path.map(pos => pos.serialize()).join(',<br/>  ') + '<br/>],<br/>';
            else
                result += p + ': ' + goToMemory[p] + ',<br/>';
        }
        return result;
    }
    spawnPC(name, roomName) {
        let room = Game.rooms[roomName];
        if (!room || !room.myRoom)
            return roomName + " is not my room";
        let myRoom = room.myRoom;
        if (!myRoom.layout.powerSpawn)
            return "No power spawn in " + roomName;
        if (!Game.powerCreeps[name])
            return "There is no power creep named " + name;
        let PC = Game.powerCreeps[name];
        PC.spawn(myRoom.layout.powerSpawn);
        room.myRoom.assignOperator(PC);
        return "OK";
    }
    logout() {
        var logoutStr = "<script>"
            + "var $timeout = angular.element(document.body).injector().get('$timeout');"
            + "var logout = function() {"
            + "  localStorage.auth = null;"
            + "  location.reload();"
            + "  };"
            + "$timeout(logout, 0)"
            + "</script>";
        console.log(logoutStr);
    }
    resetDistributionCPU() {
        OperationStorage.distributionCPU = undefined;
    }
    get distributionCPU() {
        let sum = _.sum(OperationStorage.distributionCPU);
        return this.stringify(_.mapValues(OperationStorage.distributionCPU, v => (v / sum * 100).toFixed(4) + '%'));
    }
    get pathCache() {
        let result = '';
        for (let key in Pather.pathCache)
            result += Pather.pathCache[key].path[0].serialize() + '->' + _.last(Pather.pathCache[key].path).serialize()
                + ': length=' + Pather.pathCache[key].path.length
                + ', path=' + Pather.pathCache[key].path.map(p => p.serialize()).join(', ') + '<br/>';
        return result;
    }
    get obstacles() {
        return this.stringify(Pather.obstacles.map(o => o.serialize()));
    }
    get profiled() {
        return Object.keys(Profiler.wrappedFunctions).join('<br/>');
    }
    get stock() {
        let stock = {};
        let myRooms = GEmpire.myRooms;
        for (let myRoom of myRooms) {
            if (myRoom.room.terminal) {
                for (let resourceType in myRoom.room.terminal.store) {
                    stock[resourceType] = stock[resourceType] || 0;
                    stock[resourceType] += myRoom.room.terminal.store[resourceType];
                }
            }
            if (myRoom.room.storage) {
                for (let resourceType in myRoom.room.storage.store) {
                    stock[resourceType] = stock[resourceType] || 0;
                    stock[resourceType] += myRoom.room.storage.store[resourceType];
                }
            }
        }
        let result = '';
        for (let resourceType in stock) {
            result += '<font color="' + RESOURCE_COLORS[resourceType] + '" type="highlight">'
                + resourceType + ': ' + stock[resourceType]
                + '</font><br/>';
        }
        return result;
    }
    forceReinitialization() {
        Memory.respawnTick = Game.time + 1;
    }
    help() {
        let prototype = Object.getPrototypeOf(global.cc);
        let properties = Object.getOwnPropertyNames(prototype);
        return properties.map(property => {
            if (typeof prototype[property] === 'function') {
                let func = prototype[property].toString();
                let args = func.match(/.*?\(([^)]*)\)\s.*?{/)[1];
                return property + '(' + args.split(',').map(arg => arg.replace(/\/\*.*\*\//, '').trim()).filter(arg => arg).join(', ') + ')';
            }
            else {
                return property;
            }
        }).sort().join('<br/>');
    }
}
global.cc = new Console;

function toggles() {
    let result = '<table>';
    for (let key in Memory.toggles) {
        const toggleCommand = 'angular.element(document.body).injector().get(\'Console\').sendCommand(\'Memory.toggles.' + key + '=\' + this.checked, 0)';
        result += '<tr><td style="padding-right: 15px">'
            + key
            + '</td><td><input type="checkbox" onclick="' + toggleCommand + '", this.checked)"' + (Memory.toggles[key] ? ' checked/>' : '/>')
            + '</td></tr>';
    }
    result += '</table>';
    return result;
}
function initToggles() {
    Memory.toggles = Memory.toggles || Config.defaultToggles;
    for (let key in Config.defaultToggles) {
        if (!(key in Memory.toggles)) {
            console.log('setting default Memory.toggles.' + key + '=' + Config.defaultToggles[key]);
            Memory.toggles[key] = Config.defaultToggles[key];
        }
    }
    for (let key in Memory.toggles) {
        if (!(key in Config.defaultToggles)) {
            console.log('deleting ' + key + ' from Memory.toggles');
            delete Memory.toggles[key];
        }
    }
    global.toggles = toggles;
}
initToggles();

class CreepBodyCache {
    constructor() {
        this.values = {};
        this.clearQueueHead = null;
        this.clearQueueTail = null;
    }
    get(creepId) {
        return this.values[creepId];
    }
    add(creep) {
        if (this.values[creep.id])
            return;
        let creepBody = new CreepBody(creep);
        this.values[creep.id] = creepBody;
        let newTail = {
            expires: Game.time + 1500,
            creepId: creep.id,
            next: null
        };
        if (this.clearQueueTail) {
            this.clearQueueTail.next = newTail;
            this.clearQueueTail = newTail;
        }
        else {
            this.clearQueueTail = newTail;
            this.clearQueueHead = newTail;
        }
    }
    run() {
        while (this.clearQueueHead && this.clearQueueHead.expires < Game.time) {
            delete this.values[this.clearQueueHead.creepId];
            this.clearQueueHead = this.clearQueueHead.next;
        }
        if (!this.clearQueueHead)
            this.clearQueueTail = null;
    }
}
__decorate([
    profile()
], CreepBodyCache.prototype, "run", null);
global.GCreepBodyCache = new CreepBodyCache();

class Treaties {
    static add(treaty) {
        this.treaties.push(treaty);
    }
    static canBeClaimed(roomName) {
        return this.treaties.every(treaty => treaty.canBeClaimed(roomName));
    }
    static canBeAttacked(roomName) {
        return this.treaties.every(treaty => treaty.canBeAttacked(roomName));
    }
    static preTick() {
        if (this.isIinitialized)
            return;
        Memory.treaties = Memory.treaties || {};
        for (let treaty of this.treaties) {
            treaty.initIfNeeded();
            treaty.update();
        }
    }
}
Treaties.isIinitialized = false;
Treaties.treaties = [];
global.Treaties = Treaties;

function memoryCacheWrapLoop(fn) {
  let lastMemory;
  let tick;

  return () => {
    if (tick && lastMemory && Game.time === tick + 1)
      {
      delete global.Memory;
      global.Memory = lastMemory;
      Memory = lastMemory;
      RawMemory._parsed = lastMemory;
      }
    else
      {
      console.log('parsing memory');
      Memory.rooms; // forces parsing
      lastMemory = RawMemory._parsed;
      }
    tick = Game.time;

    fn();
  };
}

/**
 * global.hasRespawned()
 * 
 * @author:  SemperRabbit
 * @version: 1.0
 * @date:    180331
 * @returns {boolean}: whether this is the first tick after a respawn or not
 * 
 * The checks are set as early returns in case of failure, and are ordered
 * from the least CPU intensive checks to the most. The checks are as follows:
 * 
 *      If it has returned true previously during this tick, return true again
 *      Check Game.time === 0 (returns true for sim room "respawns")
 *      There are no creeps
 *      There is only 1 room in Game.rooms
 *      The 1 room has a controller
 *      The controller is RCL 1 with no progress
 *      The controller is in safemode with the initial value
 *      There is only 1 StructureSpawn
 *
 * The only time that all of these cases are true, is the first tick of a respawn.
 * If all of these are true, you have respawned.
 */

var hasRespawned = function() {
  // check for multiple calls on same tick    
  if(Memory.respawnTick && Memory.respawnTick === Game.time)
    return true;

  // server reset or sim
  if(Game.time === 0) {
    Memory.respawnTick = Game.time;
    return true;
    }

  // check for 0 creeps
  if(Object.keys(Game.creeps).length > 0)
    return false;

  // check for only 1 room
  var rNames = Object.keys(Game.rooms);
  if(rNames.length !== 1)
    return false;

  // check for controller, progress and safe mode
  var room = Game.rooms[rNames[0]];
  if (!room.controller ||
      !room.controller.my ||
      room.controller.level !== 1 ||
      room.controller.progress ||
      !room.controller.safeMode)
    return false;

  // check for 0 or 1 spawn
  if(Object.keys(Game.spawns).length > 1)
    return false;

  if (Memory.respawnTick && Game.time - Memory.respawnTick < 100)
    return false;

  // if all cases point to a respawn, you've respawned
  Memory.respawnTick = Game.time;
  console.log('Memory.respawnTick', Memory.respawnTick);
  return true;
  };

global.injectScreepsBrowserCore = function () {
    if (!global.ScreepsBrowserCoreInjected) {
        global.ScreepsBrowserCoreInjected = true;
        var output = `<SPAN>Trying to inject ScreepsBrowserCore code!</SPAN>
<SCRIPT>
if(!window.injectScriptTagFromText) {
  window.injectScriptTagFromText = function injectScriptTagFromText(name, code){
    if(document.getElementById(name)) return;
    let src=document.createElement('script');
    src.lang='javascript';
    src.innerHTML=code;
    src.id=name;
    document.head.appendChild(src);
    console.log(code);
  };
};

let screepsBrowserCore = \`
window.DomHelper = window.DomHelper || {};
(function(DomHelper){
    DomHelper.addStyle = function (css) {
        let head = document.head;
        if (!head) return;

        let style = document.createElement('style');
        style.type = 'text/css';
        style.innerHTML = css;

        head.appendChild(style);
    };

    DomHelper.generateCompiledElement = function(parent, content) {
        let $scope = parent.scope();
        let $compile = parent.injector().get("$compile");
        return $compile(content)($scope);
    };
})(DomHelper);

window.ScreepsAdapter = window.ScreepsAdapter || {};
(function(ScreepsAdapter) {
    ScreepsAdapter.onViewChange = function (callback) {
        let rootScope = angular.element(document.body).scope();
        if (!rootScope.viewChangeCallbacks) {
            let tutorial = angular.element(document.body).injector().get("Tutorial");
            console.log("Overriding Tutorial.trigger");
            
            tutorial._trigger = tutorial.trigger;
            tutorial.trigger = function(triggerName, unknownB) {
                for (let i in rootScope.viewChangeCallbacks) {
                    rootScope.viewChangeCallbacks[i](triggerName);
                }
                tutorial._trigger(triggerName, unknownB);
            };

            rootScope.viewChangeCallbacks = [];
        }

        rootScope.viewChangeCallbacks.push(callback);
    };

    ScreepsAdapter.onHashChange = function (callback) {
        let rootScope = angular.element(document.body).scope();
        if (!rootScope.hashChangeCallbacks) {
            rootScope.$watch(() => window.location.hash, function(newVal, oldVal) {
                for (let i in rootScope.hashChangeCallbacks) {
                    rootScope.hashChangeCallbacks[i](window.location.hash);
                }
            });

            rootScope.hashChangeCallbacks = [];
        }

        rootScope.hashChangeCallbacks.push(callback);
    };
    
    ScreepsAdapter.onRoomChange = function (callback) {
        let $routeParams = angular.element(document.body).injector().get("$routeParams");
        let rootScope = angular.element(document.body).scope();
        if (!rootScope.roomChangeCallbacks) {
            ScreepsAdapter.onHashChange((hash) => {
                let room = $routeParams.room;
                if (room !== rootScope.lastRoom) {
                    for (let i in rootScope.roomChangeCallbacks) {
                        rootScope.roomChangeCallbacks[i](room);
                    }
                    rootScope.lastRoom = room;
                }
            });

            rootScope.roomChangeCallbacks = [];
        }

        rootScope.roomChangeCallbacks.push(callback);
    };

    ScreepsAdapter.onMapChange = function (callback) {
        let $routeParams = angular.element(document.body).injector().get("$routeParams");
        let rootScope = angular.element(document.body).scope();
        if (!rootScope.mapChangeCallbacks) {
            ScreepsAdapter.onHashChange((hash) => {
                let pos = $routeParams.pos;
                let scale = $routeParams.scale;
                if (!scale) {
                  let scaleByRoomSize = {
                  };
                }
                if (rootScope.lastPos !== pos || rootScope.lastScale !== scale) {
                    for (let i in rootScope.mapChangeCallbacks) {
                        rootScope.mapChangeCallbacks[i](pos, scale);
                    }
                    rootScope.lastPos = pos;
                    rootScope.lastScale = scale;
                }
            });

            rootScope.mapChangeCallbacks = [];
        }

        rootScope.mapChangeCallbacks.push(callback);
    };

    Object.defineProperty(ScreepsAdapter, "User", {
        get: function() {
            delete this.User;
            Object.defineProperty(this, "User", {
                value: angular.element(document.body).scope().Me()
            });
            return this.User;
        },
        configurable: true
    });
    
    Object.defineProperty(ScreepsAdapter, "$timeout", {
        get: function() {
            delete this.$timeout;
            Object.defineProperty(this, "$timeout", {
                value: angular.element(document.body).injector().get('$timeout')
            });
            return this.$timeout;
        },
        configurable: true
    });
    
    Object.defineProperty(ScreepsAdapter, "Connection", {
        get: function() {
            delete this.Connection;
            Object.defineProperty(this, "Connection", {
                value: angular.element(document.body).injector().get('Connection')
            });
            return this.Connection;
        },
        configurable: true
    });
    
    Object.defineProperty(ScreepsAdapter, "Socket", {
        get: function() {
            delete this.Socket;
            Object.defineProperty(this, "Socket", {
                value: angular.element(document.body).injector().get('Socket')
            });
            return this.Socket;
        },
        configurable: true
    });
    
    Object.defineProperty(ScreepsAdapter, "Api", {
        get: function() {
            delete this.Api;
            Object.defineProperty(this, "Api", {
                value: angular.element(document.body).injector().get('Api')
            });
            return this.Api;
        },
        configurable: true
    });

})(ScreepsAdapter);
\`;

if (!document.getElementById("ScreepsAdapter") || !window.ScreepsAdapter) {
  window.injectScriptTagFromText('ScreepsAdapter', screepsBrowserCore);
}
</SCRIPT>`;
        console.log(output.replace(/(\r\n|\n|\r)\t+|(\r\n|\n|\r) +|(\r\n|\n|\r)/gm, ''));
    }
};
global.forceInjectScreepsBrowserCore = () => {
    global.ScreepsBrowserCoreInjected = false;
    global.injectScreepsBrowserCore();
};
global.injectScreepsBrowserCore();

// special thanks to ags131, Robalian, and QGazQ for the assists
// Author: SemperRabbit
// 20190705
function injectBirthday() {
    if (!global.BirthdayInjected) {
        global.BirthdayInjected = true;
        var output = `<SPAN>Trying to inject Birthday code!</SPAN>
<SCRIPT>
if(!window.showBirthDate) window.showBirthDate = function(event){
  var formatDate = function formatDate(d){
    return ("0" + d.getUTCHours()).slice(-2)+":"+("0" + d.getUTCMinutes()).slice(-2)+":"+("0" + d.getUTCSeconds()).slice(-2) + " " +
    ("0" + (d.getUTCMonth()+1)).slice(-2)+"/"+("0" + d.getUTCDate()).slice(-2)+"/"+d.getUTCFullYear() + " UTC";
  };
  var showBdayInternal = function(){
    let gameEl = angular.element($('section.game'));
    let roomEl = angular.element($('section.room'));
    let $rootScope = gameEl.injector().get('$rootScope');
    let $compile = gameEl.injector().get('$compile');
    let target = $('.object-properties .aside-block-content')[0];
    let elem = $('<div class="ng-binding ng-scope"><label>BirthDate: </label>' + formatDate(new Date(parseInt(roomEl.scope().Room.selectedObject._id.substr(0,8), 16)*1000)) + '</div>');
    $compile(elem)($rootScope);
    if(target.children.length > 1) {
      elem.insertBefore(target.children[2]);
    } else {
      elem.insertBefore(target.children[0].children[2]);
    };
  };

  setTimeout(()=>{
    if(event == 'view' && $('.object-properties .aside-block-content')[0]) {
      showBdayInternal();
    }
  }, 100);
};

if(window.ScreepsAdapter){
  if(!angular.element(document.body).scope().viewChangeCallbacks || !_.find(angular.element(document.body).scope().viewChangeCallbacks, o => o==window.showBirthDate))
    ScreepsAdapter.onViewChange(window.showBirthDate);
}

</SCRIPT>`;
        console.log(output.replace(/(\r\n|\n|\r)\t+|(\r\n|\n|\r) +|(\r\n|\n|\r)/gm, ''));
    }
}
global.injectBirthday = injectBirthday;
global.forceInjectBirthday = () => { global.BirthdayInjected = false; injectBirthday(); };
injectBirthday();

global.injectRoomTracker = function () {
    if (!global.RoomTrackerInjected) {
        global.RoomTrackerInjected = true;
        var output = `<SPAN>Trying to inject RoomTracker code!</SPAN>
<SCRIPT>
if(!window.injectScriptTag) {
  window.injectScriptTag =  function injectScriptTag(name, url){
    if(document.getElementById(name)) return;
    return new Promise(function(good, bad){
      const xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.onload = function () {
        if (xhr.status >= 200 && xhr.status < 300) {
          let src=document.createElement('script');
          src.lang='javascript';
          src.innerHTML=xhr.responseText;
          src.id=name;
          document.head.appendChild(src);
          console.log('resp',xhr.responseText);
          good({status: this.status, responseText: xhr.responseText});
        } else {
          bad({ status: this.status, statusText: xhr.statusText });
        }
      };
      xhr.onerror = function () {
        bad({ status: this.status, statusText: xhr.statusText });
      };
      xhr.send();
    });
  };
};

window.monitorRunning = false;
if(!window.trackVisibleRooms) window.trackVisibleRooms = function(roomName){
  console.log("Visible room changed to:", roomName);
  
  function notifyCurrentRoomVisibility() {
      let roomElem = angular.element('.room');
      let roomScope = roomElem.scope();
      let tick = roomScope.Room.gameTime;
      if (tick !== undefined && roomScope.historyTimestamp === undefined) {
          ScreepsAdapter.Connection.setMemoryByPath(
              null,
              "visibleRooms." + roomScope.Room.roomName,
              roomScope.Room.gameTime
          );
      }
  }

  function ensureRoomMonitor() {
      let roomElem = angular.element('.room');
      if (!roomElem || roomElem.length === 0) {
          setTimeout(ensureRoomMonitor, 250);
          return;
      }

      notifyCurrentRoomVisibility();

      if (window.monitorRunning)
          return;

      let roomScope = roomElem.scope();
      roomScope.$watch(() => roomScope.Room.gameTime, notifyCurrentRoomVisibility);
      window.monitorRunning = true;
  }

  if (roomName && roomName !== "sim") {
      ensureRoomMonitor();
  } else {
      window.monitorRunning = false;
  }
};

if(window.ScreepsAdapter){
  if(!angular.element(document.body).scope().roomChangeCallbacks || !_.find(angular.element(document.body).scope().roomChangeCallbacks, o => o==window.trackVisibleRooms))
    ScreepsAdapter.onRoomChange(window.trackVisibleRooms);
}

</SCRIPT>`;
        console.log(output.replace(/(\r\n|\n|\r)\t+|(\r\n|\n|\r) +|(\r\n|\n|\r)/gm, ''));
    }
};
global.forceInjectRoomTracker = () => {
    global.RoomTrackerInjected = false;
    global.injectRoomTracker();
};
global.injectRoomTracker();
function updateRoomVisibility() {
    if (!Memory.visibleRooms)
        Memory.visibleRooms = {};
    for (let roomName in Memory.visibleRooms)
        if (Memory.visibleRooms[roomName] < Game.time - 5)
            delete Memory.visibleRooms[roomName];
}

global.injectMapTracker = function () {
    if (!global.MapTrackerInjected) {
        global.MapTrackerInjected = true;
        var output = `<SPAN>Trying to inject MapTracker code!</SPAN>
<SCRIPT>
if(!window.trackMap) window.trackMap = function(pos, scale) {
  let [posX, posY] = pos.split(',').map(coord => +coord);
  /*console.log('x =',posX,'y =',posY);
  console.log('roomGridSize', window.roomGridSize);
  console.log('viewportTopLeft', window.viewportTop, window.viewportLeft);
  console.log('viewportBottomRight', window.viewportRight, window.viewportBottom);
  console.log('viewportRoomsXY', window.viewportRoomsX, window.viewportRoomsY);*/
};

if(window.ScreepsAdapter){
  let mapChangeCallbacks = angular.element(document.body).scope().mapChangeCallbacks;
  if(!mapChangeCallbacks || !_.find(mapChangeCallbacks, o => o === window.trackMap))
    ScreepsAdapter.onMapChange(window.trackMap);
}

</SCRIPT>`;
        console.log(output.replace(/(\r\n|\n|\r)\t+|(\r\n|\n|\r) +|(\r\n|\n|\r)/gm, ''));
    }
};
global.forceInjectMapTracker = () => {
    global.MapTrackerInjected = false;
    global.injectMapTracker();
};
global.injectMapTracker();

ConstructionSite.prototype.isObstacle = function () {
    return OBSTACLE_STRUCTURE_TYPES.has(this.structureType);
};

let randomDirCandidates = new Uint8Array(9);
let keepRangeDirCandidates = new Uint8Array(9);
function getNudgeDirection_Random(pos) {
    const room = Game.rooms[pos.roomName];
    const terrain = Game.map.getRoomTerrain(pos.roomName);
    let totalWeight = 0;
    for (let dir = TOP; dir <= TOP_LEFT; ++dir) {
        randomDirCandidates[dir] = 0;
        let posX = pos.x + Common.offsetX[dir];
        let posY = pos.y + Common.offsetY[dir];
        if (posX < 1 || posX > 48 || posY < 1 || posY > 48)
            continue;
        if ((terrain.get(posX, posY) & TERRAIN_MASK_WALL) > 0 && !room.lookForAt(LOOK_STRUCTURES, posX, posY).find(s => s.structureType === STRUCTURE_ROAD))
            continue;
        if (room.lookForAt(LOOK_STRUCTURES, posX, posY).find(s => s.isObstacle()))
            continue;
        const hasCreeps = room.lookForAt(LOOK_CREEPS, posX, posY).length > 0;
        const addWeight = hasCreeps ? 1 : 2;
        randomDirCandidates[dir] += addWeight;
        totalWeight += randomDirCandidates[dir];
    }
    let sum = 0;
    let rnd = _.random(1, totalWeight, false);
    for (let dir = TOP; dir <= TOP_LEFT; ++dir) {
        sum += randomDirCandidates[dir];
        if (rnd <= sum) {
            return dir;
        }
    }
    return Common.getRandomDir();
}
function getNudgeDirection_KeepRange(pos, target) {
    const room = Game.rooms[pos.roomName];
    const terrain = Game.map.getRoomTerrain(pos.roomName);
    let keepRangeTotalWeight = 0;
    let randomTotalWeight = 0;
    for (let dir = TOP; dir <= TOP_LEFT; ++dir) {
        keepRangeDirCandidates[dir] = 0;
        randomDirCandidates[dir] = 0;
        let posX = pos.x + Common.offsetX[dir];
        let posY = pos.y + Common.offsetY[dir];
        if (posX < 1 || posX > 48 || posY < 1 || posY > 48)
            continue;
        if ((terrain.get(posX, posY) & TERRAIN_MASK_WALL) > 0 && !room.lookForAt(LOOK_STRUCTURES, posX, posY).find(s => s.structureType === STRUCTURE_ROAD))
            continue;
        if (room.lookForAt(LOOK_STRUCTURES, posX, posY).find(s => s.isObstacle()))
            continue;
        const hasCreeps = room.lookForAt(LOOK_CREEPS, posX, posY).length > 0;
        const addWeight = hasCreeps ? 1 : 2;
        randomDirCandidates[dir] += addWeight;
        if (target.pos.inRangeTo(posX, posY, target.range))
            keepRangeDirCandidates[dir] += addWeight;
        keepRangeTotalWeight += keepRangeDirCandidates[dir];
        randomTotalWeight += randomDirCandidates[dir];
    }
    const dirCandidates = keepRangeTotalWeight > 0 ? keepRangeDirCandidates : randomDirCandidates;
    const totalWeight = keepRangeTotalWeight > 0 ? keepRangeTotalWeight : randomTotalWeight;
    let sum = 0;
    if (totalWeight > 0) {
        let rnd = _.random(1, totalWeight, false);
        for (let dir = TOP; dir <= TOP_LEFT; ++dir) {
            sum += dirCandidates[dir];
            if (rnd <= sum) {
                return dir;
            }
        }
    }
    return Common.getRandomDir();
}
function giveWay(creep, arg) {
    Profiler.push('Creep::giveWay');
    if (creep.memory.excuseMe) {
        if (!arg)
            creep.move(creep.memory.excuseMe, true);
        else if (typeof arg === 'object')
            creep.move(getNudgeDirection_KeepRange(creep.pos, arg), true);
        else
            creep.move(getNudgeDirection_Random(creep.pos), true);
    }
    Profiler.pop();
}
if (!Creep.prototype.hasOwnProperty('goToMemory')) {
    Object.defineProperty(Creep.prototype, 'goToMemory', {
        get: function () {
            return Pather.goToMemory[this.name];
        }
    });
}
var say = Creep.prototype.say;
Creep.prototype.say = function (message, toPublic) {
    if (_.isUndefined(toPublic))
        toPublic = true;
    return say.call(this, message, toPublic);
};
Creep.prototype.smokeBreak = function () {
    if (this.pos.isExit())
        this.moveOffExit();
    else
        this.giveWay(true);
    this.say('\u{1F6AC}');
};
Creep.prototype.isSmoking = function () {
    return this.saying === '\u{1F6AC}';
};
Creep.prototype.giveWay = function (arg) {
    giveWay(this, arg);
};
const RMA_DAMAGE = [
    10,
    10,
    4,
    1
];
Creep.prototype.shootAtWill = function (targets, focus) {
    if (targets.length === 0)
        return;
    if (this.getActiveBodyparts(RANGED_ATTACK)) {
        let allies = this.room.findAlliedCreeps();
        let massAttackDmg = 0;
        if (!allies.some(a => a.pos.inRangeTo(this.pos, 3))) {
            for (let target of targets) {
                let range = this.pos.getRangeTo(target);
                if (range <= 3 && ('owner' in target) && !target.pos.lookFor(LOOK_STRUCTURES).find(s => s !== target && s.structureType === STRUCTURE_RAMPART))
                    massAttackDmg += RMA_DAMAGE[range];
            }
        }
        if (focus && ((this.pos.getRangeTo(focus) > 1 && this.pos.getRangeTo(focus) <= 3) || this.pos.isNearTo(focus) && !('owner' in focus)))
            this.rangedAttack(focus);
        else if (massAttackDmg > 10)
            this.rangedMassAttack();
        else {
            let target = _.min(targets, t => ((t.hits && this.pos.inRangeTo(t.pos, 3)) ? t.hits : Infinity));
            this.rangedAttack(target);
        }
    }
    if (this.getActiveBodyparts(ATTACK)) {
        if (focus && this.pos.isNearTo(focus))
            this.attack(focus);
        else {
            let target = _.min(targets, t => (t.hits && this.pos.isNearTo(t.pos) ? t.hits : Infinity));
            this.attack(target);
        }
    }
};
Creep.prototype.goTo = function (goal, range, opts) {
    return Pather.goTo(this, goal, range, opts);
};
Creep.prototype.goToRoom = function (roomName, opts) {
    return this.goTo(new RoomPosition(25, 25, roomName), 22, opts);
};
Creep.prototype.flee = function (threats, opts) {
    return Pather.flee(this, threats, opts);
};
Creep.prototype.fleeFromRoom = function (roomName, opts) {
    if (this.pos.roomName === roomName) {
        let closest = null;
        let range = Infinity;
        let exits = Game.map.describeExits(roomName);
        for (let dir in exits) {
            const exit = exits[dir];
            const exitRoomIntel = GIntel.rooms[exit];
            if (exitRoomIntel && !exitRoomIntel.isSafe)
                continue;
            let closestThisDir = this.pos.findClosestByPath(parseInt(dir));
            let rangeThisDir = this.pos.getRangeTo(closestThisDir);
            if (rangeThisDir < range) {
                range = rangeThisDir;
                closest = closestThisDir;
            }
        }
        if (closest)
            this.goTo(closest, 0, opts);
        else
            this.goTo(this.pos.findClosestByRange(FIND_EXIT), 0, opts);
    }
    else if (this.pos.isExit())
        this.moveOffExit();
    else
        this.giveWay(true);
    this.say('😱');
};
Creep.prototype.moveOffExit = function () {
    let directions;
    if (this.pos.x === 0)
        directions = [RIGHT, TOP_RIGHT, BOTTOM_RIGHT];
    else if (this.pos.y === 0)
        directions = [BOTTOM, BOTTOM_LEFT, BOTTOM_RIGHT];
    else if (this.pos.x === 49)
        directions = [LEFT, TOP_LEFT, BOTTOM_LEFT];
    else if (this.pos.y === 49)
        directions = [TOP, TOP_LEFT, TOP_RIGHT];
    else
        return;
    let terrain = Game.map.getRoomTerrain(this.pos.roomName);
    let dir = directions.find(d => {
        let nextPos = this.pos.nextPosition(d);
        if ((terrain.get(nextPos.x, nextPos.y) & TERRAIN_MASK_WALL) > 0)
            return false;
        if (nextPos.lookFor(LOOK_CREEPS).length > 0)
            return false;
        return true;
    });
    if (!dir) {
        dir = directions.find(d => {
            let nextPos = this.pos.nextPosition(d);
            if ((terrain.get(nextPos.x, nextPos.y) & TERRAIN_MASK_WALL) > 0)
                return false;
            return true;
        });
    }
    if (dir)
        this.move(dir, true);
};
Creep.prototype.isPowerCreep = function () {
    return false;
};
PowerCreep.prototype.getActiveBodyparts = function (type) {
    if (type === MOVE)
        return 1;
    else if (type === CARRY)
        return this.carryCapacity / CARRY_CAPACITY;
    else
        return 0;
};
if (!PowerCreep.prototype.hasOwnProperty('body')) {
    Object.defineProperty(PowerCreep.prototype, "body", {
        get: function () {
            return [{
                    hits: this.hits,
                    type: MOVE
                }];
        }
    });
}
if (!PowerCreep.prototype.hasOwnProperty('fatigue')) {
    Object.defineProperty(PowerCreep.prototype, "fatigue", {
        get: function () {
            return 0;
        }
    });
}
if (!PowerCreep.prototype.hasOwnProperty('goToMemory')) {
    Object.defineProperty(PowerCreep.prototype, 'goToMemory', {
        get: function () {
            return Pather.goToMemory[this.name];
        }
    });
}
PowerCreep.prototype.goTo = function (goal, range, opts) {
    if (!opts)
        opts = { offroad: true };
    if (!opts.offroad)
        opts.offroad = true;
    return Pather.goTo(this, goal, range, opts);
};
PowerCreep.prototype.goToRoom = function (roomName, opts) {
    return this.goTo(new RoomPosition(25, 25, roomName), 22, opts);
};
PowerCreep.prototype.giveWay = function (arg) {
    giveWay(this, arg);
};
PowerCreep.prototype.isPowerCreep = function () {
    return false;
};

// TODO - change caching technique in case of persistent Game objects
Room.prototype.findHostileCreeps = function () {
    if (!this._hostileCreeps) {
        this._hostileCreeps = [...this.find(FIND_HOSTILE_CREEPS), ...this.find(FIND_HOSTILE_POWER_CREEPS)].filter(creep => !Config.WHITELIST.has(creep.owner.username));
    }
    return this._hostileCreeps;
};
// TODO - change caching technique in case of persistent Game objects
Room.prototype.findAlliedCreeps = function () {
    if (!this._alliedCreeps) {
        this._alliedCreeps = [...this.find(FIND_HOSTILE_CREEPS), ...this.find(FIND_HOSTILE_POWER_CREEPS)].filter(creep => Config.ALLIES.has(creep.owner.username));
    }
    return this._alliedCreeps;
};
// TODO - change caching technique in case of persistent Game objects
Room.prototype.findWhitelistedCreeps = function () {
    if (!this._alliedCreeps) {
        this._whitelistedCreeps = [...this.find(FIND_HOSTILE_CREEPS), ...this.find(FIND_HOSTILE_POWER_CREEPS)].filter(creep => Config.WHITELIST.has(creep.owner.username));
    }
    return this._whitelistedCreeps;
};
// TODO - change caching technique in case of persistent Game objects
Room.prototype.findFriendlyCreeps = function () {
    if (!this._friendlyCreeps) {
        let allies = this.findAlliedCreeps();
        this._friendlyCreeps = [...this.find(FIND_MY_CREEPS), ...this.find(FIND_MY_POWER_CREEPS), ...allies];
    }
    return this._friendlyCreeps;
};
Room.prototype.getExitTo = function (roomName) {
    return Common.getExitDir(this.name, roomName);
};
if (!Room.prototype.hasOwnProperty('myRoom')) {
    Object.defineProperty(Room.prototype, 'myRoom', {
        get: function () {
            return GEmpire.myRooms.find(r => r.roomName === this.name);
        }
    });
}
if (!Room.prototype.hasOwnProperty('intel')) {
    Object.defineProperty(Room.prototype, 'intel', {
        get: function () {
            return global.GIntel.rooms[this.name];
        }
    });
}

RoomPosition.deserialize = function (serializedPos) {
    let params = serializedPos.split(',');
    return new RoomPosition(parseInt(params[0]), parseInt(params[1]), params[2]);
};
RoomPosition.prototype.serialize = function () {
    return this.x + ',' + this.y + ',' + this.roomName;
};
RoomPosition.prototype.isExit = function () {
    return Common.isExit(this.x, this.y, this.roomName);
};
RoomPosition.prototype.link = function () {
    return `<a href="#!/room/${Game.shard.name}/${this.roomName}">[${this.roomName} ${this.x},${this.y}]</a>`;
};
RoomPosition.prototype.lookInRange = function (type, range) {
    return Game.rooms[this.roomName].lookForAtArea(type, Math.max(0, this.y - range), Math.max(0, this.x - range), Math.min(49, this.y + range), Math.min(49, this.x + range), true).map(found => found[type]);
};
RoomPosition.prototype.nextPosition = function (dir) {
    let xx = this.x + Common.offset[dir].x;
    let yy = this.y + Common.offset[dir].y;
    if (xx < 0 || yy < 0 || xx > 49 || yy > 49)
        return undefined;
    return new RoomPosition(xx, yy, this.roomName);
};
RoomPosition.prototype.isWalkable = function () {
    const terrain = Game.map.getRoomTerrain(this.roomName);
    if (terrain.get(this.x, this.y))
        return false;
    if (this.lookFor(LOOK_STRUCTURES).find(s => s.isObstacle()))
        return false;
    return true;
};
RoomPosition.prototype.toWorldPos = function () {
    let x = this.x;
    let y = this.y;
    let match = this.roomName.match(/^([WE])([0-9]+)([NS])([0-9]+)$/);
    let rx = parseInt(match[2]);
    let ry = parseInt(match[4]);
    if (match[1] === 'W') {
        x = ~x;
        rx *= -1;
    }
    if (match[3] === 'N') {
        y = ~y;
        ry *= -1;
    }
    return {
        x: (50 * rx) + x,
        y: (50 * ry) + y
    };
};
RoomPosition.prototype.getInterroomRange = function (pos) {
    if (this.roomName === pos.roomName)
        return this.getRangeTo(pos.x, pos.y);
    else {
        let worldThis = this.toWorldPos();
        let worldPos = pos.toWorldPos();
        return Math.max(Math.abs(worldThis.x - worldPos.x), Math.abs(worldThis.y - worldPos.y));
    }
};
RoomPosition.prototype.inInterroomRangeTo = function (pos, range) {
    return this.getInterroomRange(pos) <= range;
};

// Creep ------------------------------------------------------------------------------
var attack = Creep.prototype.attack;
Creep.prototype.attack = function (target) {
    Profiler.push('Creep::attack', "Intent" /* ProfilerFunctionType.Intent */);
    let result = attack.call(this, target);
    Profiler.pop();
    return result;
};
var attackController = Creep.prototype.attackController;
Creep.prototype.attackController = function (target) {
    Profiler.push('Creep::attackController', "Intent" /* ProfilerFunctionType.Intent */);
    let result = attackController.call(this, target);
    Profiler.pop();
    return result;
};
var build = Creep.prototype.build;
Creep.prototype.build = function (target) {
    Profiler.push('Creep::build', "Intent" /* ProfilerFunctionType.Intent */);
    let result = build.call(this, target);
    Profiler.pop();
    return result;
};
var dismantle = Creep.prototype.dismantle;
Creep.prototype.dismantle = function (target) {
    Profiler.push('Creep::dismantle', "Intent" /* ProfilerFunctionType.Intent */);
    let result = dismantle.call(this, target);
    Profiler.pop();
    return result;
};
var drop = Creep.prototype.drop;
Creep.prototype.drop = function (resourceType, amount) {
    Profiler.push('Creep::drop', "Intent" /* ProfilerFunctionType.Intent */);
    let result = drop.call(this, resourceType, amount);
    Profiler.pop();
    return result;
};
var harvest = Creep.prototype.harvest;
if (Game.shard.name !== 'swc') {
    Creep.prototype.harvest = function (target) {
        Profiler.push('Creep::harvest', "Intent" /* ProfilerFunctionType.Intent */);
        let result = harvest.call(this, target);
        Profiler.pop();
        return result;
    };
}
else {
    Creep.prototype.harvest = function (target) {
        Profiler.push('Creep::harvest', "Intent" /* ProfilerFunctionType.Intent */);
        let result = harvest.call(this, target);
        Profiler.pop();
        return result;
    };
}
var heal = Creep.prototype.heal;
Creep.prototype.heal = function (target) {
    Profiler.push('Creep::heal', "Intent" /* ProfilerFunctionType.Intent */);
    let result = heal.call(this, target);
    Profiler.pop();
    return result;
};
var move = Creep.prototype.move;
Creep.prototype.move = function (direction, nudge) {
    Pather.addMoved(this);
    if (nudge && _.isNumber(direction) && this.fatigue === 0)
        Common.excuseMe(this.pos, direction);
    //
    Profiler.push('Creep::move', "Intent" /* ProfilerFunctionType.Intent */);
    let result = move.call(this, direction);
    Profiler.pop();
    return result;
};
var pickup = Creep.prototype.pickup;
Creep.prototype.pickup = function (target) {
    Profiler.push('Creep::pickup', "Intent" /* ProfilerFunctionType.Intent */);
    let result = pickup.call(this, target);
    Profiler.pop();
    return result;
};
var rangedAttack = Creep.prototype.rangedAttack;
Creep.prototype.rangedAttack = function (target) {
    Profiler.push('Creep::rangedAttack', "Intent" /* ProfilerFunctionType.Intent */);
    let result = rangedAttack.call(this, target);
    Profiler.pop();
    return result;
};
var rangedHeal = Creep.prototype.rangedHeal;
Creep.prototype.rangedHeal = function (target) {
    Profiler.push('Creep::rangedHeal', "Intent" /* ProfilerFunctionType.Intent */);
    let result = rangedHeal.call(this, target);
    Profiler.pop();
    return result;
};
var rangedMassAttack = Creep.prototype.rangedMassAttack;
Creep.prototype.rangedMassAttack = function () {
    Profiler.push('Creep::rangedMassAttack', "Intent" /* ProfilerFunctionType.Intent */);
    let result = rangedMassAttack.call(this);
    Profiler.pop();
    return result;
};
var repair = Creep.prototype.repair;
Creep.prototype.repair = function (target) {
    Profiler.push('Creep::repair', "Intent" /* ProfilerFunctionType.Intent */);
    let result = repair.call(this, target);
    Profiler.pop();
    return result;
};
var reserveController = Creep.prototype.reserveController;
Creep.prototype.reserveController = function (target) {
    Profiler.push('Creep::reserveController', "Intent" /* ProfilerFunctionType.Intent */);
    let result = reserveController.call(this, target);
    Profiler.pop();
    return result;
};
var transfer = Creep.prototype.transfer;
Creep.prototype.transfer = function (target, resourceType, amount) {
    Profiler.push('Creep::transfer', "Intent" /* ProfilerFunctionType.Intent */);
    let result = transfer.call(this, target, resourceType, amount);
    Profiler.pop();
    return result;
};
var upgradeController = Creep.prototype.upgradeController;
Creep.prototype.upgradeController = function (target) {
    Profiler.push('Creep::upgradeController', "Intent" /* ProfilerFunctionType.Intent */);
    let result = upgradeController.call(this, target);
    Profiler.pop();
    return result;
};
var withdraw = Creep.prototype.withdraw;
Creep.prototype.withdraw = function (target, resourceType, amount) {
    Profiler.push('Creep::withdraw', "Intent" /* ProfilerFunctionType.Intent */);
    let result = withdraw.call(this, target, resourceType, amount);
    Profiler.pop();
    return result;
};
// StructureTower ---------------------------------------------------------------------
var structureTowerAttack = StructureTower.prototype.attack;
StructureTower.prototype.attack = function (target) {
    Profiler.push('StructureTower::attack', "Intent" /* ProfilerFunctionType.Intent */);
    let result = structureTowerAttack.call(this, target);
    Profiler.pop();
    return result;
};
var structureTowerRepair = StructureTower.prototype.repair;
StructureTower.prototype.repair = function (target) {
    Profiler.push('StructureTower::repair', "Intent" /* ProfilerFunctionType.Intent */);
    let result = structureTowerRepair.call(this, target);
    Profiler.pop();
    return result;
};
var structureTowerHeal = StructureTower.prototype.heal;
StructureTower.prototype.heal = function (target) {
    Profiler.push('StructureTower::heal', "Intent" /* ProfilerFunctionType.Intent */);
    let result = structureTowerHeal.call(this, target);
    Profiler.pop();
    return result;
};
// PowerCreep -------------------------------------------------------------------------
// calls Creep.move
// var PCmove = PowerCreep.prototype.move;
// PowerCreep.prototype.move = function(direction: DirectionConstant | Creep, excuse?: boolean) {
//   Pather.addMoved(this);
// 
//   if (excuse && _.isNumber(direction))
//     Common.excuseMe(this.pos, direction);
// 
//   //
//   Profiler.push('PowerCreep::move', ProfilerFunctionType.Intent);
//   let result = PCmove.call(this, direction);
//   Profiler.pop();
//   return result;
//   };
var PCusePower = PowerCreep.prototype.usePower;
PowerCreep.prototype.usePower = function (power, target) {
    Profiler.push('PowerCreep::usePower');
    let result = PCusePower.call(this, power, target);
    Profiler.pop();
    return result;
};
// StructureSpawn ---------------------------------------------------------------------
// var spawnCreep = StructureSpawn.prototype.spawnCreep;
// StructureSpawn.prototype.spawnCreep = function(body: BodyPartConstant[], name: string, opts?: SpawnOptions) {
//   Profiler.push('StructureSpawn::spawnCreep', StatsFunctionType.Intent);
//   let result = spawnCreep.call(this, body, name, opts);
//   Profiler.pop();
//   return result;
//   };
var renewCreep = StructureSpawn.prototype.renewCreep;
StructureSpawn.prototype.renewCreep = function (target) {
    Profiler.push('StructureSpawn::renewCreep', "Intent" /* ProfilerFunctionType.Intent */);
    let result = renewCreep.call(this, target);
    Profiler.pop();
    return result;
};
// var recycleCreep = StructureSpawn.prototype.recycleCreep;
// StructureSpawn.prototype.recycleCreep = function(target: Creep) {
//   Profiler.push('StructureSpawn::recycleCreep', StatsFunctionType.Intent);
//   let result = recycleCreep.call(this, target);
//   Profiler.pop();
//   return result;
//   };
// StructureLab -----------------------------------------------------------------------
var structureLabRunReaction = StructureLab.prototype.runReaction;
StructureLab.prototype.runReaction = function (lab1, lab2) {
    Profiler.push('StructureLab::runReaction');
    let result = structureLabRunReaction.call(this, lab1, lab2);
    Profiler.pop();
    return result;
};
// var structureLabBoostCreep = StructureLab.prototype.boostCreep;
// StructureLab.prototype.boostCreep = function(creep: Creep, bodypartsCount?: number) {
//   Profiler.push('StructureLab::boostCreep');
//   let result = structureLabBoostCreep.call(this, creep, bodypartsCount);
//   Profiler.pop();
//   return result;
//   };
// Room -------------------------------------------------------------------------------
//var roomFind = Room.prototype.find;
//Room.prototype.find = function<K extends FindConstant>(type: K, opts?: FilterOptions<K>) {
//  Profiler.push('Room.find', StatsFunctionType.Find);
//  let result = roomFind.call(this, type, opts);
//  Profiler.pop();
//  return result;
//  };
// StructurePowerSpawn ----------------------------------------------------------------
var structurePowerSpawnProcessPower = StructurePowerSpawn.prototype.processPower;
StructurePowerSpawn.prototype.processPower = function () {
    Profiler.push('StructurePowerSpawn::processPower', "Intent" /* ProfilerFunctionType.Intent */);
    let result = structurePowerSpawnProcessPower.call(this);
    Profiler.pop();
    return result;
};
// var roomLookFor = Room.prototype.lookForAt;
// Room.prototype.lookForAt = function<T extends keyof AllLookAtTypes>(type: T, x: number | RoomPosition | _HasRoomPosition, y?: number) {
//   Profiler.push('Room.lookForAt', StatsFunctionType.LookFor);
//   let result = roomLookFor.call(this, type, x, y);
//   Profiler.pop();
//   return result;
//   };
// StructureTerminal ------------------------------------------------------------------
// var structureTerminalSend = StructureTerminal.prototype.send;
// StructureTerminal.prototype.send = function(resourceType: ResourceConstant, amount: number, destination: string, description?: string) {
//   Profiler.push('StructureTerminal::send', StatsFunctionType.Intent);
//   let result = structureTerminalSend.call(this, resourceType, amount, destination, description);
//   Profiler.pop();
//   return result;
//   };
// StructureObserver ------------------------------------------------------------------
var structureObserverObserveRoom = StructureObserver.prototype.observeRoom;
StructureObserver.prototype.observeRoom = function (roomName) {
    Profiler.push('StructureObserver::observeRoom', "Intent" /* ProfilerFunctionType.Intent */);
    let result = structureObserverObserveRoom.call(this, roomName);
    Profiler.pop();
    return result;
};

Structure.prototype.isAttackable = function () {
    return !!this.hits;
};
Structure.prototype.isBuildable = function () {
    return !!this.hits && this.structureType !== STRUCTURE_POWER_BANK && this.structureType !== STRUCTURE_INVADER_CORE;
};
Structure.prototype.isObstacle = function () {
    if (this.structureType === STRUCTURE_RAMPART && !this.my)
        return true;
    if (OBSTACLE_STRUCTURE_TYPES.has(this.structureType))
        return true;
    return false;
};
Structure.prototype.isOwned = function () {
    return 'owner' in this;
};
Structure.prototype.isMy = function () {
    return this.isOwned() && this.my;
};
Structure.prototype.hasStore = function () {
    return 'store' in this;
};
var structureIsActive = OwnedStructure.prototype.isActive;
OwnedStructure.prototype.isActive = function () {
    if (this.room.controller && this.room.controller.level === 8)
        return true;
    else
        return structureIsActive.call(this);
};

const colors = {
    gray: '#555555',
    light: '#AAAAAA',
    road: '#666',
    energy: '#FFE87B',
    power: '#F53547',
    dark: '#181818',
    outline: '#8FBB93',
    speechText: '#000000',
    speechBackground: '#2ccf3b'
};
const speechSize = 0.5;
const speechFont = 'Times New Roman';
function calculateFactoryLevelGapsPoly() {
    let x = -0.08;
    let y = -0.52;
    let result = [];
    let gapAngle = 16 * (Math.PI / 180);
    let c1 = Math.cos(gapAngle);
    let s1 = Math.sin(gapAngle);
    let angle = 72 * (Math.PI / 180);
    let c2 = Math.cos(angle);
    let s2 = Math.sin(angle);
    for (let i = 0; i < 5; ++i) {
        result.push([0.0, 0.0]);
        result.push([x, y]);
        result.push([x * c1 - y * s1, x * s1 + y * c1]);
        let tmpX = x * c2 - y * s2;
        y = x * s2 + y * c2;
        x = tmpX;
    }
    return result;
}
const factoryLevelGaps = calculateFactoryLevelGapsPoly();
RoomVisual.prototype.structure = function (x, y, type, opts = {}) {
    /*
    opts = Object.assign({
      opacity: 1
    }, opts);
    */
    switch (type) {
        case STRUCTURE_FACTORY: {
            const outline = [
                [-0.68, -0.11],
                [-0.84, -0.18],
                [-0.84, -0.32],
                [-0.44, -0.44],
                [-0.32, -0.84],
                [-0.18, -0.84],
                [-0.11, -0.68],
                [0.11, -0.68],
                [0.18, -0.84],
                [0.32, -0.84],
                [0.44, -0.44],
                [0.84, -0.32],
                [0.84, -0.18],
                [0.68, -0.11],
                [0.68, 0.11],
                [0.84, 0.18],
                [0.84, 0.32],
                [0.44, 0.44],
                [0.32, 0.84],
                [0.18, 0.84],
                [0.11, 0.68],
                [-0.11, 0.68],
                [-0.18, 0.84],
                [-0.32, 0.84],
                [-0.44, 0.44],
                [-0.84, 0.32],
                [-0.84, 0.18],
                [-0.68, 0.11]
            ];
            this.poly(outline.map(p => [p[0] + x, p[1] + y]), {
                fill: null,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            // outer circle
            this.circle(x, y, {
                radius: 0.65,
                fill: '#232323',
                strokeWidth: 0.035,
                stroke: '#140a0a',
                opacity: opts.opacity
            });
            const spikes = [
                [-0.4, -0.1],
                [-0.8, -0.2],
                [-0.8, -0.3],
                [-0.4, -0.4],
                [-0.3, -0.8],
                [-0.2, -0.8],
                [-0.1, -0.4],
                [0.1, -0.4],
                [0.2, -0.8],
                [0.3, -0.8],
                [0.4, -0.4],
                [0.8, -0.3],
                [0.8, -0.2],
                [0.4, -0.1],
                [0.4, 0.1],
                [0.8, 0.2],
                [0.8, 0.3],
                [0.4, 0.4],
                [0.3, 0.8],
                [0.2, 0.8],
                [0.1, 0.4],
                [-0.1, 0.4],
                [-0.2, 0.8],
                [-0.3, 0.8],
                [-0.4, 0.4],
                [-0.8, 0.3],
                [-0.8, 0.2],
                [-0.4, 0.1]
            ];
            this.poly(spikes.map(p => [p[0] + x, p[1] + y]), {
                fill: colors.gray,
                stroke: '#140a0a',
                strokeWidth: 0.04,
                opacity: opts.opacity
            });
            // factory level circle
            this.circle(x, y, {
                radius: 0.54,
                fill: '#302a2a',
                strokeWidth: 0.04,
                stroke: '#140a0a',
                opacity: opts.opacity
            });
            this.poly(factoryLevelGaps.map(p => [p[0] + x, p[1] + y]), {
                fill: '#140a0a',
                stroke: null,
                opacity: opts.opacity
            });
            // inner black circle
            this.circle(x, y, {
                radius: 0.42,
                fill: '#140a0a',
                opacity: opts.opacity
            });
            this.rect(x - 0.24, y - 0.24, 0.48, 0.48, {
                fill: '#3f3f3f',
                opacity: opts.opacity
            });
            break;
        }
        case STRUCTURE_EXTENSION:
            this.circle(x, y, {
                radius: 0.5,
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.circle(x, y, {
                radius: 0.35,
                fill: colors.energy,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_SPAWN:
            this.circle(x, y, {
                radius: 0.65,
                fill: colors.dark,
                stroke: '#CCCCCC',
                strokeWidth: 0.10,
                opacity: opts.opacity
            });
            this.circle(x, y, {
                radius: 0.40,
                fill: colors.energy,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_POWER_SPAWN:
            this.circle(x, y, {
                radius: 0.65,
                fill: colors.dark,
                stroke: colors.power,
                strokeWidth: 0.10,
                opacity: opts.opacity
            });
            this.circle(x, y, {
                radius: 0.40,
                fill: colors.energy,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_LINK:
            {
                let outer = [
                    [0.0, -0.5],
                    [0.4, 0.0],
                    [0.0, 0.5],
                    [-0.4, 0.0]
                ];
                let inner = [
                    [0.0, -0.3],
                    [0.25, 0.0],
                    [0.0, 0.3],
                    [-0.25, 0.0]
                ];
                outer = relPoly(x, y, outer);
                inner = relPoly(x, y, inner);
                outer.push(outer[0]);
                inner.push(inner[0]);
                this.poly(outer, {
                    fill: colors.dark,
                    stroke: colors.outline,
                    strokeWidth: 0.05,
                    opacity: opts.opacity
                });
                this.poly(inner, {
                    fill: colors.gray,
                    stroke: null,
                    opacity: opts.opacity
                });
                break;
            }
        case STRUCTURE_TERMINAL:
            {
                let outer = [
                    [0.0, -0.8],
                    [0.55, -0.55],
                    [0.8, 0.0],
                    [0.55, 0.55],
                    [0.0, 0.8],
                    [-0.55, 0.55],
                    [-0.8, 0.0],
                    [-0.55, -0.55]
                ];
                let inner = [
                    [0.0, -0.65],
                    [0.45, -0.45],
                    [0.65, 0.0],
                    [0.45, 0.45],
                    [0.0, 0.65],
                    [-0.45, 0.45],
                    [-0.65, 0.0],
                    [-0.45, -0.45]
                ];
                outer = relPoly(x, y, outer);
                inner = relPoly(x, y, inner);
                outer.push(outer[0]);
                inner.push(inner[0]);
                this.poly(outer, {
                    fill: colors.dark,
                    stroke: colors.outline,
                    strokeWidth: 0.05,
                    opacity: opts.opacity
                });
                this.poly(inner, {
                    fill: colors.light,
                    stroke: null,
                    opacity: opts.opacity
                });
                this.rect(x - 0.45, y - 0.45, 0.9, 0.9, {
                    fill: colors.gray,
                    stroke: colors.dark,
                    strokeWidth: 0.1,
                    opacity: opts.opacity
                });
                break;
            }
        case STRUCTURE_LAB:
            this.circle(x, y - 0.025, {
                radius: 0.55,
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.circle(x, y - 0.025, {
                radius: 0.40,
                fill: colors.gray,
                opacity: opts.opacity
            });
            this.rect(x - 0.45, y + 0.3, 0.9, 0.25, {
                fill: colors.dark,
                stroke: null,
                opacity: opts.opacity
            });
            {
                let box = [
                    [-0.45, 0.3],
                    [-0.45, 0.55],
                    [0.45, 0.55],
                    [0.45, 0.3]
                ];
                box = relPoly(x, y, box);
                this.poly(box, {
                    stroke: colors.outline,
                    strokeWidth: 0.05,
                    opacity: opts.opacity
                });
            }
            break;
        case STRUCTURE_TOWER:
            this.circle(x, y, {
                radius: 0.6,
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.rect(x - 0.4, y - 0.3, 0.8, 0.6, {
                fill: colors.gray,
                opacity: opts.opacity
            });
            this.rect(x - 0.2, y - 0.9, 0.4, 0.5, {
                fill: colors.light,
                stroke: colors.dark,
                strokeWidth: 0.07,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_ROAD:
            this.circle(x, y, {
                radius: 0.175,
                fill: colors.road,
                stroke: null,
                opacity: opts.opacity
            });
            if (!this.roads)
                this.roads = [];
            this.roads.push([x, y]);
            break;
        case STRUCTURE_RAMPART:
            this.circle(x, y, {
                radius: 0.65,
                fill: '#434C43',
                stroke: '#5D735F',
                strokeWidth: 0.10,
                opacity: opts.opacity * 0.45
            });
            break;
        case STRUCTURE_WALL:
            this.circle(x, y, {
                radius: 0.40,
                fill: colors.dark,
                stroke: colors.light,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_STORAGE:
            let outline1 = relPoly(x, y, [
                [-0.45, -0.55],
                [0, -0.65],
                [0.45, -0.55],
                [0.55, 0],
                [0.45, 0.55],
                [0, 0.65],
                [-0.45, 0.55],
                [-0.55, 0],
                [-0.45, -0.55]
            ]);
            this.poly(outline1, {
                stroke: colors.outline,
                strokeWidth: 0.05,
                fill: colors.dark,
                opacity: opts.opacity
            });
            this.rect(x - 0.35, y - 0.45, 0.7, 0.9, {
                fill: colors.energy,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_OBSERVER:
            this.circle(x, y, {
                fill: colors.dark,
                radius: 0.45,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.circle(x + 0.225, y, {
                fill: colors.outline,
                radius: 0.20,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_NUKER: {
            let outline = [
                [0, -1],
                [-0.47, 0.2],
                [-0.5, 0.5],
                [0.5, 0.5],
                [0.47, 0.2],
                [0, -1]
            ];
            outline = relPoly(x, y, outline);
            this.poly(outline, {
                stroke: colors.outline,
                strokeWidth: 0.05,
                fill: colors.dark,
                opacity: opts.opacity
            });
            let inline = [
                [0, -.80],
                [-0.40, 0.2],
                [0.40, 0.2],
                [0, -.80]
            ];
            inline = relPoly(x, y, inline);
            this.poly(inline, {
                stroke: colors.outline,
                strokeWidth: 0.01,
                fill: colors.gray,
                opacity: opts.opacity
            });
            break;
        }
        case STRUCTURE_CONTAINER:
            this.rect(x - 0.225, y - 0.3, 0.45, 0.6, {
                fill: colors.gray,
                opacity: opts.opacity,
                stroke: colors.dark,
                strokeWidth: 0.10
            });
            break;
        default:
            this.circle(x, y, {
                fill: colors.light,
                radius: 0.35,
                stroke: colors.dark,
                strokeWidth: 0.20,
                opacity: opts.opacity
            });
            break;
    }
    return this;
};
const dirs = [
    [],
    [0, -1],
    [1, -1],
    [1, 0],
    [1, 1],
    [0, 1],
    [-1, 1],
    [-1, 0],
    [-1, -1]
];
RoomVisual.prototype.connectRoads = function (opts = {}) {
    let color = opts.color || colors.road || 'white';
    if (!this.roads)
        return this;
    // this.text(this.roads.map(r=>r.join(',')).join(' '),25,23)
    this.roads.forEach(road => {
        // this.text(`${r[0]},${r[1]}`,r[0],r[1],{ size: 0.2 })
        for (let i = 1; i <= 4; i++) {
            let d = dirs[i];
            let c = [road[0] + d[0], road[1] + d[1]];
            let rd = _.some(this.roads, r => r[0] === c[0] && r[1] === c[1]);
            // this.text(`${c[0]},${c[1]}`,c[0],c[1],{ size: 0.2, color: rd?'green':'red' })
            if (rd) {
                this.line(road[0], road[1], c[0], c[1], {
                    color: color,
                    width: 0.35,
                    opacity: opts.opacity || 1
                });
            }
        }
    });
    return this;
};
RoomVisual.prototype.speech = function (text, x, y, opts = {}) {
    let background = opts.background ? opts.background : colors.speechBackground;
    let textcolor = opts.textcolor ? opts.textcolor : colors.speechText;
    let textstyle = opts.textstyle ? opts.textstyle : false;
    let textsize = opts.textsize ? opts.textsize : speechSize;
    let textfont = opts.textfont ? opts.textfont : speechFont;
    let opacity = opts.opacity ? opts.opacity : 1;
    var fontstring = '';
    if (textstyle) {
        fontstring = textstyle + ' ';
    }
    fontstring += textsize + ' ' + textfont;
    let pointer = [
        [-0.2, -0.8],
        [0.2, -0.8],
        [0, -0.3]
    ];
    pointer = relPoly(x, y, pointer);
    pointer.push(pointer[0]);
    this.poly(pointer, {
        fill: background,
        stroke: background,
        opacity: opacity,
        strokeWidth: 0.0
    });
    this.text(text, x, y - 1, {
        color: textcolor,
        backgroundColor: background,
        backgroundPadding: 0.1,
        opacity: opacity,
        font: fontstring
    });
    return this;
};
function relPoly(x, y, poly) {
    return poly.map(p => {
        p[0] += x;
        p[1] += y;
        return p;
    });
}
RoomVisual.prototype.multiRoomLine = function (pos1, pos2, style) {
    let pos1Visual = new RoomVisual(pos1.roomName);
    let pos2Visual = new RoomVisual(pos2.roomName);
    if (pos1.roomName === pos2.roomName)
        pos1Visual.line(pos1.x, pos1.y, pos2.x, pos2.y, style);
    else {
        let parsed = /^([WE])([0-9]+)([NS])([0-9]+)$/.exec(pos1.roomName);
        let pos1RoomX = parseInt(parsed[2]) * (parsed[1] === 'W' ? -1 : 1);
        let pos1RoomY = parseInt(parsed[4]) * (parsed[3] === 'N' ? -1 : 1);
        parsed = /^([WE])([0-9]+)([NS])([0-9]+)$/.exec(pos2.roomName);
        let pos2RoomX = parseInt(parsed[2]) * (parsed[1] === 'W' ? -1 : 1);
        let pos2RoomY = parseInt(parsed[4]) * (parsed[3] === 'N' ? -1 : 1);
        pos1Visual.line(pos1.x, pos1.y, pos2.x + 50 * (pos2RoomX - pos1RoomX), pos2.y + 50 * (pos2RoomY - pos1RoomY), style);
        pos2Visual.line(pos1.x + 50 * (pos1RoomX - pos2RoomX), pos1.y + 50 * (pos1RoomY - pos2RoomY), pos2.x, pos2.y, style);
    }
    return this;
};

class RoomIntel {
    get isPOI() {
        return (this.pointOfInterestExpiration || 0) > Game.time;
    }
    // ---------------------------------------------------------------------
    constructor(roomName, creepRoomCache) {
        this.roomName = roomName;
        this.isSkRoom = Common.isSkRoom(roomName);
        this.isCenterRoom = Common.isCenterRoom(roomName);
        this.isHighway = Common.isHighway(roomName);
        this.isCrossway = Common.isCrossway(roomName);
        this.isPortalRoom = Common.isPortalRoom(roomName);
        this.isControllerRoom = Common.isControllerRoom(roomName);
        this.creepRoomCache = creepRoomCache;
        this.lastStructureUpdate = -9999;
        this.lastCreepUpdate = -9999;
        if (!Memory.rooms)
            Memory.rooms = {};
        if (!Memory.rooms[roomName]) {
            this.init();
        }
        const memory = this.memory;
        if (!this.isHighway) {
            this.sources = memory.sources.map(pos => RoomPosition.deserialize(pos));
            this.mineralType = memory.mineralType;
            this.mineralPos = RoomPosition.deserialize(memory.mineralPos);
        }
        if (this.isControllerRoom) {
            this.controllerPos = RoomPosition.deserialize(memory.controllerPos);
            this.controllerSlots = memory.controllerSlots;
        }
        if (this.isSkRoom) {
            this.sourceKeeperSpots = memory.SKPaths.map(pos => new RoomPosition(pos % 50, Math.floor(pos / 50), this.roomName));
        }
        this.deserialize();
    }
    init() {
        const room = Game.rooms[this.roomName];
        console.log('Scouting room: ' + this.roomName);
        let terrain = Game.map.getRoomTerrain(room.name);
        let [mineral] = room.find(FIND_MINERALS);
        let roomMemory = {
            controllerPos: room.controller ? room.controller.pos.serialize() : undefined,
            controllerSlots: room.controller ? _.sum(Common.offset, o => (terrain.get(room.controller.pos.x + o.x, room.controller.pos.y + o.y) & TERRAIN_MASK_WALL) === 0 ? 1 : 0) : undefined,
            sources: room.find(FIND_SOURCES).map(source => source.pos.serialize()),
            mineralType: mineral ? mineral.mineralType : undefined,
            mineralPos: mineral ? mineral.pos.serialize() : undefined
        };
        if (this.isSkRoom) {
            roomMemory.SKPaths = [];
            let SKLairs = room.find(FIND_HOSTILE_STRUCTURES).filter(s => s.structureType === STRUCTURE_KEEPER_LAIR);
            let veins = [...room.find(FIND_SOURCES), ...room.find(FIND_MINERALS)].map(vein => ({ pos: vein.pos, range: 1 }));
            for (let lair of SKLairs) {
                let searchResult = PathFinder.search(lair.pos, veins);
                let keeperTargetSpot = _.last(searchResult.path);
                if (!keeperTargetSpot) {
                    // vein is next to lair
                    for (let dir in Common.offset) {
                        let posX = lair.pos.x + Common.offset[dir].x;
                        let posY = lair.pos.y + Common.offset[dir].y;
                        if ((terrain.get(posX, posY) & TERRAIN_MASK_WALL) === 0) {
                            keeperTargetSpot = new RoomPosition(posX, posY, room.name);
                            break;
                        }
                    }
                }
                roomMemory.SKPaths.push(keeperTargetSpot.y * 50 + keeperTargetSpot.x);
            }
        }
        Memory.rooms[this.roomName] = roomMemory;
    }
    deserialize() {
        // TODO - TEMP
        if (this.memory['invaderCore']) {
            this.memory.invaderCorePos = this.memory['invaderCore'];
            this.memory.invaderCoreLevel = 0;
            delete this.memory['invaderCore'];
        }
        //
        // controller info
        this.owner = this.memory.owner;
        this.rcl = this.memory.rcl;
        this.energyCapacityAvailable = this.memory.energyCapacityAvailable;
        this.safeMode = this.memory.safeModeExpiration;
        this.upgradeBlocked = this.memory.upgradeBlockedExpiration;
        this.storedEnergy = this.memory.storedEnergy;
        if (this.memory.reserveUsername) {
            const isMy = this.memory.reserveUsername === Common.USERNAME;
            const isAllied = Config.WHITELIST.has(this.memory.reserveUsername);
            this.reservation = {
                username: this.memory.reserveUsername,
                expires: this.memory.reserveExpiration,
                isMy: isMy,
                isAllied: isAllied,
                isHostile: !isMy && !isAllied
            };
        }
        this.updateDerivativeControllerRoomInfo();
        // structure/deposit info
        this.spawns = this.memory.spawns || 0;
        this.towers = this.memory.towers || 0;
        this.invaderCore = this.memory.invaderCorePos
            ? {
                pos: RoomPosition.deserialize(this.memory.invaderCorePos),
                level: this.memory.invaderCoreLevel
            }
            : undefined;
        this.poisoned = this.memory.poisoned || false;
        this.blockedControllerSlots = this.memory.blockedControllerSlots || 0;
        this.powerBank = this.memory.powerBank && {
            decay: this.memory.powerBank.decay,
            hits: this.memory.powerBank.hits,
            id: this.memory.powerBank.id,
            pos: RoomPosition.deserialize(this.memory.powerBank.pos),
            power: this.memory.powerBank.power
        };
        this.deposits = this.memory.deposits
            ? this.memory.deposits.map(d => ({
                type: d.type,
                cooldown: d.cooldown,
                decay: d.decay,
                pos: RoomPosition.deserialize(d.pos)
            }))
            : [];
        // creep info
        this.invasion = this.memory.invasion;
        this.hostiles = this.memory.hostiles
            ? this.memory.hostiles.map(creepInfo => ({
                id: creepInfo.id,
                body: new CreepBody(creepInfo.body, creepInfo.boosts),
                owner: creepInfo.owner,
                expires: creepInfo.expires
            }))
            : [];
        for (let hostile of this.hostiles) {
            this.creepRoomCache.updateCreepRoom(hostile.id, this.roomName);
        }
        this.usedByAlly = this.memory.usedByAlly && {
            username: this.memory.usedByAlly,
            expires: this.memory.usedByAllyTimeout
        };
        this.usedByHostile = this.memory.usedByHostile && {
            username: this.memory.usedByHostile,
            expires: this.memory.usedByHostileTimeout
        };
        // other
        this.lastSafe = this.memory.lastSafe || -9999;
        this.lastUnsafe = this.memory.lastUnsafe || -9999;
        this.lastScout = this.memory.lastScout || -9999;
        this.isSafe = this.lastSafe === this.lastScout;
        this.pointOfInterestExpiration = this.memory.poiExpires;
    }
    serialize() {
        // controller info
        this.memory.owner = this.owner;
        this.memory.rcl = this.rcl;
        this.memory.energyCapacityAvailable = this.energyCapacityAvailable;
        this.memory.safeModeExpiration = this.safeMode;
        this.memory.upgradeBlockedExpiration = this.upgradeBlocked;
        this.memory.storedEnergy = this.storedEnergy;
        this.memory.reserveUsername = this.reservation && this.reservation.username;
        this.memory.reserveExpiration = this.reservation && this.reservation.expires;
        // structure/deposit info
        this.memory.spawns = this.spawns || undefined;
        this.memory.towers = this.towers || undefined;
        this.memory.invaderCorePos = this.invaderCore && this.invaderCore.pos.serialize();
        this.memory.invaderCoreLevel = this.invaderCore && this.invaderCore.level;
        this.memory.poisoned = this.poisoned || undefined;
        this.memory.blockedControllerSlots = this.blockedControllerSlots || undefined;
        this.memory.powerBank = this.powerBank && {
            decay: this.powerBank.decay,
            hits: this.powerBank.hits,
            id: this.powerBank.id,
            pos: this.powerBank.pos.serialize(),
            power: this.powerBank.power
        };
        this.memory.deposits = this.deposits.length === 0
            ? undefined
            : this.deposits.map(d => ({
                type: d.type,
                cooldown: d.cooldown,
                decay: d.decay,
                pos: d.pos.serialize()
            }));
        // creep info
        this.memory.hostiles = this.hostiles.length === 0
            ? undefined
            : this.hostiles.map(creepInfo => ({
                id: creepInfo.id,
                body: creepInfo.body.serializedBody,
                boosts: [...creepInfo.body.boosts],
                owner: creepInfo.owner,
                expires: creepInfo.expires
            }));
        this.memory.invasion = this.invasion;
        this.memory.usedByAlly = this.usedByAlly && this.usedByAlly.username;
        this.memory.usedByAllyTimeout = this.usedByAlly && this.usedByAlly.expires;
        this.memory.usedByHostile = this.usedByHostile && this.usedByHostile.username;
        this.memory.usedByHostileTimeout = this.usedByHostile && this.usedByHostile.expires;
        // other
        this.memory.lastSafe = this.lastSafe;
        this.memory.lastUnsafe = this.lastUnsafe;
        this.memory.lastScout = this.lastScout;
        this.memory.poiExpires = this.pointOfInterestExpiration;
    }
    // ---------------------------------------------------------------------
    get memory() {
        return Memory.rooms[this.roomName];
    }
    // ---------------------------------------------------------------------
    updateControllerRoomInfo(room) {
        if (!this.isControllerRoom)
            return;
        const controller = room.controller;
        this.isMy = controller.my;
        this.owner = controller.owner && controller.owner.username;
        if (this.owner) {
            this.rcl = controller.level;
            this.safeMode = controller.safeMode
                ? controller.safeMode + Game.time
                : undefined;
            this.upgradeBlocked = controller.upgradeBlocked
                ? controller.upgradeBlocked + Game.time
                : undefined;
            this.storedEnergy = (room.storage && room.storage.store.energy || 0) + (room.terminal && room.terminal.store.energy || 0);
            this.energyCapacityAvailable = room.energyCapacityAvailable;
        }
        else {
            this.rcl = undefined;
            this.safeMode = undefined;
            this.upgradeBlocked = undefined;
            this.storedEnergy = undefined;
            this.energyCapacityAvailable = undefined;
        }
        if (controller.reservation) {
            const isMy = controller.reservation.username === Common.USERNAME;
            const isAllied = Config.WHITELIST.has(controller.reservation.username);
            this.reservation = {
                username: controller.reservation.username,
                expires: controller.reservation.ticksToEnd + Game.time,
                isMy: isMy,
                isAllied: isAllied,
                isHostile: !isMy && !isAllied
            };
        }
        else {
            this.reservation = undefined;
        }
        this.updateDerivativeControllerRoomInfo();
    }
    invalidateControllerRoomInfo() {
        if (this.reservation && Game.time > this.reservation.expires)
            this.reservation = undefined;
        if (this.safeMode && Game.time > this.safeMode)
            this.safeMode = undefined;
        if (this.upgradeBlocked && Game.time > this.upgradeBlocked)
            this.upgradeBlocked = undefined;
        this.updateDerivativeControllerRoomInfo();
    }
    updateDerivativeControllerRoomInfo() {
        if (this.owner) {
            if (this.isMy) {
                this.isFriendly = true;
                this.isHostile = false;
            }
            else if (Config.WHITELIST.has(this.owner)) {
                this.isFriendly = true;
                this.isHostile = false;
            }
            else {
                this.isFriendly = false;
                this.isHostile = true;
            }
        }
        else if (this.reservation && this.reservation.isHostile) {
            this.isFriendly = false;
            this.isHostile = true;
        }
        else if (this.reservation) {
            this.isFriendly = true;
            this.isHostile = false;
        }
        else {
            this.isFriendly = false;
            this.isHostile = false;
        }
    }
    updateStructuresAndDeposits(room) {
        if (this.lastStructureUpdate > Game.time - 20)
            return;
        if (this.owner) {
            this.spawns = room.find(FIND_MY_SPAWNS).length + room.find(FIND_HOSTILE_SPAWNS).length;
        }
        const poisonPOIs = this.isControllerRoom && [room.controller.pos, ...room.find(FIND_SOURCES).map(s => s.pos)];
        this.spawns = 0;
        this.towers = 0;
        this.blockedControllerSlots = 0;
        this.poisoned = false;
        this.portals = undefined;
        this.intershardPortals = undefined;
        this.powerBank = undefined;
        this.invaderCore = undefined;
        const structures = room.find(FIND_STRUCTURES);
        for (let structure of structures) {
            switch (structure.structureType) {
                case STRUCTURE_SPAWN:
                    ++this.spawns;
                    break;
                case STRUCTURE_TOWER:
                    ++this.towers;
                    break;
                case STRUCTURE_INVADER_CORE:
                    this.invaderCore = {
                        pos: structure.pos,
                        level: structure.level
                    };
                    break;
                case STRUCTURE_PORTAL:
                    if (this.isCenterRoom) {
                        const destination = structure.destination;
                        this.portals = this.portals || [];
                        this.portals.push({
                            pos: structure.pos,
                            destination: destination,
                            decayAt: structure.ticksToDecay + Game.time
                        });
                    }
                    else { // if (this.isCrossway) {
                        const destination = structure.destination;
                        this.intershardPortals = this.intershardPortals || [];
                        this.intershardPortals.push({
                            pos: structure.pos,
                            destinationShard: destination.shard,
                            destinationRoom: destination.room
                        });
                    }
                    break;
                case STRUCTURE_WALL:
                    if (this.isControllerRoom && !this.poisoned && poisonPOIs.some(poi => poi.isNearTo(structure.pos)))
                        this.poisoned = true;
                    break;
                case STRUCTURE_POWER_BANK:
                    this.powerBank = {
                        power: structure.power,
                        hits: structure.hits,
                        pos: structure.pos,
                        decay: Game.time + structure.ticksToDecay,
                        id: structure.id
                    };
                    break;
            }
            if (this.isControllerRoom && structure.pos.isNearTo(room.controller.pos) && structure !== room.controller && structure.isObstacle())
                ++this.blockedControllerSlots;
        }
        if (this.isHighway) {
            let deposits = room.find(FIND_DEPOSITS);
            this.deposits = deposits.map(d => ({
                type: d.depositType,
                cooldown: d.lastCooldown,
                decay: Game.time + d.ticksToDecay,
                pos: d.pos
            }));
        }
    }
    updateCreepInfo(room) {
        if (this.lastCreepUpdate > Game.time - 10)
            return;
        this.lastCreepUpdate = Game.time;
        this.invasion = undefined;
        this.hostiles = [];
        let creeps = room.find(FIND_HOSTILE_CREEPS);
        for (let creep of creeps) {
            // ignore my creeps
            if (creep.my)
                continue;
            // ignore source keepers
            if (creep.owner.username === 'Source Keeper')
                continue;
            // ignore stronghold defenders
            const isStrongholdDefender = this.isSkRoom
                && creep.owner.username === 'Invader'
                && creep.name.startsWith('defender');
            if (isStrongholdDefender)
                continue;
            const isFriendly = Config.WHITELIST.has(creep.owner.username);
            //const isInvader = (creep.owner.username === 'Invader');
            //
            GCreepBodyCache.add(creep);
            const creepBody = GCreepBodyCache.get(creep.id);
            // invasions
            if (!isFriendly) {
                if (creepBody[ATTACK] || creepBody[RANGED_ATTACK] || creepBody[HEAL] || creepBody[CLAIM]) {
                    this.hostiles.push({
                        body: creepBody,
                        expires: Game.time + creep.ticksToLive,
                        id: creep.id,
                        owner: creep.owner.username
                    });
                    this.creepRoomCache.updateCreepRoom(creep.id, this.roomName);
                }
                //
                if (!this.invasion) {
                    this.invasion = {
                        expires: 0,
                        bodyparts: 0,
                        meleeAttack: 0,
                        rangedAttack: 0,
                        heal: 0,
                        dmgMultiplier: 1,
                        owner: creep.owner.username
                    };
                }
                this.invasion.expires = Math.max(this.invasion.expires, Game.time + creep.ticksToLive);
                this.invasion.bodyparts += creep.body.length;
                this.invasion.meleeAttack += creepBody.attackPower;
                this.invasion.rangedAttack += creepBody.rangedAttackPower;
                this.invasion.heal += creepBody.healPower;
                this.invasion.dmgMultiplier = Math.min(creepBody.toughMultiplier, this.invasion.dmgMultiplier);
            }
            if (!this.isMy) {
                let isSourceWorker = creepBody[WORK] > 0 && !this.isHighway;
                let isDepositWorker = creepBody[WORK] > 0 && this.deposits.length > 0;
                let isPowerWorker = (creepBody[ATTACK] > 0 || creepBody[CARRY] > 0) && this.powerBank;
                if (isSourceWorker || isDepositWorker || isPowerWorker) {
                    if (isFriendly) {
                        this.usedByAlly = {
                            username: creep.owner.username,
                            expires: Game.time + creep.ticksToLive + CREEP_LIFE_TIME
                        };
                    }
                    else {
                        this.usedByHostile = {
                            username: creep.owner.username,
                            expires: Game.time + creep.ticksToLive + CREEP_LIFE_TIME
                        };
                    }
                }
            }
        }
    }
    invalidateCreepInfo() {
        if (this.memory.invasion && this.memory.invasion.expires < Game.time)
            this.memory.invasion = undefined;
        if (this.usedByAlly && this.usedByAlly.expires < Game.time)
            this.usedByAlly = undefined;
        if (this.usedByHostile && this.usedByHostile.expires < Game.time)
            this.usedByHostile = undefined;
        if (this.hostiles.some(h => h.expires <= Game.time))
            this.hostiles = this.hostiles.filter(h => h.expires > Game.time);
    }
    updateIsSafe(room) {
        if (this.isMy && room.controller.safeMode)
            this.isSafe = true;
        else if (this.invasion && (this.invasion.meleeAttack > 0 || this.invasion.rangedAttack > 0))
            this.isSafe = false;
        else if (this.isMy)
            this.isSafe = true;
        else if (this.owner && !Config.ALLIES.has(this.owner) && this.towers > 0)
            this.isSafe = false;
        else if (this.isCenterRoom && this.invaderCore && this.towers > 0)
            this.isSafe = false;
        else
            this.isSafe = true;
        if (this.isSafe)
            this.lastSafe = Game.time;
        else
            this.lastUnsafe = Game.time;
    }
    // ---------------------------------------------------------------------
    update() {
        let room = Game.rooms[this.roomName];
        if (!room)
            return;
        if (this.memory.reinit) {
            this.init();
            delete this.memory.reinit;
        }
        this.updateControllerRoomInfo(room);
        this.updateStructuresAndDeposits(room);
        this.updateCreepInfo(room);
        //
        this.updateIsSafe(room);
        this.lastScout = Game.time;
        this.serialize();
    }
    invalidateCache() {
        this.invalidateControllerRoomInfo();
        this.invalidateCreepInfo();
        this.serialize();
    }
}
// ---------------------------------------------------------------------
class Intel {
    constructor() {
        this.rooms = {};
        this.hostileCreepLocations = {};
        for (let roomName in Memory.rooms) {
            try {
                let roomIntel = new RoomIntel(roomName, this);
                this.rooms[roomName] = roomIntel;
            }
            catch (e) {
                console.log('<font color="#ff5555" type="highlight">'
                    + roomName + '<br/>' + e.stack
                    + '</font>');
            }
        }
        this.invalidateCreepCache();
    }
    isScouted(roomName) {
        return roomName in this.rooms;
    }
    forceUpdateStructures(roomName) {
        this.rooms[roomName].lastStructureUpdate = -9999;
    }
    updateCreepRoom(creepId, roomName) {
        const currentCreepRoom = this.hostileCreepLocations[creepId];
        if (currentCreepRoom !== roomName) {
            if (currentCreepRoom) {
                _.remove(this.rooms[currentCreepRoom].hostiles, c => c.id === creepId);
            }
            this.hostileCreepLocations[creepId] = roomName;
        }
    }
    invalidateCreepCache() {
        this.hostileCreepLocations = {};
        for (let roomName in this.rooms) {
            const intel = this.rooms[roomName];
            for (let creep of intel.hostiles) {
                this.hostileCreepLocations[creep.id] = roomName;
            }
        }
    }
    markAsPointOfInterest(roomName) {
        this.rooms[roomName].pointOfInterestExpiration = Game.time + 1500;
    }
    getLastKnownCreepLocation(creepId) {
        return this.hostileCreepLocations[creepId];
    }
    getHostileCreepIntel(creepId) {
        const creepRoom = this.hostileCreepLocations[creepId];
        if (creepRoom)
            return undefined;
        const creepInfo = this.rooms[creepRoom].hostiles.find(h => h.id === creepId);
        return creepInfo;
    }
    run() {
        const startCpu = Game.cpu.getUsed();
        for (let roomName in Game.rooms) {
            if (!this.rooms[roomName]) {
                this.rooms[roomName] = new RoomIntel(roomName, this);
            }
            this.rooms[roomName].update();
        }
        if (Game.time % 10 === 0)
            for (let roomName in this.rooms)
                this.rooms[roomName].invalidateCache();
        if (Game.time % 100 === 0)
            this.invalidateCreepCache();
        const tickCpu = Game.cpu.getUsed() - startCpu;
        const rollingPeriod = 1000;
        Memory.intelRunCpu = ((Memory.intelRunCpu || 0) * (rollingPeriod - 1) + tickCpu) / rollingPeriod;
    }
}
__decorate([
    profile()
], Intel.prototype, "run", null);

class TickSkipper {
    static update() {
        this.skipTick = Game.cpu.bucket < 500;
        this.skipRooms = false; //Game.cpu.bucket < 1000;
        this.skipRemotes = Game.cpu.bucket < 1800;
        this.skipRemoteSpawning = Game.cpu.bucket < 2000;
        this.slowMarket = Game.cpu.bucket < 3000;
        if (this.skipTick)
            console.log(Game.time, `low cpu bucket ${Game.cpu.bucket}, skipping ticks`);
        else if (this.skipRooms)
            console.log(Game.time, `low cpu bucket ${Game.cpu.bucket}, skipping rooms`);
        else if (this.skipRemotes)
            console.log(Game.time, `low cpu bucket ${Game.cpu.bucket}, skipping remotes`);
    }
}
TickSkipper.slowMarket = false;
TickSkipper.skipRemoteSpawning = false;
TickSkipper.skipRemotes = false;
TickSkipper.skipRooms = false;
TickSkipper.skipTick = false;

class OperationMine extends BaseRoomOperation {
    static create(sourcePos) {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            pos: sourcePos.serialize(),
            mode: 1 /* MineMode.CPU */,
            isOff: true
        };
        return memory;
    }
    //
    get dropSpot() {
        return this.parentRoom.getCollectionPoint();
    }
    get miningRoom() {
        return Game.rooms[this.sourcePos.roomName];
    }
    // ----------------------------------------------------
    constructor(parentRoom, id) {
        super(parentRoom);
        this.id = id;
        let minePlan = this.roomPlan.mines[this.memory.pos];
        this.sourcePos = RoomPosition.deserialize(this.memory.pos);
        this.minerSpot = minePlan.container[0];
        this.pathLength = minePlan.road.length;
        this.isSourceKeeperRoom = Common.isSkRoom(this.sourcePos.roomName);
        this.isPortalRoom = Common.isPortalRoom(this.sourcePos.roomName);
        this.isRemote = (this.sourcePos.roomName !== this.parentRoom.roomName);
        // TODO -it's here and in initForTick
        let path = minePlan.road;
        if (!this.isRemote && this.link)
            this.distanceToTravel = 0;
        else if (this.distanceToTravel === path.length && this.link)
            this.distanceToTravel = _.sum(path, tile => tile.roomName !== this.room.name ? 1 : 0);
        else
            this.distanceToTravel = this.pathLength;
        this.updateCreepComposition();
    }
    get memory() {
        return this.parentRoom.memory.mines[this.id];
    }
    onInitForTick() {
        //
        this._isWorking = undefined;
        this._container = undefined;
        this._link = undefined;
        this._source = undefined;
        this._lair = undefined;
        this._shouldFleeFromRoom = undefined;
        //
        if (Game.time % 1000 === 0) {
            let minePlan = this.roomPlan.mines[this.memory.pos];
            let path = minePlan.road;
            if (!this.isRemote && this.link && this.parentRoom.layout.coreLink)
                this.distanceToTravel = 0;
            else if (this.distanceToTravel === path.length && this.link && this.parentRoom.layout.coreLink)
                this.distanceToTravel = _.sum(path, tile => tile.roomName !== this.room.name ? 1 : 0);
            else
                this.distanceToTravel = this.pathLength;
        }
        //
        let roadStatus = this.roomLayout.moduleStatus[this.id];
        let offroad = (!roadStatus || roadStatus.offroad);
        if (!this.creepComposition
            || this.creepComposition.mode !== this.memory.mode
            || this.creepComposition.energyCapacityAvailable !== this.spawnRoom.energyCapacityAvailable
            || this.creepComposition.hasLink !== !!this.link
            || this.creepComposition.offroad !== offroad
            || this.creepComposition.sourceCapacity !== this.sourceCapacity) {
            this.updateCreepComposition();
        }
        //
        if (this.source)
            for (let creep of this.creeps)
                if (creep.memory.role === 0 /* CreepRole.Miner */ && creep.pos.isNearTo(this.sourcePos))
                    Pather.addObstacle(creep.pos);
    }
    activate(mode, index) {
        this.memory.mode = mode;
        if (this.creepComposition.mode !== this.memory.mode)
            this.updateCreepComposition();
        this.sourceRoomIndex = index;
        this.memory.isOff = false;
    }
    deactivate() {
        this.memory.isOff = true;
    }
    get shouldFleeFromRoom() {
        if (this._shouldFleeFromRoom === undefined) {
            const invasion = GIntel.rooms[this.sourcePos.roomName].invasion;
            this._shouldFleeFromRoom = this.isRemote
                && invasion
                && (invasion.rangedAttack || invasion.meleeAttack)
                && this.creeps.length > 0
                && (!this.miningRoom || this.miningRoom.findHostileCreeps().some(h => {
                    if (h.owner.username === 'Source Keeper')
                        return false;
                    if (h.pos.inRangeTo(this.minerSpot, 10))
                        return true;
                    if (this.creeps.some(c => c.pos.inInterroomRangeTo(h.pos, 10)))
                        return true;
                    return false;
                }));
        }
        return this._shouldFleeFromRoom;
    }
    get source() {
        if (this._source !== undefined)
            return this._source;
        //
        if (this._sourceId)
            this._source = Game.getObjectById(this._sourceId);
        if (this._source)
            return this._source;
        //
        if (this.miningRoom)
            this._source = this.sourcePos.lookFor(LOOK_SOURCES)[0];
        if (this._source)
            this._sourceId = this._source.id;
        else
            this._source = null;
        //
        return this._source;
    }
    get container() {
        if (this._container !== undefined)
            return this._container;
        //
        if (this._containerId)
            this._container = Game.getObjectById(this._containerId);
        if (this._container)
            return this._container;
        //
        let minePlan = this.roomPlan.mines[this.memory.pos];
        if (minePlan.container && minePlan.container[0] && Game.rooms[minePlan.container[0].roomName])
            this._container = minePlan.container[0].lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_CONTAINER);
        if (this._container)
            this._containerId = this._container.id;
        else
            this._container = null;
        //
        return this._container;
    }
    get link() {
        if (this._link !== undefined)
            return this._link;
        //
        if (this._linkId)
            this._link = Game.getObjectById(this._linkId);
        if (this._link)
            return this._link;
        //
        let minePlan = this.roomPlan.mines[this.memory.pos];
        if (minePlan.link && minePlan.link[0] && Game.rooms[minePlan.link[0].roomName])
            this._link = minePlan.link[0].lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_LINK);
        if (this._link)
            this._linkId = this._link.id;
        else
            this._link = null;
        //
        return this._link;
    }
    get lair() {
        if (this._lair !== undefined)
            return this._lair;
        //
        if (this._lairId)
            this._lair = Game.getObjectById(this._lairId);
        if (this._lair)
            return this._lair;
        //
        if (this.miningRoom)
            this._lair = this.minerSpot.findClosestByRange(FIND_HOSTILE_STRUCTURES, { filter: s => s.structureType === STRUCTURE_KEEPER_LAIR });
        if (this._lair)
            this._lairId = this._lair.id;
        else
            this._lair = null;
        //
        return this._lair;
    }
    isWorking() {
        if (this._isWorking === undefined) {
            let minersCount = _.sum(this.creeps, creep => creep.memory.role === 0 /* CreepRole.Miner */ ? 1 : 0);
            const hasMiners = (minersCount > 0);
            const hasHaulers = (this.creeps && this.creeps.length > minersCount);
            const roomIntel = GIntel.rooms[this.roomName];
            const canHarvest = !roomIntel.reservation || roomIntel.reservation.isMy;
            this._isWorking = canHarvest && hasMiners && (hasHaulers || !this.isRemote && this.link && this.parentRoom.isEnergyDistributionWorking());
        }
        return this._isWorking;
    }
    get sourceCapacity() {
        // SK room
        if (this.isSourceKeeperRoom || this.isPortalRoom)
            return SOURCE_ENERGY_KEEPER_CAPACITY + 650; // adding source keeper tombstones here
        // my room
        else if (this.miningRoom && this.miningRoom.controller && this.miningRoom.controller.my) {
            let info = POWER_INFO[PWR_REGEN_SOURCE];
            let operatorRegenSourceEffect = this.parentRoom.operator
                && this.parentRoom.operator.creep
                && this.parentRoom.operator.creep.powers[PWR_REGEN_SOURCE]
                && info.effect[this.parentRoom.operator.creep.powers[PWR_REGEN_SOURCE].level - 1]
                || 0;
            return SOURCE_ENERGY_CAPACITY + operatorRegenSourceEffect * info.duration / info.period;
        }
        // can reserve
        else if (this.room.energyCapacityAvailable >= BODYPART_COST[CLAIM] + BODYPART_COST[MOVE])
            return SOURCE_ENERGY_CAPACITY;
        // neutral room
        else
            return SOURCE_ENERGY_NEUTRAL_CAPACITY;
    }
    getMinimumScale() {
        return 1;
    }
    getMaximumScale() {
        return 1;
    }
    updateEstimatedStats() {
        const creepComposition = this.creepComposition;
        const energyDecayMultiplier = (this.container ? 1 : 0.9);
        const minerWorkParts = creepComposition.minerParts.work * creepComposition.minerCount;
        const haulerCarryParts = creepComposition.haulerParts.carry * creepComposition.haulerCount;
        const minerCost = creepComposition.minerParts.cost * creepComposition.minerCount;
        const haulerCost = creepComposition.haulerParts.cost * creepComposition.haulerCount;
        const minerSpawnTime = creepComposition.minerParts.spawnTime * creepComposition.minerCount;
        const haulerSpawnTime = creepComposition.haulerParts.spawnTime * creepComposition.haulerCount;
        let incomePerTick = Math.min(minerWorkParts * HARVEST_POWER, creepComposition.sourceCapacity / ENERGY_REGEN_TIME);
        let energyToCarry = incomePerTick * 2 * this.distanceToTravel;
        let haulerCarryPartsNeeded = Math.ceil(energyToCarry / CARRY_CAPACITY) + 1;
        let minerUptime = minerWorkParts ? Math.min(1.0, incomePerTick / (HARVEST_POWER * minerWorkParts)) : 0;
        let haulerUptime = haulerCarryParts ? haulerCarryPartsNeeded / haulerCarryParts : 0;
        this.estimatedStats.energyPerTick = energyDecayMultiplier * incomePerTick - (minerCost + haulerCost) / CREEP_LIFE_TIME;
        this.estimatedStats.spawnTime = (minerSpawnTime + haulerSpawnTime) * CREEP_LIFE_TIME / CREEP_LIFE_TIME;
        this.estimatedStats.baseCpu = creepComposition.minerCount * minerUptime * 0.2 + creepComposition.haulerCount * haulerUptime * 0.2;
    }
    getGeneratedValue() {
        let estimatedStats = this.getEstimatedStats();
        return estimatedStats.energyPerTick * (this.empire.resourceValue[RESOURCE_ENERGY] || 0);
    }
    updateCreepComposition() {
        const roadStatus = this.roomLayout.moduleStatus[this.id];
        const offroad = (!roadStatus || roadStatus.offroad);
        const isLinkMining = (this.link && this.link.pos.isNearTo(this.minerSpot) && this.roomLayout.coreLink);
        // we're building containers in remotes at RCL4 and in room at RCL2
        const isContainerMining = !isLinkMining && (this.spawnRoom.energyCapacityAvailable >= 1300 || !this.isRemote && this.spawnRoom.energyCapacityAvailable >= 550);
        // miner
        const addCarryToMiner = (isLinkMining ? 8 : isContainerMining ? 1 : 0);
        const maxMinerWorkCount = Math.floor((this.room.energyCapacityAvailable - addCarryToMiner * BODYPART_COST[CARRY]) / (BODYPART_COST[WORK] + BODYPART_COST[MOVE] * 0.5));
        const minerWorkCountNeeded = (this.memory.mode === 1 /* MineMode.CPU */
            ? Math.min(maxMinerWorkCount, 12)
            : this.memory.mode === 2 /* MineMode.HIGH_CPU */
                ? Math.min(maxMinerWorkCount, 25)
                : isContainerMining
                    ? Math.ceil(this.sourceCapacity / 300 / HARVEST_POWER * 1.2)
                    : Math.ceil(this.sourceCapacity / 300 / HARVEST_POWER));
        let terrain = Game.map.getRoomTerrain(this.sourcePos.roomName);
        let miningSlotsCount = _.sum(Common.offset, o => (terrain.get(this.sourcePos.x + o.x, this.sourcePos.y + o.y) & TERRAIN_MASK_WALL) === 0 ? 1 : 0);
        let minerCount = maxMinerWorkCount > 0 ? Math.min(miningSlotsCount, Math.ceil(minerWorkCountNeeded / maxMinerWorkCount)) : 0;
        let minerWorkCount = minerCount > 0 ? Math.min(maxMinerWorkCount, Math.ceil(minerWorkCountNeeded / minerCount)) : 0;
        let minerParts = new CreepBody(`${minerWorkCount}W${addCarryToMiner ? addCarryToMiner + 'C' : ''}${Math.ceil(minerWorkCount * 0.5)}M`);
        // hauler
        const useFatHaulers = this.memory.mode !== 0 /* MineMode.SPAWN_TIME */;
        const carryMultiplier = (offroad ? 1 : 2) * (useFatHaulers ? 2 : 1);
        const haulerMovementSpeedModifier = useFatHaulers ? 0.66 : 1;
        let maxHaulerScale = Math.floor(this.room.energyCapacityAvailable / (carryMultiplier * BODYPART_COST[CARRY] + BODYPART_COST[MOVE]));
        maxHaulerScale = useFatHaulers
            ? Math.min(maxHaulerScale, offroad ? 16 : 10)
            : Math.min(maxHaulerScale, offroad ? 25 : 16);
        let maxCarryCount = carryMultiplier * maxHaulerScale;
        let incomePerTick = Math.min(minerCount * minerWorkCount * HARVEST_POWER, this.sourceCapacity / ENERGY_REGEN_TIME);
        let energyToCarry = incomePerTick * 2 * this.distanceToTravel / haulerMovementSpeedModifier;
        let haulerCarryPartsNeeded = Math.ceil(energyToCarry / CARRY_CAPACITY) + 1;
        let haulerCount = isLinkMining || maxHaulerScale === 0 ? 0 : Math.ceil(haulerCarryPartsNeeded / maxCarryCount);
        let haulerScale = haulerCount > 0 ? Math.ceil(haulerCarryPartsNeeded / carryMultiplier / haulerCount) : 0;
        //if (this.memory.mode !== MineMode.SPAWN_TIME)
        //  haulerScale = Math.min(maxHaulerScale, 2 * haulerScale);
        let haulerParts = useFatHaulers
            ? new CreepBody(offroad ? `${haulerScale}[CCM]` : `${haulerScale}[CCCCM]`)
            : new CreepBody(offroad ? `${haulerScale}[CM]` : `${haulerScale}[CCM]`);
        this.creepComposition = {
            mode: this.memory.mode,
            minerCount: minerCount,
            minerParts: minerParts,
            haulerCount: haulerCount,
            haulerParts: haulerParts,
            energyCapacityAvailable: this.room.energyCapacityAvailable,
            hasLink: !!this.link,
            offroad: offroad,
            sourceCapacity: this.sourceCapacity
        };
        this.shouldUpdateEstimatedStats = true;
    }
    getSpawnRequestsInternal() {
        if (this.memory.isOff)
            return [];
        if (TickSkipper.skipRemoteSpawning && this.isRemote)
            return [];
        // if main room is being attacked
        if (this.room.memory.lastSafe !== this.room.memory.lastScout)
            return [];
        // if remote or room between remote and main is being attacked
        let roadStatus = this.roomLayout.moduleStatus[this.id];
        let pathRooms = roadStatus && roadStatus.pathRooms || [];
        if (this.isRemote && pathRooms.some(roomName => GIntel.rooms[roomName] && !GIntel.rooms[roomName].isSafe))
            return [];
        //
        let minersNeeded = this.creepComposition.minerCount;
        let haulersNeeded = this.creepComposition.haulerCount;
        for (let creep of this.creeps) {
            if (creep.memory.role === 0 /* CreepRole.Miner */ && (!creep.ticksToLive || creep.ticksToLive > this.pathLength))
                --minersNeeded;
            else if (creep.memory.role === 1 /* CreepRole.Hauler */)
                --haulersNeeded;
        }
        if (minersNeeded <= 0 && haulersNeeded <= 0)
            return [];
        let spawnPriority = Priority(this.sourceRoomIndex, 17 /* SpawnPriority.MINE */ + 1 - this.distanceToTravel / 1000);
        let result = [];
        while (minersNeeded > 0 || haulersNeeded > 0) {
            if (haulersNeeded / this.creepComposition.haulerCount > minersNeeded / this.creepComposition.minerCount) {
                result.push({
                    id: generateRandomKey(5),
                    nameBase: Config.CreepNames.Hauler,
                    priority: spawnPriority,
                    minEnergy: 150,
                    parts: this.creepComposition.haulerParts,
                    memory: {
                        role: 1 /* CreepRole.Hauler */,
                        state: 0
                    },
                    boostOptions: [null],
                    noRepurpose: false,
                    operation: this
                });
                --haulersNeeded;
            }
            else {
                result.push({
                    id: generateRandomKey(5),
                    nameBase: Config.CreepNames.Miner,
                    priority: spawnPriority,
                    minEnergy: 250,
                    parts: this.creepComposition.minerParts,
                    memory: {
                        role: 0 /* CreepRole.Miner */
                    },
                    boostOptions: [null],
                    noRepurpose: false,
                    operation: this
                });
                --minersNeeded;
            }
        }
        return result;
    }
    storeResources(creep, opts) {
        if (this.link && this.roomLayout.coreLink) {
            if (creep.room.name !== this.room.name || !creep.pos.inRangeTo(this.link, 1)) {
                creep.goTo(this.link.pos, 1, opts);
            }
            else if (this.link.energy < this.link.energyCapacity) {
                creep.transfer(this.link, RESOURCE_ENERGY);
            }
            else {
                creep.giveWay({ pos: this.link.pos, range: 1 });
            }
        }
        else if (creep.room.name !== this.room.name)
            creep.goTo(this.dropSpot, 1, opts);
        else {
            const spawnAndExtFilter = (s) => { return (s.structureType === STRUCTURE_SPAWN || s.structureType === STRUCTURE_EXTENSION) && s.energy < s.energyCapacity; };
            let spawnsAndExtensions = null;
            const resourceType = _.findKey(creep.carry);
            if (resourceType !== RESOURCE_ENERGY
                || this.parentRoom.isEnergyDistributionWorking()
                || (spawnsAndExtensions = this.room.find(FIND_MY_STRUCTURES).filter(spawnAndExtFilter)).length === 0) {
                if (creep.carryCapacity === 0 && creep.pos.inRangeTo(this.dropSpot, 1))
                    creep.suicide();
                else if (creep.pos.inRangeTo(this.dropSpot, 1)) {
                    const storeStructure = this.dropSpot.lookFor(LOOK_STRUCTURES).find(s => s.hasStore() && s.store.getFreeCapacity() > 0);
                    if (storeStructure) {
                        creep.transfer(storeStructure, resourceType);
                        this.parentRoom.updateTerminalDistributionRequests();
                    }
                    else {
                        let storageContainer = this.dropSpot.lookInRange(LOOK_STRUCTURES, 1).find(s => s.structureType === STRUCTURE_CONTAINER);
                        if (storageContainer && storageContainer.store.getFreeCapacity() > 0)
                            creep.transfer(storageContainer, resourceType);
                        else if (creep.pos.isEqualTo(this.dropSpot))
                            creep.drop(resourceType);
                        else
                            creep.goTo(this.dropSpot, 0);
                    }
                }
                else
                    creep.goTo(this.dropSpot, 1, opts);
            }
            else {
                let closest = creep.pos.findClosestByRange(spawnsAndExtensions);
                if (closest && creep.pos.isNearTo(closest))
                    creep.transfer(closest, RESOURCE_ENERGY);
                else if (closest)
                    creep.goTo(closest.pos, 1, opts);
                else if (creep.pos.roomName !== this.roomName)
                    creep.goToRoom(this.roomName, opts);
                else
                    creep.smokeBreak();
            }
        }
    }
    fleeFromSourceKeepers(creep) {
        if (creep.room !== this.miningRoom)
            return false;
        let lair = this.lair;
        let hostileInRange = creep.room.findHostileCreeps().find(hostile => {
            if (hostile.getActiveBodyparts(ATTACK) === 0 && hostile.getActiveBodyparts(RANGED_ATTACK) === 0)
                return false;
            if (!creep.pos.inRangeTo(hostile, 5))
                return false;
            return true;
        });
        let fleeFrom = [];
        if (hostileInRange)
            fleeFrom.push({ pos: hostileInRange.pos, range: 5 });
        if (lair && lair.ticksToSpawn && lair.ticksToSpawn < 10)
            fleeFrom.push({ pos: lair.pos, range: 5 });
        if (fleeFrom.some(t => creep.pos.inRangeTo(t, 4))) {
            creep.flee(fleeFrom);
            return true;
        }
        if (fleeFrom.some(t => creep.pos.inRangeTo(t, 5))) {
            creep.giveWay();
            return true;
        }
        return false;
    }
    minerFunc(creep) {
        if (this.shouldFleeFromRoom) {
            let resourceToDrop = _.findKey(creep.carry);
            if (resourceToDrop)
                creep.drop(resourceToDrop);
            creep.fleeFromRoom(this.sourcePos.roomName);
            return;
        }
        if (this.isSourceKeeperRoom && this.fleeFromSourceKeepers(creep))
            return;
        let source = this.source;
        let isNearSource = source && creep.pos.isNearTo(this.sourcePos);
        if (isNearSource) {
            let link = this.link;
            if (link && this.roomLayout.coreLink && creep.pos.isNearTo(link.pos) && creep.carryCapacity > 0) {
                let creepNotFull = (creep.carry.energy < creep.carryCapacity);
                let energyOnSpot = creep.pos.lookFor(LOOK_RESOURCES).find(r => r.resourceType === RESOURCE_ENERGY);
                if (creepNotFull && energyOnSpot)
                    creep.pickup(energyOnSpot);
                else if (creepNotFull && source.energy > 0)
                    creep.harvest(source);
                else if (creep.carry.energy)
                    creep.transfer(link, RESOURCE_ENERGY);
            }
            else {
                let container = this.container;
                if (container && container.hits < container.hitsMax && creep.carry.energy)
                    creep.repair(container);
                else if (source.energy > 0)
                    creep.harvest(source);
            }
        }
        if (!this.isMinerOnSpot)
            creep.goTo(this.minerSpot, 0);
        else if (!isNearSource)
            creep.goTo(this.sourcePos, 1);
    }
    haulerFunc(creep) {
        let creepCarry = creep.store.getUsedCapacity();
        const creepMemory = creep.memory;
        const isFat = this.creepComposition.haulerParts[CARRY] / this.creepComposition.haulerParts[MOVE] >= (this.creepComposition.offroad ? 2 : 4);
        if (creepMemory.state === 0 /* HaulerState.Collecting */ && (creepCarry === creep.carryCapacity || creepCarry > 0 && !this.isMinerOnSpot)) {
            creepMemory.state = 1 /* HaulerState.Returning */;
        }
        else if (creepMemory.state === 1 /* HaulerState.Returning */ && creep.carryCapacity > 0 && creepCarry === 0) {
            creepMemory.state = 0 /* HaulerState.Collecting */;
            if (creep.ticksToLive && creep.ticksToLive < 2 * this.distanceToTravel * (isFat ? 1.5 : 1)) {
                this.dismissCreep(creep, true, false);
                return;
            }
        }
        if (this.isSourceKeeperRoom && this.fleeFromSourceKeepers(creep))
            return;
        if (creepMemory.state === 0 /* HaulerState.Collecting */) {
            if (this.shouldFleeFromRoom) {
                creep.fleeFromRoom(this.sourcePos.roomName);
                return;
            }
            if (creep.room !== this.miningRoom) // || !creep.pos.inRangeTo(this.minerSpot, 5))
             {
                creep.goTo(this.minerSpot, 1, OperationMine.haulerOpts);
            }
            else {
                let container = this.container;
                let resourcePiles = this.sourcePos.lookInRange(LOOK_RESOURCES, 1);
                let biggestPile = resourcePiles.length > 0 ? _.max(resourcePiles, r => r.amount / r.pos.getRangeTo(creep.pos)) : undefined;
                let creepCapacity = creep.carryCapacity - creepCarry;
                let isNearMinerSpot = creep.pos.isNearTo(this.minerSpot);
                let containerStore = container ? container.store.getUsedCapacity() : 0;
                // TODO - pickup from ground and container in the same tick unless there is more on the ground on another spot
                if (biggestPile && creep.pos.isNearTo(biggestPile)) {
                    creep.pickup(biggestPile);
                    creepCapacity -= biggestPile.amount;
                    creep.giveWay(true);
                }
                else if (biggestPile) {
                    creep.goTo(biggestPile.pos, 1, OperationMine.haulerOpts);
                    return;
                }
                const arePotentialEnergyThievesHere = !!GIntel.rooms[this.roomName].invasion;
                if (container && isNearMinerSpot && (containerStore >= creepCapacity || !this.isMinerOnSpot && containerStore > 0 || arePotentialEnergyThievesHere || creep.ticksToLive <= this.distanceToTravel * (isFat ? 2 : 1))) {
                    const resourceType = _.findKey(container.store);
                    const resourceInStore = container.store[resourceType];
                    let amount = Math.min(resourceInStore, creepCapacity);
                    creep.withdraw(container, resourceType, amount);
                    creepCapacity -= amount;
                    creep.giveWay(true);
                }
                else if (!isNearMinerSpot) // && this.isMinerOnSpot)
                    creep.goTo(this.minerSpot, 1, OperationMine.haulerOpts);
                else
                    creep.giveWay(true);
            }
        }
        else {
            this.storeResources(creep, OperationMine.haulerOpts);
        }
    }
    onRun() {
        if (TickSkipper.skipRemotes && this.isRemote) {
            for (let creep of this.creeps)
                creep.giveWay();
            return;
        }
        if (this.creeps.length > 0) {
            this.isMinerOnSpot = !!(this.miningRoom && this.minerSpot.lookFor(LOOK_CREEPS).find(c => c.my && c.memory.role === 0 /* CreepRole.Miner */));
            for (let creep of this.creeps) {
                if (creep.spawning)
                    continue;
                else if (creep.memory.role === 0 /* CreepRole.Miner */)
                    this.minerFunc(creep);
                else if (creep.memory.role === 1 /* CreepRole.Hauler */)
                    this.haulerFunc(creep);
                else
                    // TODO - some better reporting
                    creep.say('INVALID');
            }
        }
        // remove container if there is a link
        if (_.random(0, 100) === 0 && this.link && this.container)
            this.container.destroy();
    }
}
// ----------------------------------------------------
OperationMine.haulerOpts = {
//avoidSourceKeepers: false
};
__decorate([
    Profiler.profile()
], OperationMine.prototype, "onInitForTick", null);
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationMine.prototype, "getSpawnRequestsInternal", null);
__decorate([
    profile()
], OperationMine.prototype, "storeResources", null);
__decorate([
    profile()
], OperationMine.prototype, "minerFunc", null);
__decorate([
    profile()
], OperationMine.prototype, "haulerFunc", null);
__decorate([
    check,
    profile()
], OperationMine.prototype, "onRun", null);

const AVG_MINERAL_AMOUNT = (() => {
    let result = 0;
    let prevProbability = 0;
    for (let i = 1; i <= 4; ++i) {
        result += MINERAL_DENSITY[i] * (MINERAL_DENSITY_PROBABILITY[i] - prevProbability);
        prevProbability = MINERAL_DENSITY_PROBABILITY[i];
    }
    return result;
})();
class OperationExtraction extends BaseRoomOperation {
    static create(extractionPos) {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            pos: extractionPos.serialize()
        };
        return memory;
    }
    constructor(parentRoom, id) {
        super(parentRoom);
        this.id = id;
        this.mineralPos = RoomPosition.deserialize(this.memory.pos);
        this.plan = this.mineralPos.roomName === this.roomName ? this.roomPlan.extraction : this.roomPlan.mines[this.memory.pos];
        this.minerSpot = this.plan.container[0];
        this.haulerSpot = _.last(this.plan[STRUCTURE_ROAD]);
        this.pathLength = this.plan[STRUCTURE_ROAD].length;
        this.isCenterRoom = Common.isCenterRoom(this.mineralPos.roomName);
        //
        this.isMinerOnSpot = false;
        // TODO - when structure is built miningSlots won't update until global reset
        let terrain = Game.map.getRoomTerrain(this.miningRoomName);
        this.miningSlots = _(Common.offset)
            .filter((o) => {
            let posX = this.mineralPos.x + o.x;
            let posY = this.mineralPos.y + o.y;
            if (terrain.get(posX, posY) & TERRAIN_MASK_WALL)
                return false;
            if (!this.minerSpot.isNearTo(posX, posY))
                return false;
            if (this.miningRoom && this.miningRoom.lookForAt(LOOK_STRUCTURES, posX, posY).find(s => s.isObstacle()))
                return false;
            if (this.roomPlan.mines[(new RoomPosition(posX, posY, this.mineralPos.roomName)).serialize()])
                return false;
            return true;
        })
            .map(o => new RoomPosition(this.mineralPos.x + o.x, this.mineralPos.y + o.y, this.mineralPos.roomName))
            .value();
        //
        this.creepComposition = {
            energyCapacityAvailable: 0,
            haulerCount: 0,
            haulerBody: undefined,
            minerCount: 0,
            minerBody: undefined,
            offroad: false
        };
        this.updateCreepComposition();
    }
    get memory() {
        return this.parentRoom.memory.extractions[this.id];
    }
    get dropSpot() {
        return this.parentRoom.getCollectionPoint();
    }
    onInitForTick() {
        this._mineral = undefined;
        for (let creep of this.creeps)
            if (creep.memory.role === 0 /* CreepRole.Miner */ && creep.pos.isNearTo(this.mineralPos))
                Pather.addObstacle(creep.pos);
    }
    get miningRoom() {
        return Game.rooms[this.minerSpot.roomName];
    }
    get miningRoomName() {
        return this.minerSpot.roomName;
    }
    get mineral() {
        if (this._mineral !== undefined)
            return this._mineral;
        if (this._mineralId) {
            this._mineral = Game.getObjectById(this._mineralId);
            return this._mineral;
        }
        if (this.miningRoom) {
            let mineralsInRange = this.mineralPos.lookFor(LOOK_MINERALS);
            if (mineralsInRange.length > 0) {
                this._mineral = mineralsInRange[0];
                this._mineralId = this._mineral.id;
                return this._mineral;
            }
        }
        this._mineral = null;
        return this._mineral;
    }
    get mineralType() {
        if (this.mineral)
            return this.mineral.mineralType;
        else
            return GIntel.rooms[this.roomName].mineralType;
    }
    getMinimumScale() {
        return this.getMaximumScale();
    }
    getMaximumScale() {
        if (this.parentRoom.isLowEnergy())
            return 0;
        if (this.parentRoom.abandon)
            return 0;
        else if (this.parentRoom.getStoredResource(this.mineralType) > 2 * Config.TARGET_STOCK[this.mineralType].storage + Config.TARGET_STOCK[this.mineralType].terminal)
            return 0;
        else if (this.isCenterRoom && this.room.energyCapacityAvailable >= ROOM_ENERGY_CAPACITY[7])
            return 1;
        else if (!this.isCenterRoom && this.mineral && this.mineral.mineralAmount > 0 && this.room.energyCapacityAvailable >= ROOM_ENERGY_CAPACITY[6])
            return 1;
        else
            return 0;
    }
    updateEstimatedStats() {
        if (!this.isCenterRoom && this.room.energyCapacityAvailable < ROOM_ENERGY_CAPACITY[6]
            || this.isCenterRoom && this.room.energyCapacityAvailable < ROOM_ENERGY_CAPACITY[7]) {
            this.estimatedStats.energyPerTick = 0;
            this.estimatedStats.spawnTime = 0;
            this.estimatedStats.baseCpu = 0;
        }
        else {
            let creepComposition = this.creepComposition;
            const mineralMiningTime = AVG_MINERAL_AMOUNT / (creepComposition.minerCount * creepComposition.minerBody[WORK] * HARVEST_MINERAL_POWER / EXTRACTOR_COOLDOWN);
            const uptime = mineralMiningTime / (mineralMiningTime + MINERAL_REGEN_TIME);
            const minerCost = creepComposition.minerBody.cost * creepComposition.minerCount;
            const haulerCost = creepComposition.haulerBody.cost * creepComposition.haulerCount;
            const minerSpawnTime = creepComposition.minerBody.spawnTime * creepComposition.minerCount;
            const haulerSpawnTime = creepComposition.haulerBody.spawnTime * creepComposition.haulerCount;
            const harvestFrequency = 1 / EXTRACTOR_COOLDOWN;
            const transferFrequency = (creepComposition.minerBody[CARRY] * CARRY_CAPACITY) / (creepComposition.minerBody[WORK] * HARVEST_MINERAL_POWER / EXTRACTOR_COOLDOWN);
            this.estimatedStats.energyPerTick = -(minerCost + haulerCost) / CREEP_LIFE_TIME * uptime;
            this.estimatedStats.spawnTime = minerSpawnTime + haulerSpawnTime;
            this.estimatedStats.baseCpu = (creepComposition.minerCount * (0.2 * harvestFrequency + 0.2 * transferFrequency) + creepComposition.haulerCount * 0.2) * uptime;
        }
    }
    getGeneratedValue() {
        let estimatedStats = this.getEstimatedStats();
        let mineralMiningTime = AVG_MINERAL_AMOUNT / (this.creepComposition.minerCount * this.creepComposition.minerBody[WORK] * HARVEST_MINERAL_POWER / EXTRACTOR_COOLDOWN);
        let generatedMineral = AVG_MINERAL_AMOUNT / (mineralMiningTime + MINERAL_REGEN_TIME);
        return generatedMineral * (this.empire.resourceValue[this.mineralType] || 0) + estimatedStats.energyPerTick * (this.empire.resourceValue[RESOURCE_ENERGY] || 0);
    }
    isWorking() {
        let minersCount = _.sum(this.creeps, creep => creep.memory.role === 0 /* CreepRole.Miner */ ? 1 : 0);
        return minersCount > 0 && (this.creeps.length > minersCount);
    }
    updateCreepComposition() {
        let roadStatus = this.roomLayout.moduleStatus.extraction;
        if (this.creepComposition.energyCapacityAvailable !== this.room.energyCapacityAvailable
            || this.creepComposition.offroad !== roadStatus.offroad) {
            // miner
            const moveMultiplier = (roadStatus.offroad ? 0.5 : 0.25);
            const maxWorkCount = Math.floor((this.room.energyCapacityAvailable - BODYPART_COST[CARRY]) / (BODYPART_COST[WORK] + BODYPART_COST[MOVE] * moveMultiplier));
            let workCount = Math.clamp(maxWorkCount, 0, moveMultiplier === 0.5 ? 32 : 39);
            let minerParts = new CreepBody(`${workCount}WC${Math.ceil(workCount * moveMultiplier)}M`);
            let minerCount = this.miningSlots.length;
            // hauler
            const carryMultiplier = roadStatus.offroad ? 1 : 2;
            const maxHaulerScale = Math.floor(this.room.energyCapacityAvailable / (carryMultiplier * BODYPART_COST[CARRY] + BODYPART_COST[MOVE]));
            let harvestingSpeed = minerCount * workCount * HARVEST_MINERAL_POWER / EXTRACTOR_COOLDOWN;
            let resourceToCarry = harvestingSpeed * 2 * this.pathLength;
            let carryPartsNeeded = Math.ceil(resourceToCarry / CARRY_CAPACITY);
            let haulerScale = Math.max(1, Math.min(Math.floor(carryPartsNeeded / carryMultiplier), maxHaulerScale, roadStatus.offroad ? 25 : 16));
            let haulerParts = new CreepBody(roadStatus.offroad ? `${haulerScale}[CM]` : `${haulerScale}[CCM]`);
            let haulerCount = 1;
            this.creepComposition = {
                minerBody: minerParts,
                minerCount: minerCount,
                haulerBody: haulerParts,
                haulerCount: haulerCount,
                energyCapacityAvailable: this.room.energyCapacityAvailable,
                offroad: roadStatus.offroad
            };
            this.shouldUpdateEstimatedStats = true;
        }
    }
    getSpawnRequestsInternal() {
        if (!this.miningRoom)
            return [];
        // always spawn hauler to finish collecting minerals
        let containerPlan = this.plan.container[0];
        let container = containerPlan.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_CONTAINER);
        if (!container)
            return [];
        let containerStore = container.store.getUsedCapacity();
        let result = [];
        // hauler
        if (containerStore > 0 && _.sum(this.creeps, creep => creep.memory.role === 1 /* CreepRole.Hauler */ ? 1 : 0) < this.creepComposition.haulerCount) {
            result.push({
                id: generateRandomKey(5),
                nameBase: Config.CreepNames.Hauler,
                priority: Priority(0, 10 /* SpawnPriority.EXTRACTION */),
                minEnergy: 150,
                parts: this.creepComposition.haulerBody,
                memory: {
                    role: 1 /* CreepRole.Hauler */,
                    state: 0
                },
                boostOptions: [null],
                noRepurpose: false,
                operation: this
            });
        }
        if (this.targetScale === 0)
            return result;
        if (!this.mineral)
            return result;
        let hasExtractor = this.roomName !== this.miningRoomName
            ? true
            : !!this.plan.extractor[0].lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_EXTRACTOR);
        // miner
        if (this.mineral && this.mineral.mineralAmount > 0
            && containerStore < container.storeCapacity
            && hasExtractor
            && _.sum(this.creeps, creep => creep.memory.role === 0 /* CreepRole.Miner */ ? 1 : 0) < this.creepComposition.minerCount) {
            result.push({
                id: generateRandomKey(5),
                nameBase: Config.CreepNames.MineralMiner,
                priority: Priority(0, 10 /* SpawnPriority.EXTRACTION */),
                minEnergy: 250,
                parts: this.creepComposition.minerBody,
                memory: {
                    role: 0 /* CreepRole.Miner */,
                    state: 0
                },
                boostOptions: [null],
                noRepurpose: false,
                operation: this
            });
        }
        return result;
    }
    pickupResources(creep) {
        if (creep.pos.isNearTo(this.dropSpot))
            return;
        if (creep.store.getFreeCapacity() === 0)
            return;
        let droppedResources = creep.pos.lookFor(LOOK_RESOURCES);
        if (droppedResources.length > 0)
            creep.pickup(droppedResources[0]);
        let tombstones = creep.pos.lookFor(LOOK_TOMBSTONES);
        if (tombstones.length > 0)
            creep.withdraw(tombstones[0], _.findKey(tombstones[0].store));
    }
    minerFunc(creep) {
        var _a;
        let creepCarry = creep.store.getUsedCapacity();
        if ((!this.mineral || this.mineral.mineralAmount === 0) && creepCarry === 0) {
            this.dismissCreep(creep, true, true);
            return;
        }
        let containerPlan = this.plan.container[0];
        let isNearExtractor = creep.pos.isNearTo(this.mineralPos);
        let isNearContainer = creep.pos.isNearTo(containerPlan);
        if (!this.isMinerOnSpot)
            creep.goTo(this.minerSpot, 0);
        else if (!isNearExtractor || !isNearContainer) {
            let targetSpot = this.miningSlots.find(s => s.lookFor(LOOK_CREEPS).length === 0);
            if (targetSpot)
                creep.goTo(targetSpot, 0);
            else
                creep.smokeBreak();
        }
        else
            creep.giveWay({ pos: this.mineralPos, range: 1 });
        let container = containerPlan.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_CONTAINER);
        if (isNearExtractor && container) {
            if (creep.store.getFreeCapacity() >= creep.getActiveBodyparts(WORK) * HARVEST_MINERAL_POWER)
                creep.harvest(this.mineral);
            else if (creepCarry <= container.store.getFreeCapacity() || !((_a = this.mineral) === null || _a === void 0 ? void 0 : _a.mineralAmount))
                creep.transfer(container, _.findKey(creep.carry));
        }
    }
    haulerFunc(creep) {
        let creepMemory = creep.memory;
        let creepCarry = creep.store.getUsedCapacity();
        let creepFreeCarryCapacity = creep.store.getFreeCapacity();
        if (creepMemory.state === 0 /* HaulerState.Collecting */ && (creepFreeCarryCapacity === 0 || creepCarry > 0 && !this.isMinerOnSpot))
            creepMemory.state = 1 /* HaulerState.Returning */;
        else if (creepMemory.state === 1 /* HaulerState.Returning */ && creepFreeCarryCapacity > 0 && creepCarry === 0) {
            creepMemory.state = 0 /* HaulerState.Collecting */;
            if (creep.ticksToLive && creep.ticksToLive < 2 * this.pathLength)
                this.dismissCreep(creep, true, true);
        }
        if (creepMemory.state === 0 /* HaulerState.Collecting */) {
            let containerPlan = this.plan.container[0];
            let container = this.miningRoom
                ? containerPlan.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_CONTAINER)
                : undefined;
            if ((!this.mineral || this.mineral.mineralAmount === 0) && (!container || container.store.getUsedCapacity() === 0)) {
                this.dismissCreep(creep, true, true);
                return;
            }
            if (!creep.pos.inRangeTo(this.minerSpot, 5)) {
                creep.goTo(this.haulerSpot, 0);
                this.pickupResources(creep);
            }
            else {
                let resourcePiles = this.mineralPos.lookInRange(LOOK_RESOURCES, 1);
                let creepCapacity = creep.store.getFreeCapacity();
                if (resourcePiles.length > 0) {
                    let biggestPile = _.max(resourcePiles, r => r.amount / r.pos.getRangeTo(creep.pos));
                    if (creep.pickup(biggestPile) === ERR_NOT_IN_RANGE)
                        creep.goTo(biggestPile.pos, 1);
                    else
                        creepCapacity -= biggestPile.amount;
                }
                else if (container && creep.pos.isNearTo(container) && (container.store.getUsedCapacity() >= creepCapacity || !this.isMinerOnSpot)) {
                    const resourceType = _.findKey(container.store);
                    const resourceInStore = container.store[resourceType];
                    creep.withdraw(container, resourceType, Math.min(resourceInStore, creepCapacity));
                    creep.giveWay(true);
                }
                else if (!creep.pos.isEqualTo(this.haulerSpot))
                    creep.goTo(this.haulerSpot, 0);
                else
                    creep.giveWay(true);
            }
        }
        else {
            if (creep.room.name !== this.room.name)
                creep.goTo(this.dropSpot, 1);
            else {
                const resourceType = _.findKey(creep.store);
                if (creep.pos.inRangeTo(this.dropSpot, 1)) {
                    const storeStructure = this.dropSpot.lookFor(LOOK_STRUCTURES).find(s => s.hasStore() && s.store.getFreeCapacity() > 0);
                    if (storeStructure) {
                        creep.transfer(storeStructure, resourceType);
                        this.parentRoom.updateTerminalDistributionRequests();
                    }
                    else
                        creep.drop(resourceType);
                }
                else
                    creep.goTo(this.dropSpot, 1);
            }
        }
    }
    onRun() {
        this.updateCreepComposition();
        this.isMinerOnSpot = !!Game.rooms[this.minerSpot.roomName] && !!this.minerSpot.lookFor(LOOK_CREEPS).find(c => c.my && c.memory.role === 0 /* CreepRole.Miner */);
        for (let creep of this.creeps) {
            if (creep.spawning)
                continue;
            if (creep.memory.role === 0 /* CreepRole.Miner */)
                this.minerFunc(creep);
            else if (creep.memory.role === 1 /* CreepRole.Hauler */)
                this.haulerFunc(creep);
            else
                creep.say('INVALID');
        }
    }
}
__decorate([
    Profiler.profile()
], OperationExtraction.prototype, "onInitForTick", null);
__decorate([
    profile()
], OperationExtraction.prototype, "minerFunc", null);
__decorate([
    profile()
], OperationExtraction.prototype, "haulerFunc", null);
__decorate([
    check,
    profile()
], OperationExtraction.prototype, "onRun", null);

// ----------------------------------------------------
class OperationUpgrade extends BaseRoomOperation {
    static create() {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            //
            lastProgress: Infinity,
            finishTimePrediction: Infinity,
            nextCheck: Game.time,
            workingRatio: 1,
            haulingRatio: 1
        };
        return memory;
    }
    constructor(parentRoom) {
        super(parentRoom);
        this.pathLength = this.roomPlan.upgradeSite[STRUCTURE_ROAD].length;
        let terrain = Game.map.getRoomTerrain(this.roomName);
        this.preferredSpots = [];
        for (let x = -1; x <= 1; ++x)
            for (let y = -1; y <= 1; ++y)
                if ((terrain.get(this.pos.x + x, this.pos.y + y) & TERRAIN_MASK_WALL) === 0)
                    this.preferredSpots.push(new RoomPosition(this.pos.x + x, this.pos.y + y, this.roomName));
        // TODO - TEMP
        if (this.memory.workingRatio === undefined)
            this.memory.workingRatio = 1;
        if (this.memory.haulingRatio === undefined)
            this.memory.haulingRatio = 1;
        if (this.memory.nextCheck === undefined)
            this.memory.nextCheck = this.memory.lastCheck + 400;
        //
    }
    get memory() {
        return this.parentRoom.memory.upgrade;
    }
    get container() {
        return this.roomLayout.upgradeSiteContainer;
    }
    get pos() {
        return this.roomPlan.upgradeSite.container[0];
    }
    updateCreepComposition() {
        let roadStatus = this.roomLayout.moduleStatus.upgradeSite;
        let offroad = (!roadStatus || roadStatus.offroad);
        if (!this.creepComposition ||
            this.creepComposition.energyCapacityAvailable !== this.room.energyCapacityAvailable ||
            this.creepComposition.offroad !== offroad) {
            // upgrader
            const RCL = this.room.controller.level;
            const upgraderMovePerWork = offroad ? 0.5 : 0.25;
            const upgraderCarryPerWork = UPGRADE_CONTROLLER_POWER * 3 / CARRY_CAPACITY;
            let maxWork = Math.floor(this.room.energyCapacityAvailable / (BODYPART_COST[WORK] + upgraderCarryPerWork * BODYPART_COST[CARRY] + upgraderMovePerWork * BODYPART_COST[MOVE]));
            const bodypartsPerWork = 1 + upgraderCarryPerWork + upgraderMovePerWork;
            if (RCL === 8)
                maxWork = Math.min(maxWork, 15);
            else
                maxWork = Math.min(maxWork, Math.floor(MAX_CREEP_SIZE / bodypartsPerWork));
            while (maxWork + Math.ceil(maxWork * upgraderCarryPerWork) + Math.ceil(maxWork * upgraderMovePerWork) > MAX_CREEP_SIZE)
                --maxWork;
            let workCount = maxWork;
            const carryCount = Math.ceil(maxWork * upgraderCarryPerWork);
            const moveCount = Math.ceil(maxWork * upgraderMovePerWork);
            if (workCount * BODYPART_COST[WORK] + carryCount * BODYPART_COST[CARRY] + moveCount * BODYPART_COST[MOVE] > this.room.energyCapacityAvailable)
                --workCount;
            // hauler
            const energyToCarry = maxWork * UPGRADE_CONTROLLER_POWER * 2 * Math.max(1, this.pathLength);
            const carryNeeded = Math.ceil(energyToCarry / CARRY_CAPACITY);
            //
            this.creepComposition = {
                energyCapacityAvailable: this.room.energyCapacityAvailable,
                offroad: offroad,
                haulerCarryPerUppgrader: carryNeeded,
                upgraderParts: new CreepBody(`${workCount}W${carryCount}C${moveCount}M`)
            };
            this.shouldUpdateEstimatedStats = true;
        }
    }
    getMinimumScale() {
        return 0.01;
    }
    getMaximumScale() {
        if (this.room.find(FIND_FLAGS).find(f => f.name.startsWith('StopPraise')))
            return 0.01;
        if (this.room.controller.level === 8 && _.some(Game.rooms, room => room.myRoom && room.terminal && room.controller.level >= 6 && room.controller.level < 8))
            return 0.01;
        if (this.room.controller.level === 8)
            return 1;
        let terrain = this.room.getTerrain();
        let spotCount = 0;
        for (let x = this.pos.x - 3; x <= this.pos.x + 3; ++x)
            for (let y = this.pos.y - 3; y <= this.pos.y + 3; ++y) {
                if (((terrain.get(x, y) & TERRAIN_MASK_WALL) > 0 && !this.room.lookForAt(LOOK_STRUCTURES, x, y).find(s => s.structureType === STRUCTURE_ROAD)))
                    continue;
                if (this.room.lookForAt(LOOK_STRUCTURES, x, y).find(s => s.isObstacle()))
                    continue;
                if (this.room.controller.pos.getRangeTo(x, y) > 3)
                    continue;
                ++spotCount;
            }
        if (spotCount === 0) {
            console.log(this.room.name, 'upgrade spot count = 0');
            return 1;
        }
        const lowRCLMultiplier = this.room.controller.level < 4 ? 2 : 1;
        return spotCount * lowRCLMultiplier;
    }
    updateEstimatedStats() {
        const composition = this.creepComposition;
        const haulerMoveMultiplier = (composition.offroad ? 1 : 0.5);
        const creepCosts = composition.upgraderParts.cost + composition.haulerCarryPerUppgrader * (BODYPART_COST[CARRY] + BODYPART_COST[MOVE] * haulerMoveMultiplier);
        const haulerSpawnTime = CREEP_SPAWN_TIME * 3 * composition.haulerCarryPerUppgrader / 2;
        this.estimatedStats.energyPerTick = -(creepCosts / CREEP_LIFE_TIME + composition.upgraderParts.work * UPGRADE_CONTROLLER_POWER);
        this.estimatedStats.spawnTime = haulerSpawnTime + composition.upgraderParts.spawnTime;
        this.estimatedStats.baseCpu = 0.2;
    }
    getSpawnRequestsInternal() {
        // if main room is being attacked
        if (this.room.memory.invasion && !this.room.controller.safeMode)
            return [];
        const roadStatus = this.roomLayout.moduleStatus.upgradeSite;
        const scale = this.targetScale;
        // upgrader
        const upgraderCount = Math.max(1, Math.floor(scale));
        const maxWork = scale >= 1 ? this.creepComposition.upgraderParts.work : 1;
        if (maxWork === 0)
            return [];
        const baseWorkNeeded = upgraderCount * maxWork;
        let workNeeded = baseWorkNeeded;
        // hauler
        const haulerMoveMultiplier = (roadStatus.offroad ? 1 : 0.5);
        const maxCarry = Math.min(Math.floor(50 / (1.0 + haulerMoveMultiplier)), Math.floor(this.room.energyCapacityAvailable / (2 * BODYPART_COST[CARRY] + BODYPART_COST[MOVE])));
        let baseCarryNeeded = this.creepComposition.haulerCarryPerUppgrader * upgraderCount;
        let carryNeeded = baseCarryNeeded;
        if (maxCarry === 0)
            return [];
        for (let creep of this.creeps) {
            if (creep.memory.role === 7 /* CreepRole.Upgrader */)
                workNeeded -= _.sum(creep.body, body => body.type === WORK ? 1 : 0);
            else //if (creep.memory.role === CreepRole.Hauler)
                carryNeeded -= _.sum(creep.body, body => body.type === CARRY ? 1 : 0);
        }
        //
        let haulersNeeded = Math.ceil(carryNeeded / maxCarry);
        let upgradersNeeded = Math.ceil(workNeeded / maxWork);
        const carryPerHauler = Math.min(maxCarry, Math.ceil(baseCarryNeeded / haulersNeeded));
        //console.log(this.room.name, upgradersNeeded, workNeeded, maxWork, workCount, this.scale.last());
        //
        if (haulersNeeded <= 0 && upgradersNeeded <= 0)
            return [];
        let result = [];
        const haulerUpgraderRatio = (baseCarryNeeded / maxCarry) / upgraderCount;
        while (haulersNeeded > 0 || upgradersNeeded > 0) {
            if (haulersNeeded > upgradersNeeded * haulerUpgraderRatio) {
                if (this.memory.haulingRatio > 0.9) {
                    result.push({
                        id: generateRandomKey(5),
                        nameBase: Config.CreepNames.Hauler,
                        priority: Priority(0, this.creeps.some(c => c.memory.role === 1 /* CreepRole.Hauler */) ? 8 /* SpawnPriority.UPGRADE */ : 14 /* SpawnPriority.FIRST_UPGRADER */),
                        minEnergy: 150,
                        parts: new CreepBody(`${carryPerHauler}C${Math.ceil(carryPerHauler * haulerMoveMultiplier)}M`),
                        memory: {
                            role: 1 /* CreepRole.Hauler */,
                            state: 0
                        },
                        boostOptions: [null],
                        noRepurpose: false,
                        operation: this
                    });
                }
                --haulersNeeded;
            }
            else {
                if (this.memory.workingRatio > 0.9) {
                    result.push({
                        id: generateRandomKey(5),
                        nameBase: Config.CreepNames.Upgrader,
                        priority: Priority(0, this.creeps.some(c => c.memory.role === 7 /* CreepRole.Upgrader */) ? 8 /* SpawnPriority.UPGRADE */ : 14 /* SpawnPriority.FIRST_UPGRADER */),
                        minEnergy: 300,
                        parts: scale >= 1
                            ? this.creepComposition.upgraderParts
                            : new CreepBody('WCM'),
                        boostOptions: (scale >= 1 && (Memory.toggles.useGH || this.room.controller.level < 8))
                            ? [[RES_XGH2O], [RES_GH2O], [RES_GH], null]
                            : [null],
                        memory: {
                            role: 7 /* CreepRole.Upgrader */
                        },
                        noRepurpose: false,
                        operation: this
                    });
                }
                --upgradersNeeded;
            }
        }
        return result;
    }
    upgraderFunc(creep) {
        if (creep.memory.boosts) {
            this.boostCreep(creep);
            return false;
        }
        if (creep.ticksToLive < 5 * this.pathLength && creep.body.find(b => !!b.boost)) {
            creep.drop(RESOURCE_ENERGY);
            this.dismissCreep(creep, true, false);
            return false;
        }
        let upgradePower = creep.getActiveBodyparts(WORK);
        let startingEnergy = creep.store.getUsedCapacity(RES_ENERGY);
        let currentEnergy = startingEnergy;
        if (currentEnergy > 0) {
            const container = this.container;
            if (container && container.hits < container.hitsMax && creep.pos.inRangeTo(container, 3))
                creep.repair(container);
            if (creep.pos.inRangeTo(this.room.controller, 3)
                && (this.room.controller.level < 8
                    || _.sum(creep.body, p => p.type === WORK ? 1 : 0) > 1
                    || this.room.controller.ticksToDowngrade <= CONTROLLER_DOWNGRADE[8] - CONTROLLER_DOWNGRADE_RESTORE)) {
                creep.upgradeController(this.room.controller);
                currentEnergy -= upgradePower;
            }
        }
        else {
            creep.room.visual.text('?', creep.pos.x, creep.pos.y, { color: '#ff0000' });
        }
        let distanceToDropSpot = creep.pos.getRangeTo(this.pos);
        let poorerUpgraders = creep.pos.lookInRange(LOOK_CREEPS, 1).filter(c => {
            if (!c.my)
                return false;
            if (c.memory.role !== 7 /* CreepRole.Upgrader */)
                return false;
            if (c.pos.isNearTo(this.pos) || c.pos.getRangeTo(this.pos) <= distanceToDropSpot)
                return false;
            return true;
        });
        const poorerUpgrader = poorerUpgraders.length > 0 ? _.min(poorerUpgraders, c => c.store.getUsedCapacity()) : null;
        if ((poorerUpgrader || creep.carry.energy < 2 * UPGRADE_CONTROLLER_POWER * creep.getActiveBodyparts(WORK))) {
            const container = this.container;
            const storage = this.room.storage;
            if (storage && storage.store.getUsedCapacity(RESOURCE_ENERGY) > 0 && creep.pos.isNearTo(storage.pos)) {
                creep.withdraw(storage, RESOURCE_ENERGY);
                currentEnergy = creep.store.getCapacity() - startingEnergy + currentEnergy;
            }
            else if (container && container.store.getUsedCapacity(RESOURCE_ENERGY) > 0 && creep.pos.isNearTo(container)) {
                creep.withdraw(container, RESOURCE_ENERGY);
                currentEnergy = creep.store.getCapacity() - startingEnergy + currentEnergy;
            }
            else {
                let pile = creep.pos.lookInRange(LOOK_RESOURCES, 1).find(r => r.resourceType === RESOURCE_ENERGY);
                if (pile) {
                    creep.pickup(pile);
                    currentEnergy = creep.store.getCapacity() - startingEnergy + currentEnergy;
                }
            }
        }
        if (currentEnergy > upgradePower || poorerUpgrader) {
            creep.transfer(poorerUpgrader, RES_ENERGY, currentEnergy - upgradePower);
        }
        // TODO - valid spots
        if (!creep.pos.inRangeTo(this.room.controller, 3) && creep.carry.energy) {
            let preferredSpot = this.preferredSpots.find(spot => spot.lookFor(LOOK_CREEPS).length === 0 && !spot.lookFor(LOOK_STRUCTURES).find(s => s.isObstacle()));
            if (preferredSpot)
                creep.goTo(preferredSpot, 0);
            else
                creep.goTo(this.room.controller.pos, 3);
        }
        else if (!creep.pos.inRangeTo(this.pos, 1) && !creep.carry.energy && (this.pos.lookFor(LOOK_RESOURCES).length > 0 || this.container && this.container.store.energy))
            creep.goTo(this.pos, 1);
        else if (!creep.pos.inRangeTo(this.pos, 6))
            creep.goTo(this.pos, 1);
        else if (creep.carry.energy)
            creep.giveWay({ pos: this.room.controller.pos, range: 3 });
        else {
            creep.giveWay(true);
            return false;
        }
        return true;
    }
    haulerFunc(creep) {
        let creepMemory = creep.memory;
        if (creepMemory.state === 0 /* HaulerState.Collecting */ && creep.store.energy === creep.store.getCapacity())
            creepMemory.state = 1 /* HaulerState.Returning */;
        else if (creepMemory.state === 1 /* HaulerState.Returning */ && creep.store.energy === 0)
            creepMemory.state = 0 /* HaulerState.Collecting */;
        let result = true;
        if (creepMemory.state === 0 /* HaulerState.Collecting */) {
            let energyOnSite = 0;
            const container = this.container;
            if (container && container.store[RESOURCE_ENERGY])
                energyOnSite += container.store[RESOURCE_ENERGY];
            let pile = this.pos.lookFor(LOOK_RESOURCES).find(r => r.resourceType === RESOURCE_ENERGY);
            if (pile)
                energyOnSite += pile.amount;
            if (energyOnSite < 2000)
                result = collectEnergy(creep, RESOURCE_ENERGY, this.parentRoom, this.constructor.name);
            else {
                creep.smokeBreak();
                result = false;
            }
        }
        else {
            let range = this.container ? 1 : 0;
            if (creep.pos.inRangeTo(this.pos, range)) {
                if (this.container)
                    creep.transfer(this.container, RESOURCE_ENERGY);
                else
                    creep.drop(RESOURCE_ENERGY);
                creep.giveWay(true);
            }
            else
                creep.goTo(this.pos, range);
        }
        return result;
    }
    layOffWorkers() {
        if (this.creeps.length === 0)
            return;
        const upgraderCount = Math.max(1, Math.floor(this.targetScale));
        let workNeeded = upgraderCount * this.creepComposition.upgraderParts.work;
        let carryNeeded = this.creepComposition.haulerCarryPerUppgrader * upgraderCount;
        let dismissUpgraders = false;
        let dismissHaulers = false;
        // oldest creeps are first in an array so reverse loop will keep young ones and dismiss old ones
        for (let i = this.creeps.length - 1; i >= 0; --i) {
            let creep = this.creeps[i];
            if (this.memory.workingRatio < 0.9 && creep.memory.role === 7 /* CreepRole.Upgrader */) {
                if (dismissUpgraders)
                    this.dismissCreep(creep, true, true);
                else {
                    workNeeded -= _.sum(creep.body, body => body.type === WORK ? 1 : 0);
                    if (workNeeded < 0)
                        dismissUpgraders = true;
                }
            }
            if (this.memory.haulingRatio < 0.9 && creep.memory.role === 1 /* CreepRole.Hauler */) {
                if (dismissHaulers)
                    this.dismissCreep(creep, true, true);
                else {
                    carryNeeded -= _.sum(creep.body, body => body.type === CARRY ? 1 : 0);
                    if (carryNeeded < 0)
                        dismissHaulers = true;
                }
            }
        }
    }
    updateFinishTimeEstimate() {
        const updateFrequency = 400;
        if (Game.time < this.memory.nextCheck)
            return;
        const progresSinceLastCheck = this.room.controller.progress - this.memory.lastProgress;
        const ticksTillFinish = (this.room.controller.progressTotal - this.room.controller.progress) / (progresSinceLastCheck / updateFrequency);
        const timeTillFinish = ticksTillFinish * Common.getTickDuration();
        this.memory.finishTimePrediction = Date.now() + Math.ceil(timeTillFinish);
        this.memory.lastProgress = this.room.controller.progress;
        this.memory.nextCheck = Game.time + updateFrequency;
    }
    onRun() {
        this.updateCreepComposition();
        this.layOffWorkers();
        let workingCount = 0;
        let haulingCount = 0;
        let workerCount = 0;
        let haulerCount = 0;
        for (let creep of this.creeps) {
            if (creep.spawning)
                continue;
            if (creep.memory.role === 7 /* CreepRole.Upgrader */) {
                ++workerCount;
                let wasWorking = this.upgraderFunc(creep);
                if (wasWorking)
                    ++workingCount;
            }
            else if (creep.memory.role === 1 /* CreepRole.Hauler */) {
                ++haulerCount;
                let wasHauling = this.haulerFunc(creep);
                if (wasHauling)
                    ++haulingCount;
            }
            else
                creep.say('INVALID');
        }
        const period = 100;
        if (workerCount === 0)
            this.memory.workingRatio = 1;
        else
            this.memory.workingRatio = this.memory.workingRatio * (period - 1) / period + (workingCount / workerCount) / period;
        if (haulerCount === 0)
            this.memory.haulingRatio = 1;
        else
            this.memory.haulingRatio = this.memory.haulingRatio * (period - 1) / period + (haulingCount / haulerCount) / period;
        this.updateFinishTimeEstimate();
    }
}
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationUpgrade.prototype, "getSpawnRequestsInternal", null);
__decorate([
    profile()
], OperationUpgrade.prototype, "upgraderFunc", null);
__decorate([
    profile()
], OperationUpgrade.prototype, "haulerFunc", null);
__decorate([
    check,
    profile()
], OperationUpgrade.prototype, "onRun", null);

class OperationDefend extends BaseRoomOperation {
    static create() {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0
        };
        return memory;
    }
    constructor(parentRoom) {
        super(parentRoom);
    }
    get memory() {
        return this.parentRoom.memory.defend;
    }
    onInitForTick() {
        this._safeZones = undefined;
        //
        let activeTowers = 0;
        for (let tower of this.roomLayout.towers)
            if (tower.store.energy >= TOWER_ENERGY_COST)
                ++activeTowers;
        if (activeTowers !== this._lastActiveTowerCount)
            this._towerDamageMatrix = undefined;
        this._lastActiveTowerCount = activeTowers;
        //
        this.hostilesInRoom = this.room.findHostileCreeps();
        if (this.hostilesInRoom.length > 0 && !this.memory.hostilesArrival)
            this.memory.hostilesArrival = Game.time;
        else if (this.hostilesInRoom.length === 0)
            this.memory.hostilesArrival = undefined;
        //
        this.isUnderAttack = (!this.room.controller.safeMode
            && this.hostilesInRoom.length > 0
            && this.memory.hostilesArrival
            && (Game.time - this.memory.hostilesArrival > (this.hostilesInRoom.some(h => h.owner.username !== 'Invader')
                ? OperationDefend.spawnAgainstPlayersThreshold
                : OperationDefend.spawnAgainstInvadersThreshold)));
        this.attackerBoostTier = 0;
        for (let h of this.hostilesInRoom) {
            if (h.owner.username !== 'Invader')
                continue;
            for (let b of h.body)
                if (b.boost)
                    this.attackerBoostTier = Math.max(this.attackerBoostTier, BOOST_TO_TIER[b.boost]);
        }
    }
    getMinimumScale() {
        return 1;
    }
    getMaximumScale() {
        return 1;
    }
    updateEstimatedStats() {
        this.estimatedStats.energyPerTick = 0;
        this.estimatedStats.spawnTime = 0;
        this.estimatedStats.baseCpu = this.creeps.length * 0.2;
    }
    onSpawn(requestId, creepName) {
        super.onSpawn(requestId, creepName);
        this.shouldUpdateEstimatedStats = true;
    }
    onCreepDeath(creepName) {
        this.shouldUpdateEstimatedStats = true;
    }
    get safeZones() {
        if (this._safeZones)
            return this._safeZones;
        this._safeZones = _(this.roomLayout.ramparts)
            .filter(r => !r.pos.lookFor(LOOK_STRUCTURES).find(s => s.isObstacle()) && !r.pos.isNearTo(this.room.controller))
            .map(r => r.pos)
            .value();
        return this._safeZones;
    }
    getSpawnRequestsInternal() {
        if (!this.isUnderAttack)
            return [];
        if (this.hostilesInRoom.every(h => h.getActiveBodyparts(RANGED_ATTACK) === 0 && h.getActiveBodyparts(WORK) === 0 && h.getActiveBodyparts(ATTACK) === 0))
            return [];
        let maxDefenders = Math.min(this.hostilesInRoom.length, OperationDefend.maxDefenders);
        if (this.creeps.length >= maxDefenders)
            return [];
        const attackersHeal = _.sum(this.room.findHostileCreeps(), h => HEAL_POWER * getBodypartPower(HEAL, h));
        const defendersAttack = _.sum(this.creeps, c => ATTACK_POWER * getBodypartPower(ATTACK, c) + RANGED_ATTACK_POWER * getBodypartPower(RANGED_ATTACK, c));
        const towerPower = this.roomLayout.towers.length * 150;
        if (towerPower + defendersAttack > attackersHeal * 2)
            return [];
        const rangedDefendersCount = _.sum(this.creeps, c => c.body.find(bp => bp.type === RANGED_ATTACK) ? 1 : 0);
        const meleeDefendersCount = this.creeps.length - rangedDefendersCount;
        const useRanged = (rangedDefendersCount < meleeDefendersCount);
        let meleeMultiplier = useRanged ? 0 : 4;
        let rangedMultiplier = useRanged ? 4 : 0;
        if (this.room.energyCapacityAvailable < 400)
            meleeMultiplier = meleeMultiplier * 3 / 4;
        if (this.room.energyCapacityAvailable < 650)
            rangedMultiplier = rangedMultiplier / 4;
        let maxPartCount = Math.floor(this.room.energyCapacityAvailable / (rangedMultiplier * BODYPART_COST[RANGED_ATTACK] + meleeMultiplier * BODYPART_COST[ATTACK] + BODYPART_COST[MOVE]));
        maxPartCount = Math.min(maxPartCount, 10);
        let rangedBoostOptions = [[RES_XKHO2], [RES_KHO2], [RES_KO], null].slice(3 - this.attackerBoostTier);
        let meleeBoostOptions = [[RES_XUH2O], [RES_UH2O], [RES_UH], null].slice(3 - this.attackerBoostTier);
        let result = [];
        result.push({
            id: generateRandomKey(5),
            nameBase: this.roomName + '_Defender',
            priority: Priority(0, 13 /* SpawnPriority.DEFEND */ - this.creeps.length / 1000),
            minEnergy: 200,
            parts: new CreepBody(`${(useRanged ? rangedMultiplier : meleeMultiplier) * maxPartCount}${useRanged ? 'R' : 'A'}${maxPartCount}M`),
            memory: {},
            boostOptions: useRanged ? rangedBoostOptions : meleeBoostOptions,
            noRepurpose: false,
            operation: this
        });
        return result;
    }
    getTowerDamageMatrix() {
        if (this._towerDamageMatrix)
            return this._towerDamageMatrix;
        let towers = this.roomLayout.towers;
        this._towerDamageMatrix = new Uint16Array(2500);
        for (let i = 0; i < 2500; ++i) {
            let x = i % 50;
            let y = Math.floor(i / 50);
            this._towerDamageMatrix[i] = 0;
            for (let t of towers) {
                if (t.energy < TOWER_ENERGY_COST)
                    continue;
                this._towerDamageMatrix[i] += TOWER_POWER_ATTACK * Common.calcTowerMultiplier(x, y, t.pos.x, t.pos.y);
            }
        }
        return this._towerDamageMatrix;
    }
    getHostilesWorthAttacking() {
        let friendlies = this.room.findFriendlyCreeps();
        let hostiles = this.room.findHostileCreeps();
        let hostileHealers = this.room.controller.safeMode
            ? []
            : hostiles.filter(h => h.getActiveBodyparts(HEAL) > 0);
        // if there are no hostile soldier creeps then assume it's not an attack or drain attempt
        let anyHostileSoldiers = hostiles.some(h => h.body.some(bp => bp.type === ATTACK || bp.type === RANGED_ATTACK || bp.type === HEAL));
        if (!anyHostileSoldiers)
            return hostiles;
        return hostiles.filter(creep => {
            const healers = creep.pos.findInRange(hostileHealers, 1);
            const healsCount = _.sum(healers, healer => getBodypartPower(HEAL, healer));
            let creepDamageOnSpot = 0;
            for (let friendly of friendlies) {
                const mAttackPower = getBodypartPower(ATTACK, friendly);
                const rAttackPower = getBodypartPower(RANGED_ATTACK, friendly);
                if (mAttackPower > 0 && friendly.pos.inRangeTo(creep.pos, 1))
                    creepDamageOnSpot += mAttackPower * ATTACK_POWER;
                if (rAttackPower > 0 && friendly.pos.inRangeTo(creep.pos, 3))
                    creepDamageOnSpot += rAttackPower * RANGED_ATTACK_POWER;
            }
            let towerDamageMatrix = this.getTowerDamageMatrix();
            let towersPowerAtSpot = towerDamageMatrix[creep.pos.y * 50 + creep.pos.x];
            //
            let potentialHealOnSpot = healsCount * HEAL_POWER;
            let potentialDamageOnSpot = creepDamageOnSpot + towersPowerAtSpot;
            if (creep.owner.username === 'Invader' && potentialDamageOnSpot > potentialHealOnSpot)
                return true;
            if (potentialDamageOnSpot > potentialHealOnSpot && creep.pos.lookInRange(LOOK_STRUCTURES, 1).find(s => s.isMy()))
                return true;
            let creepDistanceToExit = creep.pos.findClosestByRange(FIND_EXIT).getRangeTo(creep);
            if (creep.fatigue > 0)
                creepDistanceToExit += Math.ceil(creep.fatigue / (getBodypartPower(MOVE, creep) * 2));
            if (!_.isFinite(creepDistanceToExit))
                return true;
            let damageTillExit = creepDamageOnSpot;
            const towerFalloffPerTile = TOWER_POWER_ATTACK * TOWER_FALLOFF / (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);
            const minTowerDamage = TOWER_POWER_ATTACK * (1.0 - TOWER_FALLOFF);
            do {
                // assumes creep retreats with all healers in range
                damageTillExit += towersPowerAtSpot - potentialHealOnSpot;
                towersPowerAtSpot = Math.max(towersPowerAtSpot - towerFalloffPerTile, minTowerDamage);
                --creepDistanceToExit;
            } while (creepDistanceToExit > 0);
            creep.room.visual.text((creep.hits - damageTillExit).toString(), creep.pos.x, creep.pos.y - 0.5);
            return damageTillExit >= creep.hits;
        });
    }
    runTowers() {
        let towers = this.roomLayout.towers;
        if (!towers || towers.length === 0)
            return;
        //let dmgCM = this.getTowerDamageMatrix();
        //(global.cc as ConsoleCommands).visualizeCM(this.roomName, dmgCM);
        //let cpuStart = Game.cpu.getUsed();
        let hostilesWorthAttacking = this.getHostilesWorthAttacking();
        if (hostilesWorthAttacking.length > 0) {
            for (let tower of towers)
                tower.attack(tower.pos.findClosestByRange(hostilesWorthAttacking));
            this.parentRoom.updateTowerDistributionRequests();
            return;
        }
        //console.log(this.parentRoom.roomName, 'shootingHostiles', Game.cpu.getUsed() - cpuStart); cpuStart = Game.cpu.getUsed();
        let startIndex = 0;
        // repairing spawns
        let spawns = this.roomLayout.spawns;
        for (let spawnIndex = 0; spawnIndex < spawns.length && startIndex < towers.length; ++spawnIndex) {
            let spawn = spawns[spawnIndex];
            if (spawn.hits === spawn.hitsMax)
                continue;
            let repairedAmount = 0;
            for (let i = startIndex; i < towers.length; ++i) {
                let tower = towers[i];
                tower.repair(spawn);
                this.parentRoom.updateTowerDistributionRequests();
                ++startIndex;
                let repairPower = TOWER_POWER_REPAIR * Common.calcTowerMultiplier(spawn.pos.x, spawn.pos.y, tower.pos.x, tower.pos.y);
                repairedAmount += repairPower;
                if (spawn.hits + repairedAmount >= spawn.hitsMax)
                    break;
            }
        }
        //console.log(this.parentRoom.roomName, 'repairingSpawns', Game.cpu.getUsed() - cpuStart); cpuStart = Game.cpu.getUsed();
        // TODO - track entering/leaving creeps, check only if there is an invasion or creep entered a room
        // healing creeps
        let myCreeps = this.room.findFriendlyCreeps();
        for (let creepIndex = 0; creepIndex < myCreeps.length && startIndex < towers.length; ++creepIndex) {
            let creep = myCreeps[creepIndex];
            if (creep.hits === creep.hitsMax)
                continue;
            if (creep.pos.isExit())
                continue;
            if (!creep.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_RAMPART) && this.hostilesInRoom.some(h => h.getActiveBodyparts(ATTACK) && h.pos.isNearTo(creep.pos) || h.getActiveBodyparts(RANGED_ATTACK) && h.pos.inRangeTo(creep.pos, 3)))
                continue;
            if (this.isUnderAttack && !creep.body.find(p => p.type === RANGED_ATTACK || p.type === ATTACK || p.type === HEAL || p.type === WORK))
                continue;
            let healedAmount = 0;
            for (let i = startIndex; i < towers.length; ++i) {
                let tower = towers[i];
                tower.heal(creep);
                this.parentRoom.updateTowerDistributionRequests();
                ++startIndex;
                let healPower = TOWER_POWER_HEAL * Common.calcTowerMultiplier(creep.pos.x, creep.pos.y, tower.pos.x, tower.pos.y);
                healedAmount += healPower;
                if (creep.hits + healedAmount >= creep.hitsMax)
                    break;
            }
        }
        //console.log(this.parentRoom.roomName, 'healingCreeps', Game.cpu.getUsed() - cpuStart); cpuStart = Game.cpu.getUsed();
    }
    defenderFunc(creep) {
        let creepMemory = creep.memory;
        if (this.room.controller.safeMode) {
            this.dismissCreep(creep, true, true);
            return;
        }
        if (creep.ticksToLive < 100) {
            this.dismissCreep(creep, true, false);
            return;
        }
        if (creep.memory.boosts) {
            this.boostCreep(creep);
            return;
        }
        let hostilesInRange = creep.pos.findInRange(this.hostilesInRoom, 3);
        if (creep.getActiveBodyparts(RANGED_ATTACK))
            creep.shootAtWill(hostilesInRange);
        let hostilesInMeleeRange = creep.pos.findInRange(hostilesInRange, 1);
        if (hostilesInMeleeRange.length > 0)
            creep.attack(hostilesInMeleeRange[0]);
        let opts = {
            stayUnderRampart: creep.pos.lookFor(LOOK_STRUCTURES).some(s => s.structureType === STRUCTURE_RAMPART)
        };
        // get to room
        if (creep.pos.roomName !== this.roomName)
            creep.goToRoom(this.roomName);
        else if (this.hostilesInRoom.length > 0) {
            let targetPos = creepMemory.targetPos ? RoomPosition.deserialize(creepMemory.targetPos) : undefined;
            // find new targetPos
            if (!targetPos || !this.hostilesInRoom.some(h => targetPos.isNearTo(h.pos))) {
                let safeZoneClosestToHostile = _.min(this.safeZones, safeZone => {
                    let defenderOnPos = this.creeps.some(c => {
                        let cMemory = creep.memory;
                        if (creep === c)
                            return false;
                        if (c.pos.isEqualTo(safeZone))
                            return true;
                        if (cMemory.targetPos && RoomPosition.deserialize(cMemory.targetPos).isEqualTo(safeZone))
                            return true;
                        return false;
                    });
                    if (defenderOnPos)
                        return Infinity;
                    let safeZoneRange = safeZone.findClosestByRange(this.hostilesInRoom).pos.getRangeTo(safeZone);
                    //let closestHostileRange = _.min(this.hostilesInRoom, hostile => creep.pos.getRangeTo(hostile)).pos.getRangeTo(creep);
                    //if (safeZoneRange > closestHostileRange)
                    //  return Infinity;
                    return safeZoneRange;
                });
                targetPos = (this.safeZones.length > 0 ? safeZoneClosestToHostile : creep.pos.findClosestByRange(this.hostilesInRoom).pos);
                creepMemory.targetPos = targetPos.serialize();
            }
            //                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       c
            if (targetPos) {
                if (creep.pos.isEqualTo(targetPos))
                    creep.giveWay();
                else
                    creep.goTo(targetPos, 0, opts);
            }
        }
        else {
            if (creep.ticksToLive > 30)
                creep.smokeBreak();
            else
                this.dismissCreep(creep, true, false);
        }
    }
    letAlliesIn() {
        if (!this._rampartsToClose) {
            this._rampartsToClose = this.roomLayout.ramparts
                .filter(r => r.isPublic)
                .map(r => r.id);
        }
        let alliesInRoom = this.room.findAlliedCreeps();
        this._rampartsToClose = this._rampartsToClose.filter(rampartId => {
            let r = Game.getObjectById(rampartId);
            if (!r || !r.isPublic)
                return false;
            const anyAllyNearRamp = alliesInRoom.some(ally => ally.pos.isNearTo(r.pos) && !ally.pos.isEqualTo(r.pos));
            if (anyAllyNearRamp)
                return true;
            r.setPublic(false);
            return true;
        });
        if (alliesInRoom.length === 0 || this.roomLayout.ramparts.length === 0)
            return;
        if (this.isUnderAttack)
            return;
        //*
        for (let ally of alliesInRoom) {
            for (let dir in Common.offset) {
                let x = ally.pos.x + Common.offset[dir].x;
                let y = ally.pos.y + Common.offset[dir].y;
                if (x < 0 || x > 49 || y < 0 || y > 49)
                    continue;
                let rampartAtPos = this.room.lookForAt(LOOK_STRUCTURES, x, y).find(s => s.structureType === STRUCTURE_RAMPART);
                if (rampartAtPos && rampartAtPos.my && !rampartAtPos.isPublic) {
                    rampartAtPos.setPublic(true);
                    this._rampartsToClose.push(rampartAtPos.id);
                }
            }
        }
        /*/
        for (let r of this.roomLayout.ramparts) {
          const anyAllyNearRamp = alliesInRoom.some(ally => ally.pos.inRangeTo(r.pos, 1) && !ally.pos.isEqualTo(r.pos));
          if (!r.isPublic && anyAllyNearRamp && r.pos.lookFor(LOOK_STRUCTURES).filter(s => s.structureType === STRUCTURE_ROAD)) {
            r.setPublic(true);
            this.rampartsToClose.push(r);
          }
        }
        //*/
    }
    primitiveLetAlliesIn() {
        if (!this._rampartsToClose) {
            this._rampartsToClose = this.roomLayout.ramparts
                .filter(r => r.isPublic)
                .map(r => r.id);
        }
        let alliesInRoom = this.room.findAlliedCreeps();
        const areRampartsOpen = this._rampartsToClose.length > 0;
        const areAlliesReallyInARoom = alliesInRoom.some(c => c.pos.x < 2 && c.pos.y < 2 && c.pos.x > 47 && c.pos.y > 47);
        if (!this.isUnderAttack && !areRampartsOpen && areAlliesReallyInARoom) {
            for (let r of this.roomLayout.ramparts) {
                r.setPublic(true);
                this._rampartsToClose.push(r.id);
            }
        }
        else if (areRampartsOpen && (!areAlliesReallyInARoom || this.isUnderAttack)) {
            for (let rampartId of this._rampartsToClose) {
                const rampart = Game.getObjectById(rampartId);
                if (!rampart || !rampart.isPublic)
                    continue;
                rampart.setPublic(false);
            }
            this._rampartsToClose = [];
        }
    }
    autoSafeMode() {
        if (this.room.find(FIND_FLAGS).find(f => f.name.startsWith('NoSafemode')))
            return;
        let rampartCount = this.roomLayout.ramparts.length;
        if (this.isUnderAttack) {
            const controller = this.room.controller;
            const hasDestroyedRampart = (this._lastRampartCount !== undefined && rampartCount < this._lastRampartCount);
            const isSpawnEndangered = this.roomLayout.spawns.some(s => s.hits < s.hitsMax);
            const isControllerEndangered = this.room.findHostileCreeps().find(c => {
                if (!c.pos.inRangeTo(controller.pos, 2))
                    return false;
                if (c.getActiveBodyparts(CLAIM) === 0)
                    return false;
                if (Pather.findPath(c.pos, { pos: controller.pos, range: 1 }, { offroad: true, maxCost: 2 }).incomplete)
                    return false;
                return true;
            });
            if (hasDestroyedRampart || isSpawnEndangered || isControllerEndangered)
                controller.activateSafeMode();
        }
        this._lastRampartCount = rampartCount;
    }
    onRun() {
        this.runTowers();
        for (let creep of this.creeps)
            if (!creep.spawning || creep.memory.boosts)
                this.defenderFunc(creep);
        this.autoSafeMode();
        if (this.isUnderAttack && this.attackerBoostTier > 0) {
            this.parentRoom.memory.wasEverSieged = true;
        }
        if (Memory.toggles.usePrimitiveRampartOpening)
            this.primitiveLetAlliesIn();
        else
            this.letAlliesIn();
    }
}
// ----------------------------------------------------
OperationDefend.maxDefenders = 6;
OperationDefend.spawnAgainstInvadersThreshold = 30;
OperationDefend.spawnAgainstPlayersThreshold = 5;
__decorate([
    Profiler.profile()
], OperationDefend.prototype, "onInitForTick", null);
__decorate([
    profile()
], OperationDefend.prototype, "getHostilesWorthAttacking", null);
__decorate([
    profile()
], OperationDefend.prototype, "runTowers", null);
__decorate([
    profile()
], OperationDefend.prototype, "defenderFunc", null);
__decorate([
    profile()
], OperationDefend.prototype, "letAlliesIn", null);
__decorate([
    check,
    profile()
], OperationDefend.prototype, "onRun", null);

class OperationBuild extends BaseRoomOperation {
    static create() {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            lastRCL: 0,
            lastStructureCount: 0,
            workingRatio: 1,
            currentBuildTask: undefined
        };
        return memory;
    }
    constructor(parentRoom) {
        super(parentRoom);
        if (this.memory.currentBuildTask) {
            this.currentBuildTask = {
                structureType: this.memory.currentBuildTask.structureType,
                pos: RoomPosition.deserialize(this.memory.currentBuildTask.pos)
            };
        }
        this.creepComposition = {
            body: undefined,
            energyCapacityAvailable: -1
        };
    }
    get memory() {
        return this.parentRoom.memory.build;
    }
    updateCreepComposition() {
        if (!this.creepComposition || this.creepComposition.energyCapacityAvailable !== this.room.energyCapacityAvailable) {
            const partsCount = Math.min(16, Math.floor(this.room.energyCapacityAvailable / (BODYPART_COST[WORK] + BODYPART_COST[CARRY] + BODYPART_COST[MOVE])));
            this.creepComposition = {
                energyCapacityAvailable: this.room.energyCapacityAvailable,
                body: new CreepBody(`${partsCount}[WC]${partsCount}M`)
            };
            this.shouldUpdateEstimatedStats = true;
        }
    }
    //
    getMinimumScale() {
        return this.currentBuildTask ? 1 : 0;
    }
    getMaximumScale() {
        if (!this.currentBuildTask)
            return 0;
        if (this.room.storage && this.currentBuildTask.pos.roomName !== this.roomName)
            return 6;
        else if (this.room.storage)
            return 3;
        else
            return 10;
    }
    updateEstimatedStats() {
        if (!this.currentBuildTask) {
            this.estimatedStats.energyPerTick = 0;
            this.estimatedStats.spawnTime = 0;
            this.estimatedStats.baseCpu = 0;
        }
        else {
            const baseCenter = this.parentRoom.layout.roomPlan.pos;
            const creepCost = this.creepComposition.body.cost;
            const searchResult = Pather.findPath(baseCenter, { pos: this.currentBuildTask.pos, range: 3 });
            if (searchResult.incomplete) {
                console.log(this.roomName, "Couldn't find path to build task", this.currentBuildTask.pos.serialize());
            }
            const buildingEffectiveness = searchResult.incomplete
                ? 0.5
                : CARRY_CAPACITY / (CARRY_CAPACITY + Math.max(1, 1 + 2 * searchResult.path.length));
            this.estimatedStats.energyPerTick = -(creepCost / CREEP_LIFE_TIME + BUILD_POWER * this.creepComposition.body.work * buildingEffectiveness);
            this.estimatedStats.spawnTime = this.creepComposition.body.spawnTime;
            this.estimatedStats.baseCpu = 0.2;
        }
    }
    updateCurrentBuildTask() {
        // if finished remove task
        let justFinished = false;
        if (this.currentBuildTask) {
            const currentTaskRoomName = this.currentBuildTask.pos.roomName;
            const currentTaskRoom = Game.rooms[currentTaskRoomName];
            const currentTaskRoomIntel = GIntel.rooms[currentTaskRoomName];
            const isBuildingBlocked = (currentTaskRoomIntel.reservation && !currentTaskRoomIntel.reservation.isMy);
            const isRouteUnsafe = Pather.findRoute(this.roomName, currentTaskRoomName, {}).some(roomName => !GIntel.rooms[roomName].isSafe);
            if (isRouteUnsafe || isBuildingBlocked) {
                this.memory.currentBuildTask = undefined;
                this.currentBuildTask = undefined;
                this.shouldUpdateEstimatedStats = true;
                justFinished = true;
            }
            else if (currentTaskRoom && this.currentBuildTask.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === this.memory.currentBuildTask.structureType)) {
                // roads aren't cached
                if (this.memory.currentBuildTask.structureType !== STRUCTURE_ROAD)
                    this.parentRoom.layout.updateCache();
                this.memory.currentBuildTask = undefined;
                this.currentBuildTask = undefined;
                this.shouldUpdateEstimatedStats = true;
                justFinished = true;
            }
        }
        // if no task find some module to build - assumes spawns have top priority, otherwise it'd cause to update build task every tick
        const switchToBuildingSpawn = this.memory.currentBuildTask
            && this.memory.currentBuildTask.structureType !== STRUCTURE_SPAWN
            && this.roomLayout.spawns.length === 0;
        let shouldFindNewTask = switchToBuildingSpawn
            || !this.memory.currentBuildTask
                && (justFinished
                    || this.memory.lastRCL !== this.room.controller.level
                    || Game.time % 50 === 0
                    || Game.time % 10 && this.memory.lastStructureCount !== this.room.find(FIND_STRUCTURES).length);
        // anti nuke ramparting
        const nukes = this.room.find(FIND_NUKES);
        for (let nuke of nukes) {
            let left = Math.max(1, nuke.pos.x - 2);
            let right = Math.min(49, nuke.pos.x + 2);
            let top = Math.max(1, nuke.pos.y - 2);
            let bottom = Math.min(49, nuke.pos.y + 2);
            for (let x = left; x <= right; ++x)
                for (let y = top; y <= bottom; ++y) {
                    let structures = this.room.lookForAt(LOOK_STRUCTURES, x, y);
                    if (structures.find(s => s.isOwned() && s.isBuildable() && s.structureType !== STRUCTURE_RAMPART) && !structures.find(s => s.structureType === STRUCTURE_RAMPART)) {
                        this.room.createConstructionSite(x, y, STRUCTURE_RAMPART);
                        shouldFindNewTask = true;
                    }
                }
        }
        if (shouldFindNewTask && !this.parentRoom.abandon) {
            this.memory.lastRCL = this.room.controller.level;
            this.memory.lastStructureCount = this.room.find(FIND_STRUCTURES).length;
            if (nukes.length > 0) {
                let constructionSites = this.room.find(FIND_MY_CONSTRUCTION_SITES);
                let rampartCS = constructionSites.find(cs => cs.structureType === STRUCTURE_RAMPART);
                if (rampartCS) {
                    this.currentBuildTask = {
                        structureType: rampartCS.structureType,
                        pos: rampartCS.pos
                    };
                    this.memory.currentBuildTask = {
                        structureType: rampartCS.structureType,
                        pos: rampartCS.pos.serialize()
                    };
                    this.shouldUpdateEstimatedStats = true;
                }
            }
            if (!this.currentBuildTask) {
                let buildRequest = this.parentRoom.layout.getBuildRequest();
                if (buildRequest) {
                    let taskRoom = Game.rooms[buildRequest.pos.roomName];
                    let taskPos = buildRequest.pos;
                    let isCS = (taskPos.lookFor(LOOK_CONSTRUCTION_SITES).length > 0);
                    if (!isCS) {
                        let createResult = taskRoom.createConstructionSite(buildRequest.pos.x, buildRequest.pos.y, buildRequest.structureType);
                        if (createResult === OK)
                            isCS = true;
                        else
                            console.log(this.parentRoom.roomName, 'build create result:', ERROR_STR[createResult], 'pos:', buildRequest.pos.link(), 'structureType:', buildRequest.structureType);
                    }
                    if (isCS) {
                        this.currentBuildTask = {
                            structureType: buildRequest.structureType,
                            pos: buildRequest.pos
                        };
                        this.memory.currentBuildTask = {
                            structureType: buildRequest.structureType,
                            pos: buildRequest.pos.serialize()
                        };
                        this.shouldUpdateEstimatedStats = true;
                    }
                }
            }
            // existing construction sites
            if (!this.currentBuildTask) {
                let constructionSites = this.room.find(FIND_MY_CONSTRUCTION_SITES);
                if (constructionSites.length > 0) {
                    this.currentBuildTask = {
                        structureType: constructionSites[0].structureType,
                        pos: constructionSites[0].pos
                    };
                    this.memory.currentBuildTask = {
                        structureType: constructionSites[0].structureType,
                        pos: constructionSites[0].pos.serialize()
                    };
                    this.shouldUpdateEstimatedStats = true;
                }
            }
        }
        // create construction site + stuff
        if (this.currentBuildTask) {
            const currentTaskRoomName = this.currentBuildTask.pos.roomName;
            const currentTaskRoom = Game.rooms[currentTaskRoomName];
            new RoomVisual(currentTaskRoomName).text('\u{1F6A7}', this.currentBuildTask.pos.x, this.currentBuildTask.pos.y);
            if (currentTaskRoom) {
                let constructionSite = currentTaskRoom.lookForAt(LOOK_CONSTRUCTION_SITES, this.currentBuildTask.pos.x, this.currentBuildTask.pos.y)[0];
                if (!constructionSite) {
                    let result = currentTaskRoom.createConstructionSite(this.currentBuildTask.pos.x, this.currentBuildTask.pos.y, this.currentBuildTask.structureType);
                    if (result !== OK) {
                        this.currentBuildTask = undefined;
                        this.memory.currentBuildTask = undefined;
                        this.shouldUpdateEstimatedStats = true;
                    }
                }
                let creepOnCS = currentTaskRoom.lookForAt(LOOK_CREEPS, this.currentBuildTask.pos).find(c => c.my);
                if (constructionSite && creepOnCS && OBSTACLE_STRUCTURE_TYPES.has(constructionSite.structureType))
                    creepOnCS.memory.excuseMe = Common.getRandomDir();
            }
        }
    }
    getSpawnRequestsInternal() {
        if (!this.currentBuildTask)
            return [];
        if (this.room.memory.lastSafe < this.room.memory.lastScout && !this.room.controller.safeMode)
            return [];
        if (this.memory.workingRatio < 0.9)
            return [];
        const composition = this.creepComposition;
        if (composition.body.work === 0)
            return [];
        let workNeeded = this.targetScale * composition.body.work - _.sum(this.creeps, c => _.sum(c.body, b => b.type === WORK ? 1 : 0));
        if (workNeeded <= 0)
            return [];
        let result = [];
        const creepsNeeded = Math.ceil(workNeeded / composition.body.work);
        for (let i = 0; i < creepsNeeded; ++i) {
            result.push({
                id: generateRandomKey(5),
                nameBase: Config.CreepNames.Builder,
                priority: Priority(0, 9 /* SpawnPriority.BUILD */),
                minEnergy: 200,
                parts: composition.body,
                memory: {
                    state: 0 /* EBuilderState.GETTING_ENERGY */
                },
                boostOptions: [null],
                noRepurpose: false,
                operation: this
            });
        }
        return result;
    }
    builderFunc(creep) {
        let creepMemory = creep.memory;
        if (creepMemory.state === 0 /* EBuilderState.GETTING_ENERGY */ && creep.carry.energy === creep.carryCapacity)
            creepMemory.state = 1 /* EBuilderState.BUILDING */;
        if (creepMemory.state === 1 /* EBuilderState.BUILDING */ && creep.carry.energy === 0)
            creepMemory.state = 0 /* EBuilderState.GETTING_ENERGY */;
        // go back to room for tower healing
        if (creep.getActiveBodyparts(WORK) === 0) {
            const isInRoom = creep.pos.roomName === this.parentRoom.roomName;
            if (isInRoom && !creep.pos.isExit())
                creep.moveOffExit();
            else if (isInRoom)
                creep.smokeBreak();
            else
                creep.goToRoom(this.parentRoom.roomName);
            return false;
        }
        // get energy
        if (creepMemory.state === 0 && this.currentBuildTask && creep.pos.roomName === this.currentBuildTask.pos.roomName) {
            let energyPile = this.currentBuildTask.pos.lookFor(LOOK_RESOURCES).find(r => r.resourceType === RESOURCE_ENERGY);
            if (energyPile && energyPile.amount >= creep.carryCapacity) {
                if (creep.pos.isNearTo(energyPile)) {
                    creep.pickup(energyPile);
                    Stats.registerSpending(this.parentRoom.roomName, this.constructor.name, Math.min(creep.store.getFreeCapacity(), energyPile.amount));
                }
                else
                    creep.goTo(energyPile.pos, 1);
                return true;
            }
        }
        if (creepMemory.state === 0 /* EBuilderState.GETTING_ENERGY */) {
            return collectEnergy(creep, RESOURCE_ENERGY, this.parentRoom, this.constructor.name);
        }
        // build
        let lowRampart = creep.pos.lookInRange(LOOK_STRUCTURES, 3).find(s => s.structureType === STRUCTURE_RAMPART && s.hits < 10000);
        if (lowRampart) {
            creep.repair(lowRampart);
            creep.giveWay({ pos: lowRampart.pos, range: 3 });
            return true;
        }
        if (this.currentBuildTask) {
            if (creep.pos.roomName !== this.currentBuildTask.pos.roomName)
                creep.goTo(this.currentBuildTask.pos, 1);
            else if (!creep.pos.inRangeTo(this.currentBuildTask.pos, 3))
                creep.goTo(this.currentBuildTask.pos, 3);
            else if (creep.pos.isExit())
                creep.moveOffExit();
            else {
                const constructionSites = this.currentBuildTask.pos.lookFor(LOOK_CONSTRUCTION_SITES);
                if (constructionSites.length > 0) {
                    creep.build(constructionSites[0]);
                    creep.giveWay({ pos: this.currentBuildTask.pos, range: 3 });
                }
            }
            return true;
        }
        creep.smokeBreak();
        return false;
    }
    abortBuildTask() {
        this.memory.currentBuildTask = undefined;
        this.currentBuildTask = undefined;
    }
    onRun() {
        this.updateCreepComposition();
        this.updateCurrentBuildTask();
        let workingCount = 0;
        for (let creep of this.creeps) {
            if (creep.spawning)
                continue;
            if (this.currentBuildTask) {
                let wasWorking = this.builderFunc(creep);
                if (wasWorking)
                    ++workingCount;
            }
            else {
                this.dismissCreep(creep, true, true);
            }
        }
        const period = 100;
        if (this.memory.creeps.length === 0)
            this.memory.workingRatio = this.memory.workingRatio * (period - 1) / period + 1 / period;
        else
            this.memory.workingRatio = this.memory.workingRatio * (period - 1) / period + (workingCount / this.memory.creeps.length) / period;
    }
}
__decorate([
    profile("BuildLogic" /* ProfilerFunctionType.BuildLogic */)
], OperationBuild.prototype, "updateCurrentBuildTask", null);
__decorate([
    profile("BuildLogic" /* ProfilerFunctionType.BuildLogic */)
], OperationBuild.prototype, "builderFunc", null);
__decorate([
    check,
    profile("BuildLogic" /* ProfilerFunctionType.BuildLogic */)
], OperationBuild.prototype, "onRun", null);

class OperationRecovery extends BaseRoomOperation {
    static create() {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0
        };
        return memory;
    }
    // ----------------------------------------------------
    constructor(parentRoom) {
        super(parentRoom);
    }
    get memory() {
        return this.parentRoom.memory.recovery;
    }
    getMinimumScale() {
        return 1;
    }
    getMaximumScale() {
        return 1;
    }
    updateEstimatedStats() {
        this.estimatedStats.energyPerTick = 0;
        this.estimatedStats.spawnTime = 0;
        this.estimatedStats.baseCpu = this.creeps.length * 0.2;
    }
    onSpawn(requestId, creepName) {
        super.onSpawn(requestId, creepName);
        this.shouldUpdateEstimatedStats = true;
    }
    onCreepDeath(creepName) {
        this.shouldUpdateEstimatedStats = true;
    }
    getSpawnRequestsInternal() {
        if (!this.parentRoom.isRecoveryNeeded())
            return [];
        if (this.creeps.length > 0)
            return [];
        let result = [];
        result.push({
            id: generateRandomKey(5),
            nameBase: this.roomName + '_Restorer',
            priority: Priority(0, 30 /* SpawnPriority.RECOVERY */),
            minEnergy: 250,
            parts: new CreepBody('W2[CM]'),
            memory: {
                state: 0
            },
            boostOptions: [null],
            noRepurpose: false,
            operation: this
        });
        return result;
    }
    restorerFunc(creep) {
        if (creep.getActiveBodyparts(CARRY) === 0) {
            console.log('dismissing recoverer - no carry parts');
            this.dismissCreep(creep, true, false);
            return;
        }
        let creepMemory = creep.memory;
        if (creepMemory.state === 0 /* HaulerState.Collecting */ && creep.carry.energy === creep.carryCapacity)
            creepMemory.state = 1 /* HaulerState.Returning */;
        if (creepMemory.state === 1 /* HaulerState.Returning */ && !creep.carry.energy)
            creepMemory.state = 0 /* HaulerState.Collecting */;
        const structures = this.room.find(FIND_STRUCTURES);
        const targets = structures.filter(s => {
            return (s.structureType === STRUCTURE_SPAWN || s.structureType === STRUCTURE_EXTENSION) && s.energy < s.energyCapacity;
        });
        let resources = this.room.find(FIND_DROPPED_RESOURCES).filter(r => r.resourceType === RESOURCE_ENERGY);
        let tombstones = this.room.find(FIND_TOMBSTONES).filter(t => t.store.energy);
        let sourceStructures = structures.filter(s => {
            return (s.structureType === STRUCTURE_STORAGE || s.structureType === STRUCTURE_TERMINAL || s.structureType === STRUCTURE_CONTAINER) && s.store.energy
                || s.structureType === STRUCTURE_LINK && s.energy;
        });
        if (creepMemory.state === 0) {
            const priority1Sources = [...resources, ...sourceStructures, ...tombstones];
            const priority2Sources = this.room.find(FIND_SOURCES_ACTIVE);
            const sources = priority1Sources.length > 0 ? priority1Sources : priority2Sources;
            if (sources.length > 0) {
                let target = _.max(sources, t => Math.min(creep.carryCapacity, (t instanceof Resource ? t.amount : t instanceof Source ? t.energy : t.store.energy)) / creep.pos.getRangeTo(t.pos));
                let isInRange = creep.pos.inRangeTo(target, 1);
                if (isInRange) {
                    if (target instanceof Resource)
                        creep.pickup(target);
                    else if (target instanceof Source) {
                        creep.harvest(target);
                        creep.giveWay({ pos: target.pos, range: 1 });
                    }
                    else
                        creep.withdraw(target, RESOURCE_ENERGY);
                }
                else
                    creep.goTo(target.pos, 1);
            }
        }
        else if (targets.length > 0) {
            let target = creep.pos.findClosestByRange(targets);
            // not in the same room
            if (!target)
                creep.goTo(targets[0].pos, 1);
            else if (creep.pos.inRangeTo(target, 1))
                creep.transfer(target, RESOURCE_ENERGY);
            else {
                creep.goTo(target.pos, 1);
                creep.room.visual.line(creep.pos.x, creep.pos.y, target.pos.x, target.pos.y, { color: '#ff0000', lineStyle: 'dotted', opacity: 0.75, width: 0.1 });
            }
        }
        else if (creep.carry.energy && this.room.storage) {
            if (creep.pos.inRangeTo(this.room.storage, 1))
                creep.transfer(this.room.storage, RESOURCE_ENERGY);
            else
                creep.goTo(this.room.storage.pos, 1);
        }
        else
            creep.giveWay();
    }
    onRun() {
        if (this.parentRoom.isRecoveryNeeded()) {
            for (let creep of this.creeps)
                if (!creep.spawning)
                    this.restorerFunc(creep);
        }
        else {
            for (let creep of this.creeps) {
                if (creep.spawning) {
                    let spawn = creep.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_SPAWN);
                    spawn.spawning.cancel();
                }
                else {
                    console.log('dismissing recoverer - no longer needed');
                    this.dismissCreep(creep, true, true);
                }
            }
        }
    }
}
__decorate([
    profile()
], OperationRecovery.prototype, "restorerFunc", null);
__decorate([
    check,
    profile()
], OperationRecovery.prototype, "onRun", null);

class OperationMaintenance extends BaseRoomOperation {
    static create() {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            uptime: 1
        };
        return memory;
    }
    constructor(parentRoom) {
        super(parentRoom);
        this.creepComposition = {
            body: undefined,
            energyCapacityAvailable: -1
        };
        // TODO - temp
        if (this.memory.uptime === undefined)
            this.memory.uptime = 1;
    }
    get memory() {
        return this.parentRoom.memory.maintenance;
    }
    updateCreepComposition() {
        if (this.room.energyCapacityAvailable !== this.creepComposition.energyCapacityAvailable) {
            const partCount = Math.min(5, Math.floor(this.room.energyCapacityAvailable / (2 * BODYPART_COST[WORK] + 4 * BODYPART_COST[CARRY] + 3 * BODYPART_COST[MOVE])));
            this.creepComposition.energyCapacityAvailable = this.room.energyCapacityAvailable;
            this.creepComposition.body = new CreepBody(`${partCount}[WWCCCCMMM]`);
            this.shouldUpdateEstimatedStats = true;
        }
    }
    //
    getMinimumScale() {
        return (this.room.controller.level < 3 || this.parentRoom.isLowEnergy()) ? 0 : 1;
    }
    getMaximumScale() {
        return (this.room.controller.level < 3 || this.parentRoom.isLowEnergy()) ? 0 : 1;
    }
    // TODO - should update on active modules change
    updateEstimatedStats() {
        const composition = this.creepComposition;
        if (composition.body[WORK] === 0) {
            this.estimatedStats.energyPerTick = 0;
            this.estimatedStats.spawnTime = 0;
            this.estimatedStats.baseCpu = 0;
        }
        else {
            let summedRoadUpkeep = 0;
            const activeModules = ['core', 'upgradeSite', 'extraction', ...this.parentRoom.activeMines];
            for (let id of activeModules) {
                let path = this.parentRoom.layout.getModulePlan(id).road || [];
                // ignoring cost ratio of swamps and tunnels for better CPU
                let repairCost = ROAD_DECAY_AMOUNT / REPAIR_POWER / ROAD_DECAY_TIME;
                let roadUpkeep = repairCost * path.length;
                summedRoadUpkeep += roadUpkeep;
            }
            this.estimatedStats.energyPerTick = -(composition.body.cost / CREEP_LIFE_TIME + summedRoadUpkeep);
            this.estimatedStats.spawnTime = composition.body.spawnTime * this.memory.uptime;
            this.estimatedStats.baseCpu = 0.2 * this.memory.uptime;
        }
    }
    getSpawnRequestsInternal() {
        if (GIntel.rooms[this.parentRoom.roomName].invasion)
            return [];
        if (this.parentRoom.getRepairRequests().length === 0)
            return [];
        if (this.creepComposition.body[WORK] === 0)
            return [];
        if (this.creeps.length > 0)
            return [];
        let result = [];
        result.push({
            id: generateRandomKey(5),
            nameBase: Config.CreepNames.Repairer,
            priority: Priority(0, 11 /* SpawnPriority.REPAIR */),
            minEnergy: 550,
            parts: this.creepComposition.body,
            memory: {},
            boostOptions: [null],
            noRepurpose: false,
            operation: this
        });
        return result;
    }
    assignRepairers() {
        for (let creep of this.creeps) {
            let creepMemory = creep.memory;
            if (!creepMemory.repairedModuleId) {
                let modules = this.parentRoom.getRepairRequests();
                let moduleId = modules.find(id => !this.creeps.find(c => c.memory.repairedModuleId === id));
                if (moduleId) {
                    creepMemory.repairedModuleId = moduleId;
                    creepMemory.state = 0 /* RepairerState.REPAIRING_ROAD */;
                    creepMemory.repairProgress = 0;
                }
            }
        }
    }
    repairerFunc(creep) {
        let creepMemory = creep.memory;
        if (!creepMemory.repairedModuleId) {
            creep.smokeBreak();
            return;
        }
        if (creepMemory.state !== 2 /* RepairerState.FINISHED */ && creep.store.energy < creep.store.getCapacity()) {
            let nonEmptyHauler = creep.pos.lookInRange(LOOK_CREEPS, 1).find(c => c.my && c.memory.role === 1 /* CreepRole.Hauler */ && c.store.energy > 0);
            let nonEmptyContainer = creep.pos.lookInRange(LOOK_STRUCTURES, 1).find(s => s.structureType === STRUCTURE_CONTAINER && s.store.energy > 0);
            if (nonEmptyHauler)
                nonEmptyHauler.transfer(creep, RESOURCE_ENERGY);
            else if (nonEmptyContainer)
                creep.withdraw(nonEmptyContainer, RESOURCE_ENERGY);
        }
        // get energy
        if (creep.store.energy === 0)
            collectEnergy(creep, RESOURCE_ENERGY, this.parentRoom, this.constructor.name);
        // repair
        else {
            creep.say('\u{1F528}');
            const repairPower = creep.getActiveBodyparts(WORK) * REPAIR_POWER;
            const modulePlan = this.parentRoom.layout.getModulePlan(creepMemory.repairedModuleId);
            const structureTypeByState = {
                [0 /* RepairerState.REPAIRING_ROAD */]: STRUCTURE_ROAD,
                [1 /* RepairerState.REPAIRING_CONTAINER */]: STRUCTURE_CONTAINER
            };
            let repairedStructureType = structureTypeByState[creepMemory.state];
            let plan = modulePlan[repairedStructureType] || [];
            while (creepMemory.state !== 2 /* RepairerState.FINISHED */ && creepMemory.repairProgress >= plan.length) {
                ++creepMemory.state;
                creepMemory.repairProgress = 0;
                repairedStructureType = structureTypeByState[creepMemory.state];
                plan = modulePlan[repairedStructureType] || [];
            }
            if (creepMemory.state === 2 /* RepairerState.FINISHED */) {
                creepMemory.repairedModuleId = undefined;
                this.parentRoom.layout.updateModuleStatus();
                return;
            }
            while (creepMemory.repairProgress < plan.length
                && Game.rooms[plan[creepMemory.repairProgress].roomName]
                && !plan[creepMemory.repairProgress].lookFor(LOOK_STRUCTURES).find(s => s.structureType === repairedStructureType)) {
                ++creepMemory.repairProgress;
            }
            if (creepMemory.repairProgress >= plan.length) {
                ++creepMemory.state;
                creepMemory.repairProgress = 0;
                return;
            }
            let targetPos = plan[creepMemory.repairProgress];
            if (creep.pos.inRangeTo(targetPos, 3) && creep.pos.roomName === targetPos.roomName) {
                let structure = targetPos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === repairedStructureType);
                if (structure && structure.hitsMax - structure.hits >= repairPower)
                    creep.repair(structure);
                //
                if (!structure || structure.hitsMax - structure.hits < 2 * repairPower) {
                    ++creepMemory.repairProgress;
                }
                creep.giveWay({ pos: targetPos, range: 3 });
            }
            else if (creep.pos.roomName === targetPos.roomName && creep.pos.isExit()) {
                creep.moveOffExit();
            }
            else {
                creep.goTo(targetPos, 1);
            }
            Common.getRoomVisual(targetPos.roomName).text('\u{1F528}', targetPos.x, targetPos.y);
        }
    }
    onRun() {
        this.updateCreepComposition();
        this.assignRepairers();
        for (let creep of this.creeps)
            this.repairerFunc(creep);
        //
        const thisTickUptime = this.creeps.length > 0
            ? _.sum(this.creeps, c => c.memory.repairedModuleId ? 1 : 0) / this.creeps.length
            : 0;
        this.memory.uptime = rollingAvg(this.memory.uptime, thisTickUptime, OperationMaintenance.UptimeRollingPeriod);
        this.shouldUpdateEstimatedStats = true;
    }
}
// ----------------------------------------------------
OperationMaintenance.UptimeRollingPeriod = 1500;
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationMaintenance.prototype, "getSpawnRequestsInternal", null);
__decorate([
    check,
    profile()
], OperationMaintenance.prototype, "onRun", null);

class OperationScout extends BaseRoomOperation {
    static create() {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            taskQueue: [],
            bans: []
        };
        return memory;
    }
    get observer() {
        return this.roomLayout.observer;
    }
    constructor(parentRoom) {
        super(parentRoom);
        this.roomsToScout = Common.findRoomsInRange(parentRoom.roomName, 10);
        this.roomsToObserve = Common.findRoomsInRange(parentRoom.roomName, 20).filter(roomName => Game.map.getRoomLinearDistance(roomName, parentRoom.roomName) <= OBSERVER_RANGE);
    }
    get memory() {
        return this.parentRoom.memory.scout;
    }
    getMinimumScale() {
        return 1;
    }
    getMaximumScale() {
        return 1;
    }
    updateEstimatedStats() {
        this.estimatedStats.energyPerTick = 0;
        this.estimatedStats.spawnTime = 0;
        this.estimatedStats.baseCpu = 0.2;
    }
    getSpawnRequestsInternal() {
        if (GIntel.rooms[this.parentRoom.roomName].invasion)
            return [];
        if (this.memory.taskQueue.length === 0)
            return [];
        if (this.room.energyCapacityAvailable === 0)
            return [];
        if (this.creeps.length > 2)
            return [];
        if (this.observer && Game.map.getRoomLinearDistance(this.parentRoom.roomName, this.memory.taskQueue[0]) <= OBSERVER_RANGE)
            return [];
        let result = [];
        result.push({
            id: generateRandomKey(5),
            nameBase: Config.CreepNames.Scout,
            priority: Priority(0, 12 /* SpawnPriority.SCOUT */),
            minEnergy: 50,
            parts: new CreepBody('M'),
            memory: {},
            boostOptions: [null],
            noRepurpose: false,
            operation: this
        });
        return result;
    }
    buildTaskQueue() {
        let result = [];
        this.memory.bans = this.memory.bans.filter(b => b.timeout > Game.time);
        const hasObserver = this.room.controller.level === 8 && this.observer;
        const roomsToScout = hasObserver ? this.roomsToObserve : this.roomsToScout;
        for (let roomName of roomsToScout) {
            let roomIntel = GIntel.rooms[roomName];
            if (roomIntel && Game.time - roomIntel.lastScout < OperationScout.ScoutFrequency)
                continue;
            if (this.memory.bans.find(b => b.roomName === roomName))
                continue;
            result.push(roomName);
        }
        result.sort((a, b) => (GIntel.rooms[a] ? GIntel.rooms[a].lastScout : 0) - (GIntel.rooms[b] ? GIntel.rooms[b].lastScout : 0));
        return result;
    }
    scoutFunc(creep) {
        let opts = {
            offroad: true,
            avoidSourceKeepers: true,
            avoidHostileRooms: true,
            avoidUnsafeRooms: true,
            ensurePath: true
        };
        const creepMemory = creep.memory;
        if (creepMemory.currentTask) {
            const currentTaskRoomIntel = GIntel.rooms[creepMemory.currentTask.roomName];
            if ((currentTaskRoomIntel && Game.time - currentTaskRoomIntel.lastScout < OperationScout.ScoutFrequency) || Game.time > creepMemory.currentTask.timeout)
                creepMemory.currentTask = undefined;
        }
        if (!creepMemory.currentTask) {
            if (this.memory.taskQueue.length > 0) {
                creepMemory.currentTask = {
                    roomName: this.memory.taskQueue.shift(),
                    timeout: Game.time + 500
                };
            }
        }
        if (creepMemory.currentTask) {
            creep.say(creepMemory.currentTask.roomName, false);
            let gotoResult = creep.goToRoom(creepMemory.currentTask.roomName, opts);
            if (gotoResult === ERR_NO_PATH) {
                this.memory.bans.push({
                    roomName: creepMemory.currentTask.roomName,
                    timeout: Game.time + 500
                });
                creepMemory.currentTask = null;
            }
        }
        else {
            creep.smokeBreak();
        }
    }
    onRun() {
        if (this.memory.taskQueue.length === 0 && Game.time % 10 === 0) {
            this.memory.taskQueue = this.buildTaskQueue();
        }
        const hasObserver = this.room.controller.level === 8 && this.observer;
        if (hasObserver) {
            for (let creep of this.creeps)
                creep.suicide();
            if (this.memory.taskQueue.length > 0) {
                let result = this.observer.observeRoom(this.memory.taskQueue.shift());
                if (result !== OK)
                    console.log(this.roomName, 'observeRoom failed', result);
            }
        }
        else {
            for (let creep of this.creeps)
                if (!creep.spawning)
                    this.scoutFunc(creep);
        }
    }
}
// ----------------------------------------------------
OperationScout.ScoutFrequency = 500;
__decorate([
    check,
    profile()
], OperationScout.prototype, "onRun", null);

class OperationReinforcement extends BaseRoomOperation {
    static create() {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0
        };
        return memory;
    }
    constructor(parentRoom) {
        super(parentRoom);
        this.creepComposition = {
            body: undefined,
            energycapacityAvailable: -1
        };
    }
    get memory() {
        return this.parentRoom.memory.reinforcement;
    }
    updateCreepComposition() {
        if (this.creepComposition.energycapacityAvailable !== this.room.energyCapacityAvailable) {
            const creepSize = Math.min(5, Math.floor(this.room.energyCapacityAvailable / (4 * BODYPART_COST[WORK] + 2 * BODYPART_COST[CARRY] + 3 * BODYPART_COST[MOVE])));
            this.creepComposition.energycapacityAvailable = this.room.energyCapacityAvailable;
            this.creepComposition.body = new CreepBody(`${creepSize}[WWWWCCMMM]`);
            this.shouldUpdateEstimatedStats = true;
        }
    }
    //
    getMinimumScale() {
        let targetBarrier = this.parentRoom.getTargetBarrier();
        let requireMoreRepairers = this.room.memory.invasion && this.roomLayout.barrierStatus.avgHits < targetBarrier;
        let minBelowTarget = this.roomLayout.barrierStatus.minHits < targetBarrier;
        if (this.room.terminal && requireMoreRepairers && this.parentRoom.getEnergyAmount() > 200000)
            return 6;
        else if (this.room.terminal && requireMoreRepairers && this.parentRoom.getEnergyAmount() > 100000)
            return 2;
        else if (minBelowTarget)
            return 1;
        else
            return 0;
    }
    getMaximumScale() {
        if (this.room.find(FIND_NUKES).length > 0)
            return 6;
        let targetBarrier = this.parentRoom.getTargetBarrier();
        let minBelowTarget = this.roomLayout.barrierStatus.minHits < targetBarrier;
        let avgBelowTarget = this.roomLayout.barrierStatus.avgHits < targetBarrier;
        let allowMoreRepairers = (this.room.memory.invasion || avgBelowTarget);
        if (allowMoreRepairers && this.parentRoom.getEnergyAmount() > 200000)
            return 6;
        else if (allowMoreRepairers && this.parentRoom.getEnergyAmount() > 100000)
            return 2;
        else if (minBelowTarget)
            return 1;
        else
            return 0;
    }
    // TODO - update on rampart amount change
    updateEstimatedStats() {
        let creepCost = this.creepComposition.body.cost;
        if (creepCost === 0 || this.roomLayout.walls.length + this.roomLayout.ramparts.length === 0) {
            this.estimatedStats.energyPerTick = 0;
            this.estimatedStats.spawnTime = 0;
            this.estimatedStats.baseCpu = 0;
        }
        else {
            const repairingUptimeMN = 0.8;
            const maxCreepOutput = repairingUptimeMN * this.creepComposition.body.work; // * REPAIR_POWER * REPAIR_COST;
            const rampartMaintanenceCost = RAMPART_DECAY_AMOUNT / RAMPART_DECAY_TIME / REPAIR_POWER;
            const targetBarrier = this.parentRoom.getTargetBarrier();
            const averageHits = (_.sum(this.roomLayout.walls, w => w.hits) + _.sum(this.roomLayout.ramparts, r => r.hits)) / (this.roomLayout.ramparts.length + this.roomLayout.walls.length);
            if (averageHits < targetBarrier) {
                this.estimatedStats.energyPerTick = -(maxCreepOutput + creepCost / CREEP_LIFE_TIME);
                this.estimatedStats.spawnTime = this.creepComposition.body.spawnTime;
                this.estimatedStats.baseCpu = 0.2;
            }
            else {
                let uptime = rampartMaintanenceCost / maxCreepOutput;
                this.estimatedStats.energyPerTick = -(rampartMaintanenceCost * this.roomLayout.ramparts.length + creepCost / CREEP_LIFE_TIME * uptime);
                this.estimatedStats.spawnTime = this.creepComposition.body.spawnTime;
                this.estimatedStats.baseCpu = 0.2 * uptime;
            }
        }
    }
    getSpawnRequestsInternal() {
        if (this.creeps.length >= this.targetScale)
            return [];
        if (this.creepComposition.body.work === 0)
            return [];
        if (this.roomLayout.walls.length === 0 && this.roomLayout.ramparts.length === 0)
            return [];
        let targetBarrier = this.parentRoom.getTargetBarrier();
        if (this.roomLayout.barrierStatus.minHits >= targetBarrier)
            return [];
        //
        let boostOptions;
        if (this.room.memory.invasion || this.roomLayout.barrierStatus.avgHits < targetBarrier)
            boostOptions = [[RES_XLH2O], [RES_LH2O], [RES_LH], null];
        else
            boostOptions = [null];
        let spawnPriority = Priority(0, 13 /* SpawnPriority.REINFORCE */ - this.creeps.length / 1000);
        let result = [];
        result.push({
            id: generateRandomKey(5),
            nameBase: Config.CreepNames.Reinforcer,
            priority: spawnPriority,
            parts: this.creepComposition.body,
            minEnergy: this.creepComposition.body.cost,
            boostOptions: boostOptions,
            memory: {},
            noRepurpose: false,
            operation: this
        });
        return result;
    }
    findNewTarget() {
        const importantStructures = [
            STRUCTURE_SPAWN,
            STRUCTURE_STORAGE,
            STRUCTURE_TERMINAL,
            STRUCTURE_TOWER,
            STRUCTURE_LAB,
            // just because they are expensive
            STRUCTURE_NUKER,
            STRUCTURE_POWER_SPAWN,
            // just so it's higher than roads and nothing
            STRUCTURE_EXTENSION
        ];
        const nukes = this.room.find(FIND_NUKES);
        const barriers = [...this.roomLayout.ramparts, ...this.roomLayout.walls];
        let minBarrierScore = Infinity;
        let minBarrier = undefined;
        let minBarrierImportantStructurePriority = Infinity;
        for (let b of barriers) {
            if (this.room.memory.invasion && b.pos.isNearTo(this.room.controller.pos))
                continue;
            let score = b.hits - _.sum(nukes, n => n.pos.isEqualTo(b.pos) ? NUKE_DAMAGE[0] : n.pos.inRangeTo(b.pos, 2) ? NUKE_DAMAGE[2] : 0);
            let importantStructure = b.pos.lookFor(LOOK_STRUCTURES).find(s => importantStructures.includes(s.structureType));
            if (score < 0 && importantStructure) {
                let index = importantStructures.indexOf(importantStructure.structureType);
                if (minBarrierImportantStructurePriority > index) {
                    minBarrierImportantStructurePriority = index;
                    minBarrierScore = score;
                    minBarrier = b;
                }
            }
            else if (minBarrierScore > score && minBarrierImportantStructurePriority === Infinity) {
                minBarrierScore = score;
                minBarrier = b;
            }
        }
        if (minBarrier.hits)
            return minBarrier;
        else
            return undefined;
    }
    reinforcerFunc(creep) {
        if (creep.memory.boosts) {
            this.boostCreep(creep);
            return;
        }
        let creepMemory = creep.memory;
        if (creep.carry.energy === 0) {
            collectEnergy(creep, RESOURCE_ENERGY, this.parentRoom, this.constructor.name);
            creepMemory.targetId = undefined;
            return;
        }
        if (creep.room === this.room && creep.ticksToLive < 3 * creep.pos.getRangeTo(this.parentRoom.layout.roomPlan.pos) && creep.body.find(b => !!b.boost))
            this.dismissCreep(creep, true, false);
        let target = Game.getObjectById(creepMemory.targetId);
        if (!target) {
            let newTarget = this.findNewTarget();
            if (newTarget) {
                creepMemory.targetId = newTarget.id;
                target = newTarget;
            }
        }
        if (!target) {
            this.dismissCreep(creep, true, false);
            return;
        }
        if (creep.pos.inRangeTo(target.pos, 3)) {
            creep.repair(target);
            if (creep.pos.isExit())
                creep.moveOffExit();
            else
                creep.giveWay({ pos: target.pos, range: 3 });
        }
        else {
            let goToResult = creep.goTo(target.pos, 3, { stayUnderRampart: !!this.room.memory.invasion });
            if (goToResult === ERR_NO_PATH)
                creepMemory.targetId = undefined;
        }
    }
    onRun() {
        this.updateCreepComposition();
        for (let creep of this.creeps)
            this.reinforcerFunc(creep);
        // TEMP
        //let target = this.findNewTarget();
        //if (target) {
        //  for (let tower of this.roomLayout.towers)
        //    tower.repair(target);
        //  this.parentRoom.updateTowerDistributionRequests();
        //}
    }
}
// ----------------------------------------------------
OperationReinforcement.fortifyListUpdateCooldown = RAMPART_DECAY_TIME;
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationReinforcement.prototype, "getSpawnRequestsInternal", null);
__decorate([
    check,
    profile()
], OperationReinforcement.prototype, "onRun", null);

class OperationBoostPickup extends BaseRoomOperation {
    static create() {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0
        };
        return memory;
    }
    constructor(parentRoom) {
        super(parentRoom);
        this.targets = [];
    }
    get memory() {
        return this.parentRoom.memory.boostPickup;
    }
    getMinimumScale() {
        return this.parentRoom.room.storage ? 1 : 0;
    }
    getMaximumScale() {
        return this.parentRoom.room.storage ? 1 : 0;
    }
    updateEstimatedStats() {
        this.estimatedStats.energyPerTick = 0;
        this.estimatedStats.spawnTime = 0;
        this.estimatedStats.baseCpu = 0;
    }
    getSpawnRequestsInternal() {
        if (this.targets.length === 0)
            return [];
        if (!this.room.storage)
            return [];
        if (this.creeps.length > this.targets.length)
            return [];
        let result = [];
        const spawnPriority = Priority(0, 21 /* SpawnPriority.BOOST_PICKUP */);
        let janitorBody = new CreepBody(`${2}[CM]`);
        result.push({
            id: generateRandomKey(5),
            nameBase: this.roomName + '_Janitor',
            priority: spawnPriority,
            minEnergy: janitorBody.cost,
            parts: janitorBody,
            memory: {},
            boostOptions: [null],
            noRepurpose: false,
            operation: this
        });
        return result;
    }
    udpateDroppedBoosts() {
        this.targets = [];
        if (this.room && Game.time - this.room.intel.lastUnsafe > 10) {
            const droppedResources = this.room.find(FIND_DROPPED_RESOURCES).filter(r => r.resourceType !== RES_ENERGY);
            for (let resource of droppedResources)
                this.targets.push(resource.pos);
            const tombstones = this.room.find(FIND_TOMBSTONES).filter(t => t.store.getUsedCapacity() > t.store.getUsedCapacity(RES_ENERGY));
            for (let tombstone of tombstones)
                this.targets.push(tombstone.pos);
        }
        for (let outpost of this.parentRoom.activeOutposts) {
            let room = Game.rooms[outpost.roomName];
            if (room && Game.time - room.intel.lastUnsafe > 10) {
                const droppedResources = room.find(FIND_DROPPED_RESOURCES).filter(r => r.resourceType !== RES_ENERGY);
                for (let resource of droppedResources)
                    this.targets.push(resource.pos);
                const tombstones = room.find(FIND_TOMBSTONES).filter(t => t.store.getUsedCapacity() > t.store.getUsedCapacity(RES_ENERGY));
                for (let tombstone of tombstones)
                    this.targets.push(tombstone.pos);
            }
        }
    }
    onRun() {
        if (Memory.toggles.pickupInvaderLoot)
            this.udpateDroppedBoosts();
        if (this.currentTarget && Game.rooms[this.currentTarget.roomName]) {
            let resource = this.currentTarget.lookFor(LOOK_RESOURCES).find(r => r.resourceType !== RES_ENERGY);
            let tombstone = this.currentTarget.lookFor(LOOK_TOMBSTONES).find(t => t.store.getUsedCapacity() > t.store.getUsedCapacity(RES_ENERGY));
            if (!tombstone && !resource) {
                this.currentTarget = null;
                this.udpateDroppedBoosts();
            }
        }
        for (let creep of this.creeps) {
            if (!this.currentTarget && creep.store.getFreeCapacity() > 0 && this.targets.length > 0) {
                const targetNextToCreep = this.targets.find(t => creep.pos.isNearTo(t));
                if (targetNextToCreep) {
                    this.currentTarget = targetNextToCreep;
                }
                else {
                    const searchResult = Pather.findPathToClosest(creep.pos, this.targets.map(pos => ({ pos: pos, range: 1 })));
                    const lastStep = _.last(searchResult.path);
                    this.currentTarget = this.targets.find(t => lastStep.isNearTo(t));
                }
            }
            if (creep.store.getUsedCapacity() > 0
                && this.room.storage
                && (creep.store.getFreeCapacity() === 0 || !this.currentTarget || creep.pos.isNearTo(this.room.storage))) {
                if (creep.pos.isNearTo(this.room.storage.pos)) {
                    creep.transfer(this.room.storage, _.findKey(creep.store));
                    creep.giveWay();
                }
                else {
                    creep.goTo(this.room.storage.pos, 1);
                }
            }
            else if (this.currentTarget && creep.store.getFreeCapacity() > 0) {
                if (creep.pos.isNearTo(this.currentTarget)) {
                    let resource = this.currentTarget.lookFor(LOOK_RESOURCES).find(r => r.resourceType !== RES_ENERGY);
                    let tombstone = this.currentTarget.lookFor(LOOK_TOMBSTONES).find(t => t.store.getUsedCapacity() > t.store.getUsedCapacity(RES_ENERGY));
                    if (resource) {
                        creep.pickup(resource);
                    }
                    else if (tombstone) {
                        const tombstoneResource = _.findKey(tombstone.store, (amount, resourceType) => resourceType !== RES_ENERGY);
                        if (tombstoneResource) {
                            creep.withdraw(tombstone, tombstoneResource);
                        }
                    }
                    creep.giveWay();
                }
                else {
                    creep.room.visual.multiRoomLine(creep.pos, this.currentTarget, { color: '#ffffff', lineStyle: 'dashed', width: 0.1 });
                    creep.goTo(this.currentTarget, 1);
                }
            }
            else {
                this.dismissCreep(creep, true, true);
            }
        }
    }
}
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationBoostPickup.prototype, "getSpawnRequestsInternal", null);
__decorate([
    check,
    profile()
], OperationBoostPickup.prototype, "onRun", null);

var InvasionType;
(function (InvasionType) {
    InvasionType[InvasionType["Invaders"] = 0] = "Invaders";
    InvasionType[InvasionType["Player"] = 1] = "Player";
})(InvasionType || (InvasionType = {}));
var Status;
(function (Status) {
    Status[Status["Rallying"] = 0] = "Rallying";
    Status[Status["Moving"] = 1] = "Moving";
    Status[Status["Cleaning"] = 2] = "Cleaning";
    Status[Status["Idle"] = 3] = "Idle";
})(Status || (Status = {}));
class OperationPeacekeeping extends BaseRoomOperation {
    static create() {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0
        };
        return memory;
    }
    constructor(memory, parentRoom, outpostRoom) {
        super(parentRoom);
        this.outpostRoom = outpostRoom;
    }
    get memory() {
        return this.outpostRoom.memory.peacekeeping;
    }
    getMinimumScale() {
        return 1;
    }
    getMaximumScale() {
        return 1;
    }
    updateEstimatedStats() {
        if (!this.clearTask) {
            this.estimatedStats.energyPerTick = 0;
            this.estimatedStats.spawnTime = 0;
            this.estimatedStats.baseCpu = 0;
        }
        else {
            this.estimatedStats.energyPerTick = -this.clearTask.peacekeeperBody.cost * this.clearTask.squadSize / CREEP_LIFE_TIME;
            this.estimatedStats.spawnTime = this.clearTask.squadSize * this.clearTask.peacekeeperBody.spawnTime;
            this.estimatedStats.baseCpu = 0.2 * this.clearTask.squadSize;
        }
    }
    calculatePeacekeepingForceNeeded(invasion) {
        let invasionHealingEffectiveness = (invasion.owner === 'Invader' ? 0.4 : 1);
        let dmgNeeded = invasion.heal / invasion.dmgMultiplier * invasionHealingEffectiveness;
        let healNeeded = invasion.rangedAttack;
        let attackPartsNeeded = Math.ceil((dmgNeeded + invasion.bodyparts * 5) / RANGED_ATTACK_POWER);
        let healPartsNeeded = Math.ceil(healNeeded / HEAL_POWER);
        return {
            ranged_attack: attackPartsNeeded,
            heal: healPartsNeeded,
            move: attackPartsNeeded + healPartsNeeded
        };
    }
    getSpawnRequestsInternal() {
        if (!this.outpostRoom.isActive)
            return [];
        const spawnPriority = Priority(this.outpostRoom.index + 1, 20 /* SpawnPriority.PEACEKEEPING */);
        let result = [];
        let task = this.clearTask;
        if (task && task.status === Status.Rallying) {
            let creepsNeeded = task.squadSize - this.creeps.length;
            for (let i = 0; i < creepsNeeded; ++i) {
                result.push({
                    id: generateRandomKey(5),
                    nameBase: this.roomName + '_Peacekeeper',
                    priority: spawnPriority,
                    minEnergy: task.peacekeeperBody.cost,
                    parts: task.peacekeeperBody,
                    memory: {},
                    boostOptions: [null],
                    noRepurpose: false,
                    operation: this
                });
            }
        }
        return result;
    }
    getRally(roomName) {
        let opts = {
            avoidHostileRooms: true
        };
        let startPos = this.parentRoom.getCollectionPoint();
        let goal = {
            pos: new RoomPosition(25, 25, roomName),
            range: 23
        };
        let searchResult = Pather.findPath(startPos, goal, opts);
        if (searchResult.incomplete) {
            console.log("Couldn't find path for peacekeepers - last pos:", _.last(searchResult.path));
            return null;
        }
        let path = searchResult.path;
        let exitIndex = path.findIndex(pos => pos.roomName === roomName);
        let nodes = [
            path[exitIndex - 2]
        ];
        let rallyTest = (pos) => {
            let terrain = Game.map.getRoomTerrain(pos.roomName);
            let room = Game.rooms[pos.roomName];
            for (let rallyX = pos.x; rallyX < pos.x + 2; ++rallyX)
                for (let rallyY = pos.y; rallyY < pos.y + 2; ++rallyY) {
                    if (rallyX < 0 || rallyX > 49 || rallyY < 0 || rallyY > 49)
                        return false;
                    if (Common.isExit(rallyX, rallyY, pos.roomName))
                        return false;
                    if ((terrain.get(rallyX, rallyY) & TERRAIN_MASK_WALL) > 0)
                        return false;
                    if (room && room.lookForAt(LOOK_STRUCTURES, rallyX, rallyY).find(s => OBSTACLE_STRUCTURE_TYPES.has(s.structureType)))
                        return false;
                }
            return true;
        };
        let checked = [];
        do {
            let node = nodes.shift();
            for (let dir in Common.offset) {
                let newNode = node.nextPosition(parseInt(dir));
                if (!newNode)
                    continue;
                let newNodeHash = newNode.y * 50 + newNode.x;
                if (checked.indexOf(newNodeHash) !== -1)
                    continue;
                if (rallyTest(newNode))
                    return newNode;
                checked.push(newNode.y * 50 + newNode.x);
                nodes.push(newNode);
            }
        } while (nodes.length > 0);
        // shouldn't happen ever
        return null;
    }
    createClearTask() {
        for (let mine of this.outpostRoom.operationMine) {
            let mineRoadStatus = mine.roomLayout.moduleStatus[mine.id];
            // TODO - pathRooms shouldn't be part of status, and should be always available
            if (!mineRoadStatus)
                return null;
            // don't defend when there is invasion in a room between spawn and outpost
            for (let i = 0; i < mineRoadStatus.pathRooms.length - 1; ++i)
                if (GIntel.rooms[mineRoadStatus.pathRooms[i]].invasion)
                    return null;
        }
        let invadedRoomName = this.outpostRoom.roomName;
        let invasion = GIntel.rooms[invadedRoomName].invasion;
        let peaceKeepingForceNeeded = this.calculatePeacekeepingForceNeeded(invasion);
        let energyAvailable = this.room.energyCapacityAvailable;
        let squadCost = getCreepCost(peaceKeepingForceNeeded);
        let squadParts = _.sum(peaceKeepingForceNeeded);
        let squadSize = Math.max(Math.ceil(squadCost / energyAvailable), Math.ceil(squadParts / MAX_CREEP_SIZE));
        if (squadSize > OperationPeacekeeping.MaxSquadSize)
            return null;
        let rally = this.getRally(invadedRoomName);
        if (!rally)
            return null;
        const rangedAttack = Math.max(1, Math.floor(peaceKeepingForceNeeded.ranged_attack / squadSize));
        const heal = Math.floor(peaceKeepingForceNeeded.heal / squadSize);
        const move = Math.max(1, Math.floor(peaceKeepingForceNeeded.move / squadSize));
        if (!_.isFinite(rangedAttack) || !_.isFinite(heal) || !_.isFinite(move)) {
            console.log('room:', this.roomName, 'outpost:', this.outpostRoom.roomName, 'peacekeeper body is:', 'R:', rangedAttack, 'H:', heal, 'M:', move, '<br/>', 'squadSize:', squadSize, '<br/>', 'peaceKeepingForceNeeded:', 'R:', peaceKeepingForceNeeded.ranged_attack, 'H:', peaceKeepingForceNeeded.heal, 'M:', peaceKeepingForceNeeded.move, '<br/>');
            return null;
        }
        let body = new CreepBody(`${rangedAttack ? (rangedAttack + 'R') : ''}${move ? (move + 'M') : ''}${heal ? (heal + 'H') : ''}`);
        let result = {
            roomName: invadedRoomName,
            invasionType: invasion.owner === 'Invader' ? InvasionType.Invaders : InvasionType.Player,
            peacekeeperBody: body,
            squadSize: squadSize,
            status: Status.Rallying,
            rally: rally.serialize()
        };
        return result;
    }
    fulfillTask() {
        let peacekeepers = this.creeps.filter(c => !c.body.find(bp => bp.type === ATTACK));
        let task = this.clearTask;
        if (!task) {
            for (let peacekeeper of peacekeepers)
                this.dismissCreep(peacekeeper, false, true);
            return;
        }
        if (peacekeepers.length === 0) {
            task.status = Status.Rallying;
            return;
        }
        if (task.status === Status.Rallying && peacekeepers.length >= task.squadSize && peacekeepers.every((creep, i, a) => creep.pos.isNearTo(a[(i + 1) % task.squadSize])))
            task.status = Status.Moving;
        if (task.status === Status.Moving && peacekeepers.every(creep => creep.pos.roomName === task.roomName))
            task.status = Status.Cleaning;
        if (task.status === Status.Rallying) {
            const rallyOpts = {
                ignoreRoads: true,
                avoidSourceKeepers: true,
                avoidHostileRooms: true
            };
            let squadRally = RoomPosition.deserialize(task.rally);
            for (let i = 0; i < peacekeepers.length; ++i) {
                let creep = peacekeepers[i];
                let creepRally = new RoomPosition(squadRally.x + i % 2, squadRally.y + Math.floor(i / 2), squadRally.roomName);
                if (creep.pos.isEqualTo(creepRally))
                    creep.giveWay(true);
                else
                    creep.goTo(creepRally, 0, rallyOpts);
                creep.shootAtWill(creep.room.findHostileCreeps());
            }
        }
        else if (task.status === Status.Moving) {
            let leader = peacekeepers[0];
            let movingOpts = {
                dontIgnoreCreeps: true,
                squadMembers: peacekeepers.slice(1)
            };
            CombatPather.goTo(leader, new RoomPosition(25, 25, task.roomName), 22, movingOpts);
            for (let creep of peacekeepers)
                creep.shootAtWill(creep.room.findHostileCreeps());
        }
        else if (task.status === Status.Cleaning) {
            let taskRoom = Game.rooms[task.roomName];
            if (!taskRoom) {
                task.status = Status.Idle;
                return;
            }
            let invaders = taskRoom.findHostileCreeps().filter(hostile => hostile.owner.username !== 'Source Keeper');
            if (invaders.length === 0) {
                task.status = Status.Idle;
                return;
            }
            let leader = peacekeepers[0];
            let squadMembers = peacekeepers.slice(1);
            let target = _.min(invaders, invader => !invader.pos.isExit() ? (invader.hits / invader.hitsMax) * leader.pos.getRangeTo(invader.pos) : Infinity);
            let desiredDistance = (target.getActiveBodyparts(ATTACK) > target.getActiveBodyparts(RANGED_ATTACK) / 2) ? 3 : 2;
            let fleeDistance = 5;
            let avoidDamage = _.sum(peacekeepers, c => c.getActiveBodyparts(HEAL) * HEAL_POWER + c.getActiveBodyparts(RANGED_ATTACK) * RANGED_ATTACK_POWER);
            let cleaningOpts = {
                avoidDamage: avoidDamage,
                maxRooms: 2,
                squadMembers: squadMembers
            };
            let fleeOpts = {
                avoidDamage: avoidDamage,
                maxRooms: 2,
                squadMembers: squadMembers,
                flee: true
            };
            const distanceToTarget = leader.pos.getRangeTo(target);
            if (distanceToTarget > desiredDistance)
                CombatPather.goTo(leader, target.pos, desiredDistance, cleaningOpts);
            else if (distanceToTarget < desiredDistance)
                CombatPather.goTo(leader, target.pos, fleeDistance, fleeOpts);
            let lowest = _.max(peacekeepers, creep => creep.hitsMax - creep.hits);
            for (let creep of peacekeepers) {
                creep.shootAtWill(invaders);
                if (lowest.hits < lowest.hitsMax)
                    creep.heal(lowest);
            }
        }
        else // if (task.status === Status.Idle)
         {
            if (task.invasionType === InvasionType.Invaders) {
                for (let creep of peacekeepers)
                    this.dismissCreep(creep, true, true);
            }
            for (let creep of peacekeepers)
                creep.smokeBreak();
        }
    }
    onRun() {
        const invasion = GIntel.rooms[this.outpostRoom.roomName].invasion;
        if (this.outpostRoom.isActive && invasion && invasion.owner === 'Invader') {
            let newTask = this.createClearTask();
            if (!newTask && this.clearTask && this.clearTask.status === Status.Idle) {
                this.clearTask = undefined;
                this.shouldUpdateEstimatedStats = true;
            }
            else if (newTask && (!this.clearTask || this.clearTask.status === Status.Idle || this.clearTask.status === Status.Rallying)) {
                this.clearTask = newTask;
                this.shouldUpdateEstimatedStats = true;
            }
        }
        else {
            if (this.clearTask) {
                this.clearTask = undefined;
                this.shouldUpdateEstimatedStats = true;
            }
        }
        this.fulfillTask();
    }
}
// ----------------------------------------------------
OperationPeacekeeping.MaxSquadSize = 4;
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationPeacekeeping.prototype, "getSpawnRequestsInternal", null);
__decorate([
    check,
    profile()
], OperationPeacekeeping.prototype, "onRun", null);

class OperationSKClear extends BaseRoomOperation {
    static create() {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0
        };
        return memory;
    }
    constructor(memory, parentRoom, outpostRoom) {
        super(parentRoom);
        this.memory = memory;
        this.outpostRoom = outpostRoom;
        this.keeperSpots = [...GIntel.rooms[this.outpostRoom.roomName].sourceKeeperSpots];
    }
    getMinimumScale() {
        return 1;
    }
    getMaximumScale() {
        return 1;
    }
    updateEstimatedStats() {
        this.estimatedStats.energyPerTick = -OperationSKClear.keeperSlayerBody.cost / CREEP_LIFE_TIME;
        this.estimatedStats.spawnTime = OperationSKClear.keeperSlayerBody.spawnTime;
        this.estimatedStats.baseCpu = 0.4;
    }
    getSpawnRequestsInternal() {
        if (!this.outpostRoom.isActive)
            return [];
        if (this.creeps.length > 0 && this.creeps.some(c => c.spawning || c.ticksToLive > c.body.length * CREEP_SPAWN_TIME))
            return [];
        let result = [];
        result.push({
            id: generateRandomKey(5),
            nameBase: Config.CreepNames.KeeperSlayer,
            priority: Priority(this.outpostRoom.index + 1, 19 /* SpawnPriority.SK_CLEAR */),
            minEnergy: OperationSKClear.keeperSlayerBody.cost,
            parts: OperationSKClear.keeperSlayerBody,
            memory: {
                routePointIndex: 0
            },
            boostOptions: [null],
            noRepurpose: false,
            operation: this
        });
        return result;
    }
    get route() {
        if (this._route)
            return this._route;
        console.log('update SK routes in', this.outpostRoom.roomName);
        //
        let distances = {};
        for (let i = 0; i < this.keeperSpots.length; ++i)
            for (let j = i + 1; j < this.keeperSpots.length; ++j) {
                let pos1 = this.keeperSpots[i];
                let pos2 = this.keeperSpots[j];
                let distance = Pather.findPath(pos1, { pos: pos2, range: 0 }, OperationSKClear.goToOpts).path.length;
                distances[pos1.serialize() + pos2.serialize()] = distance;
                distances[pos2.serialize() + pos1.serialize()] = distance;
            }
        // assume there are always 4 keeper spots
        const permutations = [
            [...this.keeperSpots],
            [this.keeperSpots[0], this.keeperSpots[1], this.keeperSpots[3], this.keeperSpots[2]],
            [this.keeperSpots[0], this.keeperSpots[2], this.keeperSpots[1], this.keeperSpots[3]]
        ];
        let bestPermutation = undefined;
        let bestPermutationDistance = Infinity;
        for (let permutation of permutations) {
            let distance = 0;
            for (let i = 0; i < permutation.length; ++i) {
                let pos1 = permutation[i];
                let pos2 = permutation[(i + 1) % permutation.length];
                distance += distances[pos1.serialize() + pos2.serialize()];
            }
            if (distance < bestPermutationDistance) {
                bestPermutation = permutation;
                bestPermutationDistance = distance;
            }
        }
        this._route = bestPermutation;
        return this._route;
    }
    keeperSlayerFunc(creep) {
        const creepMemory = creep.memory;
        const route = this.route;
        //
        let currentPointPos = route[creepMemory.routePointIndex];
        let currentPointRoom = Game.rooms[currentPointPos.roomName];
        let hurtCreep = currentPointRoom
            ? currentPointRoom.find(FIND_MY_CREEPS).find(c => c.id !== creep.id && c.my && c.hits < c.hitsMax && currentPointPos.inRangeTo(c.pos, 5))
            : null;
        let keeper = currentPointRoom
            ? currentPointRoom.findHostileCreeps().find(c => currentPointPos.inRangeTo(c.pos, 3) && c.owner.username === 'Source Keeper')
            : null;
        let keeperTombstoneInRange = currentPointRoom
            ? currentPointPos.lookInRange(LOOK_TOMBSTONES, 5).find(c => c.creep.owner.username === 'Source Keeper')
            : null;
        //
        if (keeperTombstoneInRange && creepMemory.fought) {
            creepMemory.goToNextPos = true;
            creepMemory.fought = false;
        }
        if (!hurtCreep && creepMemory.goToNextPos) {
            creepMemory.goToNextPos = false;
            creepMemory.routePointIndex = (creepMemory.routePointIndex + 1) % route.length;
        }
        // attack / heal self / heal hurt creeps in range
        if (keeper && creep.pos.isNearTo(keeper) && creep.getActiveBodyparts(ATTACK) > 0) {
            creep.attack(keeper);
            creepMemory.fought = true;
        }
        else if (keeper && (creep.hits < creep.hitsMax || creep.pos.inRangeTo(keeper, 3))) {
            creep.heal(creep);
        }
        else if (!keeper && hurtCreep && creep.pos.isNearTo(hurtCreep)) {
            creep.heal(hurtCreep);
        }
        else if (!keeper && hurtCreep && creep.getActiveBodyparts(MOVE) < 5) {
            creep.heal(creep);
        }
        else if (!keeper && hurtCreep && creep.pos.inRangeTo(hurtCreep, 3)) {
            creep.rangedHeal(hurtCreep);
        }
        else if (creep.hits < creep.hitsMax) {
            creep.heal(creep);
        }
        // go to
        // source keeper might pick different spot if his default one is occupied by creep, because his moveTo(source, range: 1) doesn't ignore creeps
        let isKeeperInAlternateLocation = keeper && (keeper.pos.lookInRange(LOOK_MINERALS, 1).length > 0 || (keeper.pos.lookInRange(LOOK_SOURCES, 1).length > 0));
        if (keeper && (keeper.getActiveBodyparts(MOVE) === 0 || isKeeperInAlternateLocation) && !creep.pos.isNearTo(keeper)) {
            creep.goTo(keeper.pos, 1, OperationSKClear.goToOpts);
        }
        else if (!keeper && hurtCreep) {
            creep.goTo(hurtCreep.pos, 1, OperationSKClear.goToOpts);
        }
        else if (!creep.pos.isNearTo(currentPointPos)) {
            creep.goTo(currentPointPos, 1, OperationSKClear.goToOpts);
        }
        else {
            creep.giveWay();
        }
    }
    onRun() {
        for (let creep of this.creeps)
            if (!creep.spawning)
                this.keeperSlayerFunc(creep);
    }
}
// ----------------------------------------------------
OperationSKClear.goToOpts = {
    avoidSourceKeepers: false,
    ignoreRoads: true
};
OperationSKClear.keeperSlayerBody = new CreepBody('25M16A9H');
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationSKClear.prototype, "getSpawnRequestsInternal", null);
__decorate([
    check,
    profile()
], OperationSKClear.prototype, "onRun", null);

class OperationReserve extends BaseRoomOperation {
    static create(parentRoom, outpostRoom) {
        let distanceToController = undefined;
        if (Common.isControllerRoom(outpostRoom.roomName)) {
            let controllerPos = GIntel.rooms[outpostRoom.roomName].controllerPos;
            let searchResult = PathFinder.search(parentRoom.getCollectionPoint(), { pos: controllerPos, range: 1 }, { maxOps: 20000, plainCost: 1, swampCost: 5 });
            if (!searchResult.incomplete)
                distanceToController = searchResult.path.length;
        }
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            distanceToController: distanceToController
        };
        return memory;
    }
    constructor(parentRoom, outpostRoom) {
        super(parentRoom);
        this.outpostRoom = outpostRoom;
        this.controllerPos = GIntel.rooms[outpostRoom.roomName].controllerPos;
        this.creepComposition = {
            body: undefined,
            maxCreepCount: 0,
            energyCapactityAvailable: 0,
            useSmallReservers: false
        };
        this.updateCreepComposition();
    }
    get memory() {
        return this.outpostRoom.memory.reserve;
    }
    onInitForTick() {
        for (let creep of this.creeps)
            if (creep.room.controller && creep.pos.isNearTo(creep.room.controller))
                Pather.addObstacle(creep.pos);
    }
    getMinimumScale() {
        return 1;
    }
    getMaximumScale() {
        return 1;
    }
    updateEstimatedStats() {
        const claimerCost = BODYPART_COST[MOVE] + BODYPART_COST[CLAIM];
        const canSpawnClaimer = (this.room.energyCapacityAvailable >= claimerCost);
        if (!canSpawnClaimer) {
            this.estimatedStats.energyPerTick = 0;
            this.estimatedStats.spawnTime = 0;
            this.estimatedStats.baseCpu = 0;
        }
        else {
            const claimerWorkTime = CREEP_CLAIM_LIFE_TIME - this.memory.distanceToController;
            this.estimatedStats.energyPerTick = -claimerCost / claimerWorkTime;
            this.estimatedStats.spawnTime = 2 * CREEP_SPAWN_TIME * CREEP_LIFE_TIME / claimerWorkTime;
            this.estimatedStats.baseCpu = 0.2 / this.creepComposition.body[CLAIM];
        }
    }
    updateCreepComposition() {
        const roomIntel = GIntel.rooms[this.outpostRoom.roomName];
        const reservedByHostile = roomIntel.reservation && !roomIntel.reservation.isMy;
        const useSmallReservers = Game.time - roomIntel.lastUnsafe < OperationReserve.bigReserverSafeTimeThreshold && !reservedByHostile;
        if (this.creepComposition.energyCapactityAvailable !== this.room.energyCapacityAvailable
            || this.creepComposition.useSmallReservers !== useSmallReservers) {
            this.creepComposition.energyCapactityAvailable = this.room.energyCapacityAvailable;
            this.creepComposition.useSmallReservers = useSmallReservers;
            if (this.room.energyCapacityAvailable < BODYPART_COST[MOVE] + BODYPART_COST[CLAIM]) {
                this.creepComposition.body = new CreepBody(`1X1M`);
                this.creepComposition.maxCreepCount = 0;
            }
            else if (useSmallReservers) {
                this.creepComposition.body = new CreepBody(`1X1M`);
                this.creepComposition.maxCreepCount = 1;
            }
            else {
                const partCount = Math.min(OperationReserve.MAX_CLAIM, Math.floor(this.room.energyCapacityAvailable / (BODYPART_COST[MOVE] + BODYPART_COST[CLAIM])));
                this.creepComposition.body = new CreepBody(`${partCount}X${partCount}M`);
                this.creepComposition.maxCreepCount = Math.min(roomIntel.controllerSlots, Math.ceil(OperationReserve.MAX_CLAIM / this.creepComposition.body[CLAIM]));
            }
            this.shouldUpdateEstimatedStats = true;
        }
    }
    getSpawnRequestsInternal() {
        if (!this.outpostRoom.isActive)
            return [];
        if (TickSkipper.skipRemoteSpawning)
            return [];
        if (this.room.energyCapacityAvailable < BODYPART_COST[MOVE] + BODYPART_COST[CLAIM])
            return [];
        const roomIntel = GIntel.rooms[this.outpostRoom.roomName];
        if (Game.time - roomIntel.lastUnsafe < 500)
            return [];
        if (this.creeps.length >= this.creepComposition.maxCreepCount)
            return [];
        if (roomIntel.reservation
            && roomIntel.reservation.isMy
            && roomIntel.reservation.expires > Game.time + OperationReserve.spawnReserverThreshold) {
            return [];
        }
        let result = [];
        result.push({
            id: generateRandomKey(5),
            nameBase: Config.CreepNames.Reserver,
            priority: Priority(this.outpostRoom.index + 1, 16 /* SpawnPriority.RESERVE */),
            minEnergy: this.creepComposition.body.cost,
            parts: this.creepComposition.body,
            memory: {},
            boostOptions: [null],
            noRepurpose: false,
            operation: this
        });
        return result;
    }
    reserverFunc(creep) {
        if (!creep.room.intel.isSafe) {
            if (creep.pos.roomName === this.outpostRoom.roomName)
                creep.fleeFromRoom(creep.pos.roomName);
            else if (creep.pos.isExit())
                creep.moveOffExit();
            else
                creep.giveWay(true);
            return;
        }
        if (creep.pos.isNearTo(this.controllerPos)) {
            const room = Game.rooms[this.outpostRoom.roomName];
            if (room.controller.reservation && room.controller.reservation.username !== Common.USERNAME)
                creep.attackController(room.controller);
            else
                creep.reserveController(room.controller);
            if (!room.controller.sign || room.controller.sign.username !== Common.USERNAME)
                creep.signController(room.controller, '\u{1F359}');
        }
        else {
            creep.goTo(this.controllerPos, 1, { ignoreRoads: true });
        }
    }
    onRun() {
        this.updateCreepComposition();
        for (let creep of this.creeps)
            if (!creep.spawning)
                this.reserverFunc(creep);
    }
}
// ----------------------------------------------------
OperationReserve.MAX_CLAIM = 7;
OperationReserve.MIN_CLAIM = 2;
OperationReserve.bigReserverSafeTimeThreshold = 600;
OperationReserve.spawnReserverThreshold = 1000;
__decorate([
    Profiler.profile()
], OperationReserve.prototype, "onInitForTick", null);
__decorate([
    check,
    profile()
], OperationReserve.prototype, "onRun", null);

class OperationUnpoison extends BaseRoomOperation {
    static create(parentRoom, outpostRoom) {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0
        };
        return memory;
    }
    constructor(parentRoom, outpostRoom) {
        super(parentRoom);
        this.outpostRoom = outpostRoom;
        this.creepComposition = {
            body: undefined,
            energyCapactityAvailable: 0
        };
        this.updateCreepComposition();
    }
    get memory() {
        return this.outpostRoom.memory.unpoison;
    }
    getMinimumScale() {
        return 1;
    }
    getMaximumScale() {
        return 1;
    }
    updateEstimatedStats() {
        const body = this.creepComposition.body;
        if (body && GIntel.rooms[this.outpostRoom.roomName].poisoned) {
            this.estimatedStats.energyPerTick = body.cost / CREEP_LIFE_TIME;
            this.estimatedStats.spawnTime = body.spawnTime;
            this.estimatedStats.baseCpu = 0.2;
        }
        else {
            this.estimatedStats.energyPerTick = 0;
            this.estimatedStats.spawnTime = 0;
            this.estimatedStats.baseCpu = 0;
        }
    }
    updateCreepComposition() {
        if (this.creepComposition.energyCapactityAvailable !== this.room.energyCapacityAvailable) {
            const partCount = Math.min(25, Math.floor(this.room.energyCapacityAvailable / (BODYPART_COST[MOVE] + BODYPART_COST[WORK])));
            this.creepComposition.body = new CreepBody(`${partCount}W${partCount}M`);
            this.creepComposition.energyCapactityAvailable = this.room.energyCapacityAvailable;
        }
    }
    getSpawnRequestsInternal() {
        if (!this.outpostRoom.isActive)
            return [];
        const roomIntel = GIntel.rooms[this.outpostRoom.roomName];
        if (!roomIntel.poisoned)
            return [];
        if (this.creeps.length > 0)
            return [];
        if (Game.time - roomIntel.lastUnsafe < 500)
            return [];
        let result = [];
        result.push({
            id: generateRandomKey(5),
            nameBase: Config.CreepNames.Unpoisoner,
            priority: Priority(this.outpostRoom.index + 1, 19 /* SpawnPriority.UNPOISON */),
            minEnergy: this.creepComposition.body.cost,
            parts: this.creepComposition.body,
            memory: {},
            boostOptions: [null],
            noRepurpose: false,
            operation: this
        });
        return result;
    }
    unpoisonerFunc(creep) {
        if (creep.pos.roomName !== this.outpostRoom.roomName) {
            if (this.currentTask) {
                creep.goTo(this.currentTask.pos, 1);
            }
            else {
                creep.goToRoom(this.outpostRoom.roomName);
            }
        }
        else {
            if (!this.currentTask || !Game.getObjectById(this.currentTask.id)) {
                const room = creep.room;
                const POIs = [room.controller.pos, ...room.find(FIND_SOURCES).map(s => s.pos)];
                let obstructions = [];
                for (let poi of POIs) {
                    let structuresAround = poi.lookInRange(LOOK_STRUCTURES, 1);
                    for (let s of structuresAround) {
                        if (s.isBuildable() && s.isObstacle())
                            obstructions.push(s);
                    }
                }
                if (obstructions.length === 0) {
                    GIntel.forceUpdateStructures(this.outpostRoom.roomName);
                    this.dismissCreep(creep, true, true);
                }
                else {
                    const searchResult = Pather.findPathToClosest(creep.pos, obstructions.map(o => ({ pos: o.pos, range: 1 })), {}, creep.name);
                    if (!searchResult.incomplete) {
                        const lastPos = searchResult.path.length > 0 ? _.last(searchResult.path) : creep.pos;
                        const target = obstructions.find(o => o.pos.isNearTo(lastPos));
                        this.currentTask = {
                            pos: target.pos,
                            id: target.id
                        };
                    }
                }
            }
            if (this.currentTask) {
                let visual = Common.getRoomVisual(this.currentTask.pos.roomName);
                visual.text('\u{274C}', this.currentTask.pos, {});
                visual.multiRoomLine(creep.pos, this.currentTask.pos, { color: '#ff0000', lineStyle: 'dotted', opacity: 0.75, width: 0.1 });
                if (creep.pos.isNearTo(this.currentTask.pos)) {
                    creep.dismantle(Game.getObjectById(this.currentTask.id));
                }
                else {
                    creep.goTo(this.currentTask.pos, 1);
                }
            }
        }
    }
    onRun() {
        this.updateCreepComposition();
        for (let creep of this.creeps)
            if (!creep.spawning)
                this.unpoisonerFunc(creep);
    }
}
__decorate([
    check,
    profile()
], OperationUnpoison.prototype, "onRun", null);

class OperationCoreClear extends BaseRoomOperation {
    static create() {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0
        };
        return memory;
    }
    constructor(memory, parentRoom, outpostRoom) {
        super(parentRoom);
        this.outpostRoom = outpostRoom;
    }
    get memory() {
        return this.outpostRoom.memory.coreClear;
    }
    getMinimumScale() {
        return 1;
    }
    getMaximumScale() {
        return 1;
    }
    updateEstimatedStats() {
        this.estimatedStats.energyPerTick = 0;
        this.estimatedStats.spawnTime = 0;
        this.estimatedStats.baseCpu = 0;
    }
    getSpawnRequestsInternal() {
        if (!this.outpostRoom.isActive)
            return [];
        if (this.creeps.length > 0)
            return [];
        const spawnPriority = Priority(this.outpostRoom.index + 1, 20 /* CORE_CLEAR */);
        let roomIntel = GIntel.rooms[this.outpostRoom.roomName];
        if (!roomIntel.invaderCore)
            return [];
        let result = [];
        let coreCleanerBodySize = Math.min(25, Math.floor(this.room.energyCapacityAvailable / (BODYPART_COST[ATTACK] + BODYPART_COST[MOVE])));
        let coreCleanerBody = new CreepBody(`${coreCleanerBodySize}[AM]`);
        result.push({
            id: generateRandomKey(5),
            nameBase: this.roomName + '_CoreCleaner',
            priority: spawnPriority,
            minEnergy: coreCleanerBody.cost,
            parts: coreCleanerBody,
            memory: {},
            boostOptions: [null],
            noRepurpose: false,
            operation: this
        });
        return result;
    }
    onRun() {
        var _a;
        let corePos = (_a = GIntel.rooms[this.outpostRoom.roomName].invaderCore) === null || _a === void 0 ? void 0 : _a.pos;
        for (let creep of this.creeps) {
            if (corePos) {
                if (creep.pos.isNearTo(corePos))
                    creep.attack(corePos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_INVADER_CORE));
                else
                    creep.goTo(corePos, 1);
            }
            else {
                this.dismissCreep(creep, true, true);
            }
        }
    }
}
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationCoreClear.prototype, "getSpawnRequestsInternal", null);
__decorate([
    check,
    profile()
], OperationCoreClear.prototype, "onRun", null);

class OutpostRoom {
    static create(parentRoom, roomName) {
        const roomIntel = GIntel.rooms[roomName];
        let mines = [];
        for (let sourcePos of roomIntel.sources) {
            const mineId = sourcePos.serialize();
            mines.push(mineId);
            parentRoom.memory.mines[mineId] = OperationMine.create(RoomPosition.deserialize(mineId));
        }
        let extractionId = undefined;
        if (roomIntel.isCenterRoom) {
            extractionId = roomIntel.mineralPos.serialize();
            parentRoom.memory.extractions[extractionId] = OperationExtraction.create(roomIntel.mineralPos);
        }
        return {
            roomName: roomName,
            index: 0,
            status: 0 /* OutpostStatus.Off */,
            peacekeeping: undefined,
            coreClear: undefined,
            reserve: undefined,
            mines: mines,
            SKClear: undefined,
            extraction: extractionId,
            unpoison: undefined
        };
    }
    constructor(roomName, parentRoom) {
        this.parentRoom = parentRoom;
        this.roomName = roomName;
        this.isSkRoom = Common.isSkRoom(this.memory.roomName);
        this.isControllerRoom = Common.isControllerRoom(this.memory.roomName);
        // TODO - pathRooms shouldn't be part of status, and should be always available
        this.pathRooms = _.uniq(_.flatten(this.memory.mines.map(mineId => this.parentRoom.layout.moduleStatus[mineId].pathRooms)));
        //
        if (!this.memory.peacekeeping)
            this.memory.peacekeeping = OperationPeacekeeping.create();
        if (!this.memory.coreClear)
            this.memory.coreClear = OperationCoreClear.create();
        if (!this.memory.reserve && this.isControllerRoom)
            this.memory.reserve = OperationReserve.create(parentRoom, this);
        if (!this.memory.SKClear && this.isSkRoom)
            this.memory.SKClear = OperationSKClear.create();
        if (!this.memory.unpoison && this.isControllerRoom)
            this.memory.unpoison = OperationUnpoison.create(parentRoom, this);
        //
        this.operationPeacekeeping = new OperationPeacekeeping(this.memory.peacekeeping, parentRoom, this);
        if (this.memory.coreClear)
            this.operationCoreClear = new OperationCoreClear(this.memory.coreClear, parentRoom, this);
        if (this.memory.SKClear)
            this.operationSKClear = new OperationSKClear(this.memory.SKClear, parentRoom, this);
        if (this.memory.reserve)
            this.operationReserve = new OperationReserve(parentRoom, this);
        if (this.memory.extraction) {
            const extractionId = GIntel.rooms[this.roomName].mineralPos.serialize();
            this.operationExtraction = new OperationExtraction(parentRoom, extractionId);
        }
        if (this.memory.unpoison)
            this.operationUnpoison = new OperationUnpoison(parentRoom, this);
        this.operationMine = [];
        for (let mineId of this.memory.mines)
            this.operationMine.push(new OperationMine(parentRoom, mineId));
        // ??
        for (let mine of this.operationMine)
            mine.sourceRoomIndex = this.index + 1;
        this.operations = [
            this.operationPeacekeeping,
            this.operationCoreClear,
            ...this.operationMine,
            this.operationSKClear,
            this.operationReserve,
            this.operationExtraction,
            this.operationUnpoison
        ].filter(o => !!o);
    }
    get memory() {
        return this.parentRoom.memory.outposts[this.roomName];
    }
    get isActive() {
        return this.memory.status !== 0 /* OutpostStatus.Off */;
    }
    activate(mineMode, index) {
        for (let mine of this.operationMine) {
            mine.activate(mineMode, index + 1);
        }
        if (this.operationExtraction)
            this.operationExtraction.setTargetScale(1);
        this.memory.status = 1 /* OutpostStatus.On */;
        this.memory.index = index;
    }
    deactivate() {
        this.memory.status = 0 /* OutpostStatus.Off */;
        for (let mine of this.operationMine)
            mine.deactivate();
    }
    get index() {
        return this.memory.index;
    }
    get status() {
        return this.memory.status;
    }
    isWorking() {
        if (this._isWorking === undefined) {
            this._isWorking = GIntel.rooms[this.roomName].isSafe && _.some(this.operationMine, rm => rm.isWorking());
        }
        return this._isWorking;
    }
    getEstimatedStats() {
        if (this._stats)
            return this._stats;
        //
        this._stats = {
            energyPerTick: 0,
            spawnTime: 0,
            cpu: 0,
            baseCpu: 0
        };
        for (let mine of this.operationMine) {
            let mineEstimate = mine.getEstimatedStats();
            this._stats.energyPerTick += mineEstimate.energyPerTick;
            this._stats.spawnTime += mineEstimate.spawnTime;
            this._stats.cpu += mineEstimate.cpu;
            this._stats.baseCpu += mineEstimate.baseCpu;
            //if (_.isNaN(mineEstimate.cpu))
            //  console.log('Nan CPU ' + mine.module.id);
            //console.log(mineEstimate.cpu, mine.module.id);
        }
        if (this.operationReserve) {
            let reserveEstimate = this.operationReserve.getEstimatedStats();
            this._stats.energyPerTick += reserveEstimate.energyPerTick;
            this._stats.spawnTime += reserveEstimate.spawnTime;
            this._stats.cpu += reserveEstimate.cpu;
            this._stats.baseCpu += reserveEstimate.baseCpu;
            //if (_.isNaN(reserveEstimate.cpu))
            //  console.log('Nan CPU operationReserve');
            //console.log(reserveEstimate.cpu, 'operationReserve');
        }
        if (this.operationExtraction) {
            let extractionEstimate = this.operationExtraction.getEstimatedStats();
            this._stats.energyPerTick += extractionEstimate.energyPerTick;
            this._stats.spawnTime += extractionEstimate.spawnTime;
            this._stats.cpu += extractionEstimate.cpu;
            this._stats.baseCpu += extractionEstimate.baseCpu;
            //if (_.isNaN(extractionEstimate.cpu))
            //  console.log('Nan CPU operationExtaction');
            //console.log(extractionEstimate.cpu, 'operationExtaction');
        }
        if (this.operationSKClear) {
            let clearEstimate = this.operationSKClear.getEstimatedStats();
            this._stats.energyPerTick += clearEstimate.energyPerTick;
            this._stats.spawnTime += clearEstimate.spawnTime;
            this._stats.cpu += clearEstimate.cpu;
            this._stats.baseCpu += clearEstimate.baseCpu;
            //if (_.isNaN(clearEstimate.cpu))
            //  console.log('Nan CPU operationSKClear');
            //console.log(clearEstimate.cpu, 'operationSKClear');
        }
        return this._stats;
    }
    getGeneratedValue() {
        let result = 0;
        for (let mine of this.operationMine)
            result += mine.getGeneratedValue();
        if (this.operationExtraction)
            result += this.operationExtraction.getGeneratedValue();
        this.lastValueEstimate = result;
        return result;
    }
    getSpawnRequests() {
        const roomIntel = GIntel.rooms[this.roomName];
        if (!this.isActive)
            return [];
        else if (this.pathRooms.some(r => Game.time - (GIntel.rooms[r].lastUnsafe || 0) < 500))
            return this.operationPeacekeeping.getSpawnRequests();
        else if (roomIntel.poisoned)
            return this.operationUnpoison.getSpawnRequests();
        else if (roomIntel.reservation && !roomIntel.reservation.isMy && roomIntel.reservation.username !== 'Invader')
            return [...this.operationPeacekeeping.getSpawnRequests(), ...this.operationReserve.getSpawnRequests()];
        else
            return _.flatten(this.operations.map(o => o.getSpawnRequests()));
    }
    initForTick() {
        this._stats = undefined;
        this._isWorking = undefined;
        for (let operation of this.operations)
            operation.initForTick();
    }
    hasAnyLivingCreeps() {
        return this.operationReserve && this.operationReserve.memory.creeps.length > 0
            || this.operationSKClear && this.operationSKClear.memory.creeps.length > 0
            || this.operationPeacekeeping && this.operationPeacekeeping.memory.creeps.length > 0
            || this.operationCoreClear && this.operationCoreClear.memory.creeps.length > 0
            || this.operationUnpoison && this.operationUnpoison.memory.creeps.length > 0
            || this.operationMine.some(m => m.memory.creeps.length > 0);
    }
    updateCpuUsage() {
        for (let mine of this.operationMine)
            mine.updateCpuUsage(0);
        if (this.operationReserve)
            this.operationReserve.updateCpuUsage(0);
        if (this.operationExtraction)
            this.operationExtraction.updateCpuUsage(0);
        if (this.operationSKClear)
            this.operationSKClear.updateCpuUsage(0);
        if (this.operationPeacekeeping)
            this.operationPeacekeeping.updateCpuUsage(0);
        if (this.operationCoreClear)
            this.operationCoreClear.updateCpuUsage(0);
        if (this.operationUnpoison)
            this.operationUnpoison.updateCpuUsage(0);
    }
    kill() {
        for (let mine of this.operationMine)
            mine.kill();
        if (this.operationReserve)
            this.operationReserve.kill();
        if (this.operationExtraction)
            this.operationExtraction.kill();
        if (this.operationSKClear)
            this.operationSKClear.kill();
        if (this.operationPeacekeeping)
            this.operationPeacekeeping.kill();
        if (this.operationCoreClear)
            this.operationCoreClear.kill();
        if (this.operationUnpoison)
            this.operationUnpoison.kill();
    }
    run() {
        for (let roomName of this.pathRooms)
            GIntel.markAsPointOfInterest(roomName);
        for (let mine of this.operationMine)
            mine.run();
        if (this.operationReserve)
            this.operationReserve.run();
        if (this.operationExtraction)
            this.operationExtraction.run();
        if (this.operationSKClear)
            this.operationSKClear.run();
        if (this.operationPeacekeeping)
            this.operationPeacekeeping.run();
        if (this.operationCoreClear)
            this.operationCoreClear.run();
        if (this.operationUnpoison)
            this.operationUnpoison.run();
    }
}
__decorate([
    profile()
], OutpostRoom.prototype, "initForTick", null);
__decorate([
    check
], OutpostRoom.prototype, "run", null);

class SpawnManager {
    constructor(parentRoom) {
        this.parentRoom = parentRoom;
        this.spawnSpots = {};
    }
    initForTick() {
        this.spawns = Game.rooms[this.parentRoom.roomName].find(FIND_MY_SPAWNS, { filter: s => !s.spawning });
        this._spawnRequests = undefined;
    }
    get room() {
        return Game.rooms[this.parentRoom.roomName];
    }
    get spawnRequests() {
        if (this._spawnRequests)
            return this._spawnRequests;
        // TODO - filter by distance
        this._spawnRequests = this.parentRoom.getSpawnRequests();
        return this._spawnRequests;
    }
    updateSpawnSpots(spawn) {
        this.spawnSpots[spawn.name] = [];
        let terrain = Game.map.getRoomTerrain(spawn.pos.roomName);
        for (let dir = TOP; dir <= TOP_LEFT; ++dir) {
            let pos = spawn.pos.nextPosition(dir);
            // if spot is a wall, we can't spawn into it
            if (terrain.get(pos.x, pos.y) & TERRAIN_MASK_WALL)
                continue;
            // if spot is an obstacle, we can't spawn into it
            if (pos.lookFor(LOOK_STRUCTURES).some(s => s.isObstacle()))
                continue;
            // find other empty space around spot. If it's there than we assume it leads to somewhere,
            // so the spot is not dead end This assumption may be false and pathfinding would be needed,
            // but so far it has been good enough
            for (let dirFromSpot = TOP; dirFromSpot <= TOP_LEFT; ++dirFromSpot) {
                let pos2 = pos.nextPosition(dirFromSpot);
                if (!pos2)
                    continue;
                if ((terrain.get(pos2.x, pos2.y) & TERRAIN_MASK_WALL) > 0)
                    continue;
                if (pos2.lookFor(LOOK_STRUCTURES).some(s => s.isObstacle()))
                    continue;
                this.spawnSpots[spawn.name].push(dir);
                break;
            }
        }
    }
    processUnemployed() {
        this.parentRoom.empire.idle.hireCreeps(this.spawnRequests);
    }
    findBestRequest(spawn, requests) {
        let bestRequest = null;
        let bestPriority = -Infinity;
        for (let request of requests) {
            if (this.room.energyCapacityAvailable < request.minEnergy)
                continue;
            //
            const creepParts = (_.isFunction(request.parts)
                ? request.parts(this.room.energyCapacityAvailable)
                : request.parts);
            if (Game.map.getRoomLinearDistance(spawn.pos.roomName, request.operation.roomName) * 40 > (creepParts.claim ? CREEP_CLAIM_LIFE_TIME : CREEP_LIFE_TIME / 2))
                continue;
            //
            let selectedBoost = 0;
            for (let boostOption of request.boostOptions)
                if (boostOption && boostOption.some(b => {
                    const storedBoost = this.parentRoom.room.terminal
                        ? GEmpire.getStoredResource(b)
                        : this.parentRoom.getStoredResource(b);
                    return storedBoost < LAB_BOOST_MINERAL * (creepParts[BOOST_TO_BODYPART[b]] || 0);
                })) {
                    ++selectedBoost;
                }
            if (selectedBoost >= request.boostOptions.length)
                continue;
            if (request.priority > bestPriority) {
                bestRequest = request;
                bestPriority = request.priority;
            }
        }
        return bestRequest;
    }
    makeCreepName(nameBase) {
        let creepIndex = 0;
        let creepName = nameBase;
        while (!!Game.creeps[creepName]) {
            ++creepIndex;
            creepName = nameBase + ' ' + creepIndex;
        }
        return creepName;
    }
    processSpawns() {
        if (this.room.find(FIND_NUKES).find(n => n.timeToLand < 1500))
            return;
        for (let spawn of this.spawns) {
            if (!spawn.isActive())
                continue;
            const bestRequest = this.findBestRequest(spawn, this.spawnRequests);
            if (bestRequest !== null) {
                const creepName = this.makeCreepName(bestRequest.nameBase);
                const creepParts = bestRequest.parts;
                let selectedBoosts = bestRequest.boostOptions.find(boostOption => {
                    return !boostOption || boostOption.every(b => {
                        const storedBoost = this.parentRoom.room.terminal
                            ? GEmpire.getStoredResource(b)
                            : this.parentRoom.getStoredResource(b);
                        return storedBoost >= LAB_BOOST_MINERAL * (creepParts[BOOST_TO_BODYPART[b]] || 0);
                    });
                });
                if (selectedBoosts)
                    bestRequest.memory.boosts = selectedBoosts;
                // avoid spawning into blindspot
                if (!this.spawnSpots[spawn.name]) {
                    this.updateSpawnSpots(spawn);
                }
                let result = spawn.spawnCreep(creepParts.parts, creepName, {
                    memory: bestRequest.memory,
                    directions: this.spawnSpots[spawn.name]
                });
                if (result === OK) {
                    Stats.registerSpending(this.parentRoom.roomName, bestRequest.operation.constructor.name, creepParts.cost);
                    bestRequest.operation.onSpawn(bestRequest.id, creepName);
                    _.pull(this.spawnRequests, bestRequest);
                }
                else {
                    if (result !== ERR_NOT_ENOUGH_ENERGY || creepParts.cost > spawn.room.energyCapacityAvailable)
                        console.log(spawn.pos.roomName + ' spawn failed: ' + creepName + '\n' + creepParts.serializedBody + ', result: ' + result);
                }
            }
        }
    }
    run() {
        this.processUnemployed();
        this.processSpawns();
    }
}
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], SpawnManager.prototype, "initForTick", null);
__decorate([
    check,
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], SpawnManager.prototype, "processUnemployed", null);
__decorate([
    check,
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], SpawnManager.prototype, "processSpawns", null);
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], SpawnManager.prototype, "run", null);

class RoomLayout {
    constructor(myRoom) {
        this._myRoom = myRoom;
        this._needsCacheUpdate = true;
        let segment = SegmentManager.getSegment(this._myRoom.layoutSegmentId);
        this._roomPlan = {
            pos: RoomPosition.deserialize(segment.pos),
            core: _.mapValues(segment.core, rclPlan => {
                return _.mapValues(rclPlan, structureType => {
                    return structureType.map(s => RoomPosition.deserialize(s));
                });
            }),
            upgradeSite: _.mapValues(segment.upgradeSite, structureType => structureType.map(s => RoomPosition.deserialize(s))),
            extraction: _.mapValues(segment.extraction, structureType => structureType.map(s => RoomPosition.deserialize(s))),
            mines: _.mapValues(segment.mines, mine => {
                return _.mapValues(mine, structureType => {
                    return structureType.map(s => RoomPosition.deserialize(s));
                });
            })
        };
        this.initModuleStatus();
        this.preRun();
    }
    getVersion() {
        if (this._version)
            return this._version;
        let storagePos = this.roomPlan.core[8].storage[0];
        let isFlex = _.some(this.roomPlan.core[8].lab, l => l.getRangeTo(storagePos) > 5);
        let hasFactory = !!this.roomPlan.core[8].factory;
        if (Memory.toggles.buildFactory && !hasFactory && isFlex)
            this._version = 0 /* LayoutVersion.FLEX_PRE_FACTORY */;
        else if (Memory.toggles.buildFactory && !hasFactory)
            this._version = 1 /* LayoutVersion.BUNKER_PRE_FACTORY */;
        else if (isFlex)
            this._version = 2 /* LayoutVersion.FLEX_1_0 */;
        else if (_.some(this.roomPlan.core[8].lab, l => l.x === storagePos.x || l.y === storagePos.y))
            this._version = 3 /* LayoutVersion.BUNKER_1_0 */;
        else
            this._version = 4 /* LayoutVersion.BUNKER_2_0 */;
        return this._version;
    }
    updateLayout() {
        let version = this.getVersion();
        if (version === 0 /* LayoutVersion.FLEX_PRE_FACTORY */ && this.room.controller.level >= 7) {
            let factoryCS = this.room.find(FIND_MY_CONSTRUCTION_SITES).find(cs => cs.structureType === STRUCTURE_FACTORY);
            if (factoryCS) {
                let factoryPos = factoryCS.pos;
                for (let level = 1; level <= 6; ++level)
                    this.roomPlan.core[level].factory = [];
                this.roomPlan.core[7].factory = [factoryPos];
                this.roomPlan.core[8].factory = [factoryPos];
                if (this.serialize())
                    this._version = undefined;
            }
            else
                console.log('Factory missing in flex room', this.roomName);
        }
        else if (version === 1 /* LayoutVersion.BUNKER_PRE_FACTORY */) {
            let factoryPos = this.roomPlan.core[8].extension[23];
            for (let level = 1; level <= 6; ++level)
                this.roomPlan.core[level].factory = [];
            this.roomPlan.core[7].factory = [factoryPos];
            this.roomPlan.core[8].factory = [factoryPos];
            for (let level = 5; level <= 8; ++level)
                this.roomPlan.core[level].extension.splice(23, 1);
            for (let level = 5; level < 8; ++level) {
                let lastExtensionIndex = this.roomPlan.core[level].extension.length;
                this.roomPlan.core[level].extension.push(this.roomPlan.core[level + 1].extension[lastExtensionIndex]);
            }
            if (this.serialize()) {
                let extensionOnPos = factoryPos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_EXTENSION);
                if (extensionOnPos)
                    extensionOnPos.destroy();
                this._version = undefined;
            }
        }
        else if (version === 3 /* LayoutVersion.BUNKER_1_0 */) {
            if (this.roomPlan.core[8].extension.length === 60) {
                this.roomPlan.core[8].extension.splice(23, 1);
                if (this.serialize())
                    this._version = undefined;
            }
        }
        if (this.roomPlan.core[8].factory && this.roomPlan.core[8].factory[0]) {
            let extensionOnPos = this.roomPlan.core[8].factory[0].lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_EXTENSION);
            if (extensionOnPos)
                extensionOnPos.destroy();
        }
    }
    serialize() {
        let segmentId = this._myRoom.layoutSegmentId;
        let serializedRoomPlan = {
            pos: this._roomPlan.pos.serialize(),
            core: _.mapValues(this._roomPlan.core, rclPlan => {
                return _.mapValues(rclPlan, structureType => {
                    return structureType.map(s => s.serialize());
                });
            }),
            upgradeSite: _.mapValues(this._roomPlan.upgradeSite, structureType => structureType.map(s => s.serialize())),
            extraction: _.mapValues(this._roomPlan.extraction, structureType => structureType.map(s => s.serialize())),
            mines: _.mapValues(this._roomPlan.mines, mine => {
                return _.mapValues(mine, structureType => {
                    return structureType.map(s => s.serialize());
                });
            })
        };
        return SegmentManager.setSegment(segmentId, serializedRoomPlan);
    }
    get roomPlan() {
        return this._roomPlan;
    }
    get moduleStatus() {
        return this._moduleStatus;
    }
    get barrierStatus() {
        return this._barrierStatus;
    }
    preRun() {
        if (this._needsCacheUpdate)
            this.updateIdCache();
        this._structureCache = {
            core: {},
            upgradeSite: {},
            extraction: {},
            links: []
        };
        for (let type in this._structureIdCache.core) {
            this._structureCache.core[type] = [];
            for (let id of this._structureIdCache.core[type]) {
                let structure = Game.getObjectById(id);
                if (structure)
                    this._structureCache.core[type].push(structure);
                else if (id) // we're using id=undefined for core/lab container
                    this._needsCacheUpdate = true;
            }
        }
        for (let id of this._structureIdCache.links) {
            let structure = Game.getObjectById(id);
            if (structure)
                this._structureCache.links.push(structure);
            else if (id) // we're using id=undefined for core/lab container
                this._needsCacheUpdate = true;
        }
        if (_.random(0, 19) === 0)
            this.updateModuleStatus();
        if (!this._barrierStatus || _.random(0, 19) === 0)
            this.updateBarrierStatus();
    }
    // should be called after structure is built, structure disappearing is handled in getters
    updateCache() { this._needsCacheUpdate = true; }
    get roomName() {
        return this._myRoom.roomName;
    }
    get room() {
        return Game.rooms[this.roomName];
    }
    get RCL() {
        return this.room.controller.level;
    }
    updateIdCache() {
        console.log(this._myRoom.roomName, 'updating id cache');
        let structures = this.room.find(FIND_STRUCTURES);
        this._structureIdCache = {
            linkCount: 0,
            core: {},
            upgradeSite: {},
            extraction: {},
            links: []
        };
        this._structureIdCache.core.storage = [];
        this._structureIdCache.core.terminal = [];
        this._structureIdCache.core.observer = [];
        this._structureIdCache.core.powerSpawn = [];
        this._structureIdCache.core.nuker = [];
        this._structureIdCache.core.factory = [];
        this._structureIdCache.core.tower = [];
        this._structureIdCache.core.spawn = [];
        this._structureIdCache.core.extension = [];
        this._structureIdCache.core.rampart = [];
        this._structureIdCache.core.constructedWall = [];
        this._structureIdCache.core.lab = [];
        this._structureIdCache.core.road = [];
        this._structureIdCache.core.link = [];
        this._structureIdCache.core.container = [];
        this._structureIdCache.linkCount = 0;
        for (let structure of structures) {
            switch (structure.structureType) {
                case STRUCTURE_POWER_SPAWN:
                case STRUCTURE_OBSERVER:
                case STRUCTURE_NUKER:
                case STRUCTURE_TOWER:
                case STRUCTURE_SPAWN:
                case STRUCTURE_EXTENSION:
                case STRUCTURE_RAMPART:
                case STRUCTURE_WALL:
                case STRUCTURE_LAB:
                case STRUCTURE_FACTORY:
                case STRUCTURE_STORAGE:
                case STRUCTURE_TERMINAL:
                    this._structureIdCache.core[structure.structureType].push(structure.id);
                    break;
                case STRUCTURE_LINK:
                    ++this._structureIdCache.linkCount;
                    if (structure.pos.inRangeTo(this.roomPlan.pos, 2))
                        this._structureIdCache.core.link.push(structure.id);
                    else
                        this._structureIdCache.links.push(structure.id);
                    break;
            }
        }
        //
        let coreContainer = this.roomPlan.pos.lookInRange(LOOK_STRUCTURES, 2).find(s => s.structureType === STRUCTURE_CONTAINER);
        if (coreContainer)
            this._structureIdCache.core.container.push(coreContainer.id);
        else
            this._structureIdCache.core.container.push(undefined);
        //
        let centerLabPos;
        if (this.getVersion() === 4 /* LayoutVersion.BUNKER_2_0 */)
            centerLabPos = this.roomPlan.core[8].lab.find(l => l.x === this.roomPlan.core[8].link[0].x || l.y === this.roomPlan.core[8].link[0].y);
        else
            centerLabPos = this.roomPlan.core[8].lab.find(l => l.x === this.roomPlan.pos.x || l.y === this.roomPlan.pos.y);
        let labContainer = centerLabPos.lookInRange(LOOK_STRUCTURES, 1).find(s => s.structureType === STRUCTURE_CONTAINER);
        if (labContainer)
            this._structureIdCache.core.container.push(labContainer.id);
        else
            this._structureIdCache.core.container.push(undefined);
        //
        let extractor = this.roomPlan.extraction.extractor[0].lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_EXTRACTOR);
        let extractionContainer = this.roomPlan.extraction.container[0].lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_CONTAINER);
        this._structureIdCache.extraction = {
            extractor: extractor ? extractor.id : undefined,
            container: extractionContainer ? extractionContainer.id : undefined
        };
        //
        this._structureIdCache.upgradeSite = {};
        if (this.roomPlan.upgradeSite.link && this.roomPlan.upgradeSite.link[0]) {
            let upgradeLink = this.roomPlan.upgradeSite.link[0].lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_LINK);
            if (upgradeLink)
                this._structureIdCache.upgradeSite.link = upgradeLink.id;
        }
        let upgradeContainer = this.roomPlan.upgradeSite.container[0].lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_CONTAINER);
        if (upgradeContainer)
            this._structureIdCache.upgradeSite.container = upgradeContainer.id;
        this._needsCacheUpdate = false;
    }
    get storage() {
        //return this.room.storage;
        return this._structureCache.core[STRUCTURE_STORAGE][0];
    }
    get terminal() {
        //return this.room.terminal;
        return this._structureCache.core[STRUCTURE_TERMINAL][0];
    }
    get factory() {
        return this._structureCache.core[STRUCTURE_FACTORY][0];
    }
    get observer() {
        return this._structureCache.core[STRUCTURE_OBSERVER][0];
    }
    get powerSpawn() {
        return this._structureCache.core[STRUCTURE_POWER_SPAWN][0];
    }
    get nuker() {
        return this._structureCache.core[STRUCTURE_NUKER][0];
    }
    get spawns() {
        return this._structureCache.core[STRUCTURE_SPAWN];
    }
    get towers() {
        return this._structureCache.core[STRUCTURE_TOWER];
    }
    get extensions() {
        return this._structureCache.core[STRUCTURE_EXTENSION];
    }
    get ramparts() {
        return this._structureCache.core[STRUCTURE_RAMPART];
    }
    get walls() {
        return this._structureCache.core[STRUCTURE_WALL];
    }
    get labs() {
        return this._structureCache.core[STRUCTURE_LAB];
    }
    get labContainer() {
        return this._structureCache.core[STRUCTURE_CONTAINER][1];
    }
    get coreContainer() {
        return this._structureCache.core[STRUCTURE_CONTAINER][0];
    }
    get coreLink() {
        return this._structureCache.core[STRUCTURE_LINK][0];
    }
    get links() {
        return this._structureCache.links;
    }
    get extractionContainer() {
        if (this._structureCache.extraction.container !== undefined)
            return this._structureCache.extraction.container;
        if (this._structureIdCache.extraction.container) {
            let container = Game.getObjectById(this._structureIdCache.extraction.container);
            if (container)
                this._structureCache.extraction.container = container;
            else
                this._needsCacheUpdate = true;
        }
        else
            this._structureCache.extraction.container = null;
        return this._structureCache.extraction.container;
    }
    get extractor() {
        if (this._structureCache.extraction.extractor !== undefined)
            return this._structureCache.extraction.extractor;
        if (this._structureIdCache.extraction.extractor) {
            let extractor = Game.getObjectById(this._structureIdCache.extraction.extractor);
            if (extractor)
                this._structureCache.extraction.extractor = extractor;
            else
                this._needsCacheUpdate = true;
        }
        else
            this._structureCache.extraction.extractor = null;
        return this._structureCache.extraction.extractor;
    }
    get upgradeSiteContainer() {
        if (this._structureCache.upgradeSite.container !== undefined)
            return this._structureCache.upgradeSite.container;
        if (this._structureIdCache.upgradeSite.container) {
            let container = Game.getObjectById(this._structureIdCache.upgradeSite.container);
            if (container)
                this._structureCache.upgradeSite.container = container;
            else
                this._needsCacheUpdate = true;
        }
        else
            this._structureCache.upgradeSite.container = null;
        return this._structureCache.upgradeSite.container;
    }
    initModuleStatus() {
        this._moduleStatus = {};
        let inRoomModules = ['core', 'upgradeSite', 'extraction'];
        let keys = [...inRoomModules, ...Object.keys(this.roomPlan.mines)];
        for (let key of keys) {
            let pathRooms;
            if (inRoomModules.includes(key))
                pathRooms = [this._myRoom.roomName];
            else
                pathRooms = _.uniq(this.roomPlan.mines[key][STRUCTURE_ROAD].map(p => p.roomName));
            this._moduleStatus[key] = {
                pathRooms: pathRooms,
                lowestHits: Infinity,
                containerHits: Infinity,
                offroad: true,
                roadComplete: false,
                roomStatus: {}
            };
        }
    }
    getModulePlan(name) {
        switch (name) {
            case 'core':
                return this.roomPlan.core[this.RCL];
            case 'upgradeSite':
            case 'extraction':
                return this.roomPlan[name];
            default:
                return this.roomPlan.mines[name];
        }
    }
    updateModuleStatus() {
        let keys = ['core', 'upgradeSite', 'extraction', ...this._myRoom.activeMines];
        for (let key of keys) {
            if (!this._moduleStatus[key]) {
                let pathRooms = this.roomPlan.mines[key][STRUCTURE_ROAD].map(p => p.roomName).filter((p, i, a) => a.indexOf(p) === i);
                this._moduleStatus[key] = {
                    pathRooms: pathRooms,
                    lowestHits: Infinity,
                    containerHits: Infinity,
                    offroad: true,
                    roadComplete: false,
                    roomStatus: {}
                };
            }
            let status = this._moduleStatus[key];
            let modulePlan = this.getModulePlan(key);
            let path = modulePlan.road || [];
            let containers = modulePlan.container || [];
            let containerHits = Infinity;
            for (let containerPlan of containers) {
                if (!Game.rooms[containerPlan.roomName])
                    continue;
                let container = containerPlan.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_CONTAINER);
                if (!container)
                    continue;
                containerHits = Math.min(containerHits, container.hits / container.hitsMax);
            }
            for (let roomName of status.pathRooms) {
                let perRoomStatus = status.roomStatus[roomName];
                if (perRoomStatus && Game.time - perRoomStatus.lastCheck < RoomLayout.RoadCheckFrequency)
                    continue;
                if (!Game.rooms[roomName])
                    continue;
                let roadTiles = 0;
                let lowestHitsInRoom = Infinity;
                for (let roadPos of path) {
                    if (roadPos.roomName !== roomName)
                        continue;
                    let road = roadPos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_ROAD);
                    if (!road)
                        continue;
                    ++roadTiles;
                    if (lowestHitsInRoom > road.hits / road.hitsMax)
                        lowestHitsInRoom = road.hits / road.hitsMax;
                }
                status.roomStatus[roomName] = {
                    lastCheck: Game.time,
                    lowestHits: lowestHitsInRoom,
                    roadTiles: roadTiles
                };
            }
            let roadCoverage = 0;
            let lowestHits = Infinity;
            for (let roomName in status.roomStatus) {
                let roomStatus = status.roomStatus[roomName];
                roadCoverage += roomStatus.roadTiles;
                if (roomStatus.lowestHits < lowestHits)
                    lowestHits = roomStatus.lowestHits;
            }
            roadCoverage /= path.length;
            status.containerHits = containerHits;
            status.lowestHits = lowestHits;
            status.offroad = (roadCoverage < 0.5);
            status.roadComplete = (roadCoverage === 1);
        }
    }
    updateBarrierStatus() {
        let minHits = Infinity;
        let avgHits = 0;
        for (let w of this.walls) {
            avgHits += w.hits;
            if (minHits > w.hits)
                minHits = w.hits;
        }
        for (let r of this.ramparts) {
            avgHits += r.hits;
            if (minHits > r.hits)
                minHits = r.hits;
        }
        avgHits /= (this.walls.length + this.ramparts.length);
        this._barrierStatus = {
            avgHits: avgHits,
            minHits: minHits
        };
    }
    getRoadBuildRequest(roadPlan) {
        if (!roadPlan)
            return undefined;
        for (let pos of roadPlan) {
            if (pos.isExit())
                continue;
            if (!Game.rooms[pos.roomName])
                continue;
            if (GIntel.rooms[pos.roomName].reservation && !GIntel.rooms[pos.roomName].reservation.isMy)
                continue;
            // skip invaded rooms
            if (!GIntel.rooms[pos.roomName].isSafe)
                continue;
            if (!pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_ROAD)) {
                return {
                    structureType: STRUCTURE_ROAD,
                    pos: pos
                };
            }
        }
        return undefined;
    }
    getStructureBuildRequest(structureType, plan) {
        if (!plan)
            return undefined;
        let pos = plan.find(p => {
            const roomIntel = GIntel.rooms[p.roomName];
            if (!roomIntel.isSafe && !roomIntel.safeMode)
                return false;
            if (!Game.rooms[p.roomName])
                return false;
            if (p.lookFor(LOOK_STRUCTURES).find(s => s.structureType === structureType))
                return false;
            return true;
        });
        if (!pos)
            return undefined;
        return {
            structureType: structureType,
            pos: pos
        };
    }
    getBuildRequest() {
        let result;
        let structureTypesByPriority = [
            STRUCTURE_SPAWN,
            STRUCTURE_TOWER,
            STRUCTURE_EXTENSION,
            STRUCTURE_WALL,
            STRUCTURE_RAMPART,
            STRUCTURE_ROAD,
            STRUCTURE_CONTAINER,
            STRUCTURE_TERMINAL,
            STRUCTURE_FACTORY,
            STRUCTURE_STORAGE,
            STRUCTURE_LINK,
            STRUCTURE_LAB,
            STRUCTURE_POWER_SPAWN,
            STRUCTURE_NUKER,
            STRUCTURE_OBSERVER
        ];
        if (!Memory.toggles.buildFactory)
            _.remove(structureTypesByPriority, structureType => structureType === STRUCTURE_FACTORY);
        if (!Memory.toggles.processPower)
            _.remove(structureTypesByPriority, structureType => structureType === STRUCTURE_POWER_SPAWN);
        let initialSpawnPos = this._roomPlan.core[this.RCL][STRUCTURE_SPAWN][0];
        if (!this.room.controller.safeMode && this.spawns.length === 0 && !initialSpawnPos.lookFor(LOOK_STRUCTURES).some(s => s.structureType === STRUCTURE_RAMPART)) {
            result = {
                pos: initialSpawnPos,
                structureType: STRUCTURE_RAMPART
            };
            return result;
        }
        //
        for (let structureType of structureTypesByPriority) {
            if (!this._roomPlan.core[this.RCL][structureType])
                continue;
            if (this._structureIdCache.core[structureType].length === CONTROLLER_STRUCTURES[structureType][this.RCL])
                continue;
            result = this.getStructureBuildRequest(structureType, this._roomPlan.core[this.RCL][structureType]);
            if (result)
                return result;
        }
        //
        // TODO - sort mines by distance
        for (let mineId of this._myRoom.memory.inRoomMines) {
            const minePos = RoomPosition.deserialize(mineId);
            const mineRoomIntel = GIntel.rooms[minePos.roomName];
            if (this.RCL < 3 || this.RCL < 4 && minePos.roomName !== this._myRoom.roomName)
                continue;
            if (mineRoomIntel.poisoned)
                continue;
            if (mineRoomIntel.reservation && !mineRoomIntel.reservation.isMy)
                continue;
            if (this.moduleStatus[mineId] && this.moduleStatus[mineId].pathRooms.some(r => !GIntel.rooms[r].isSafe || Game.time - GIntel.rooms[r].lastUnsafe < 1000))
                continue;
            let minePlan = this._roomPlan.mines[mineId];
            result = this.getRoadBuildRequest(minePlan.road);
            if (result)
                return result;
            if (this._structureIdCache.linkCount < CONTROLLER_STRUCTURES[STRUCTURE_LINK][this.RCL]) {
                result = this.getStructureBuildRequest(STRUCTURE_LINK, minePlan.link);
                if (result)
                    return result;
            }
            // don't build container if there is a linkMining going on
            if (minePos.roomName !== this._myRoom.roomName || !minePlan.link || minePlan.link.length === 0 || !minePlan.link[0].lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_LINK)) {
                result = this.getStructureBuildRequest(STRUCTURE_CONTAINER, minePlan.container);
                if (result)
                    return result;
            }
        }
        //
        if (this.RCL >= 3 && this._moduleStatus.upgradeSite && !this._moduleStatus.upgradeSite.roadComplete) {
            result = this.getRoadBuildRequest(this._roomPlan.upgradeSite.road);
            if (result)
                return result;
        }
        if (this.RCL >= 2) {
            result = this.getStructureBuildRequest(STRUCTURE_CONTAINER, this._roomPlan.upgradeSite.container);
            if (result)
                return result;
        }
        if (this.RCL === 8 && this._structureIdCache.linkCount < CONTROLLER_STRUCTURES[STRUCTURE_LINK][this.RCL]) {
            result = this.getStructureBuildRequest(STRUCTURE_LINK, this._roomPlan.upgradeSite.link);
            if (result)
                return result;
        }
        //
        if (this.RCL >= 6 && this._moduleStatus.extraction && !this._moduleStatus.extraction.roadComplete) {
            result = this.getRoadBuildRequest(this._roomPlan.extraction.road);
            if (result)
                return result;
        }
        if (this.RCL >= 6) {
            result = this.getStructureBuildRequest(STRUCTURE_EXTRACTOR, this._roomPlan.extraction.extractor);
            if (result)
                return result;
        }
        if (this.RCL >= 6) {
            result = this.getStructureBuildRequest(STRUCTURE_CONTAINER, this._roomPlan.extraction.container);
            if (result)
                return result;
        }
        //
        // TODO - sort mines by distance
        for (let mineId of this._myRoom.activeMines) {
            const minePos = RoomPosition.deserialize(mineId);
            const mineRoomIntel = GIntel.rooms[minePos.roomName];
            if (this.RCL < 3 || this.RCL < 4 && minePos.roomName !== this._myRoom.roomName)
                continue;
            if (mineRoomIntel.poisoned)
                continue;
            if (mineRoomIntel.reservation && !mineRoomIntel.reservation.isMy)
                continue;
            if (this.moduleStatus[mineId] && this.moduleStatus[mineId].pathRooms.some(r => !GIntel.rooms[r].isSafe || Game.time - GIntel.rooms[r].lastUnsafe < 1000))
                continue;
            let minePlan = this._roomPlan.mines[mineId];
            result = this.getRoadBuildRequest(minePlan.road);
            if (result)
                return result;
            if (this._structureIdCache.linkCount < CONTROLLER_STRUCTURES[STRUCTURE_LINK][this.RCL]) {
                result = this.getStructureBuildRequest(STRUCTURE_LINK, minePlan.link);
                if (result)
                    return result;
            }
            // don't build container if there is a linkMining going on
            if (minePos.roomName !== this._myRoom.roomName || !minePlan.link || minePlan.link.length === 0 || !minePlan.link[0].lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_LINK)) {
                result = this.getStructureBuildRequest(STRUCTURE_CONTAINER, minePlan.container);
                if (result)
                    return result;
            }
        }
        return null;
    }
    visualizeRoomPlan() {
        for (let structureType in this.roomPlan.core[8])
            for (let pos of this.roomPlan.core[8][structureType])
                Common.getRoomVisual(pos.roomName).structure(pos.x, pos.y, structureType, { opacity: 0.75 });
        for (let structureType in this.roomPlan.extraction)
            for (let pos of this.roomPlan.extraction[structureType])
                Common.getRoomVisual(pos.roomName).structure(pos.x, pos.y, structureType, { opacity: 0.75 });
        for (let structureType in this.roomPlan.upgradeSite)
            for (let pos of this.roomPlan.upgradeSite[structureType])
                Common.getRoomVisual(pos.roomName).structure(pos.x, pos.y, structureType, { opacity: 0.75 });
        for (let mineId in this.roomPlan.mines)
            for (let structureType in this.roomPlan.mines[mineId])
                for (let pos of this.roomPlan.mines[mineId][structureType])
                    Common.getRoomVisual(pos.roomName).structure(pos.x, pos.y, structureType, { opacity: 0.75 });
    }
}
RoomLayout.RoadCheckFrequency = 100;
__decorate([
    profile()
], RoomLayout.prototype, "preRun", null);
__decorate([
    check,
    profile("BuildLogic" /* ProfilerFunctionType.BuildLogic */)
], RoomLayout.prototype, "updateModuleStatus", null);
__decorate([
    profile("BuildLogic" /* ProfilerFunctionType.BuildLogic */)
], RoomLayout.prototype, "getBuildRequest", null);
__decorate([
    profile()
], RoomLayout.prototype, "visualizeRoomPlan", null);

class Visual {
    static preTick() {
        this.any = undefined;
        this.data = {};
        this.mapData = {};
    }
    static addText(roomName, boxTitle, value) {
        let roomVisualData;
        if (!roomName) {
            this.any = this.any || {};
            roomVisualData = this.any;
        }
        else {
            this.data[roomName] = this.data[roomName] || {};
            roomVisualData = this.data[roomName];
        }
        //
        if (!roomVisualData[boxTitle]) {
            roomVisualData[boxTitle] = {
                title: boxTitle,
                rows: []
            };
        }
        let box = roomVisualData[boxTitle];
        //
        box.rows.push(value);
    }
    static addMapText(roomName, value, style) {
        this.mapData[roomName] = this.mapData[roomName] || [];
        this.mapData[roomName].push({ value: value, style: style });
    }
    static drawBox(visual, offsetX, offsetY, box) {
        let pos = {
            x: offsetX,
            y: offsetY + Visual.borderWidth
        };
        visual.text(box.title, pos.x - 0.25, pos.y, { align: 'left', color: '#ffffff', opacity: Visual.opacity, font: Visual.fontSize, strokeWidth: 0.05, stroke: '#ffffff' });
        pos.y += Visual.titleHeight;
        for (let row of box.rows) {
            visual.text(row, pos.x - 0.25, pos.y, { align: 'left', color: '#ffffff', opacity: Visual.opacity, font: Visual.fontSize });
            pos.y += Visual.fontSize;
        }
        pos.y += Visual.borderWidth;
        visual.rect(offsetX - 0.5, offsetY - 0.5, Visual.boxWidth, pos.y - offsetY, { fill: null, opacity: Visual.opacity, stroke: '#ffffff', strokeWidth: Visual.borderWidth });
        pos.y += Visual.borderWidth;
        return pos;
    }
    static run() {
        let globalVisual = new RoomVisual();
        let posX = 0.25;
        let posY = 0.25;
        for (let boxId in this.any) {
            let newPos = this.drawBox(globalVisual, posX, posY, this.any[boxId]);
            posX = newPos.x;
            posY = newPos.y;
        }
        let offsetX = posX;
        let offsetY = posY;
        for (let roomName in this.data) {
            let roomVisual = new RoomVisual(roomName);
            posX = offsetX;
            posY = offsetY;
            for (let boxId in this.data[roomName]) {
                let newPos = this.drawBox(roomVisual, posX, posY, this.data[roomName][boxId]);
                posX = newPos.x;
                posY = newPos.y;
            }
        }
        const mapTextStyle = { align: 'left', color: '#ffffff', opacity: Visual.opacity, fontSize: 4 };
        for (let roomName in this.mapData) {
            for (let i = 0; i < this.mapData[roomName].length; ++i)
                Game.map.visual.text(this.mapData[roomName][i].value, new RoomPosition(0, (i + 0.5) * mapTextStyle.fontSize, roomName), Object.assign(Object.assign({}, mapTextStyle), this.mapData[roomName][i].style));
        }
        const roomVisionStyle = { align: 'right', opacity: Visual.opacity, fontSize: 4 };
        for (let roomName in GIntel.rooms) {
            const roomIntel = GIntel.rooms[roomName];
            // vision
            if (Game.rooms[roomName])
                Game.map.visual.text('\u{1F441}\u{FE0F}', new RoomPosition(49, 3, roomName), roomVisionStyle);
            else
                Game.map.visual.text((Game.time - roomIntel.lastScout).toString(), new RoomPosition(49, 3, roomName), Object.assign(Object.assign({}, roomVisionStyle), { color: '#ff0000' }));
        }
    }
}
Visual.boxWidth = 9;
Visual.fontSize = 0.5;
Visual.opacity = 0.75;
Visual.titleHeight = 0.6;
Visual.borderWidth = 0.1;
__decorate([
    profile()
], Visual, "run", null);

var EThreadStatus;
(function (EThreadStatus) {
    EThreadStatus[EThreadStatus["Ready"] = 0] = "Ready";
    EThreadStatus[EThreadStatus["FinishedTick"] = 1] = "FinishedTick";
    EThreadStatus[EThreadStatus["Finished"] = 2] = "Finished";
})(EThreadStatus || (EThreadStatus = {}));

class FactoryManager {
    constructor(parentRoom) {
        this.parentRoom = parentRoom;
    }
    getDistributionRequests() {
        const result = [];
        const compressedResources = [
            RESOURCE_KEANIUM_BAR,
            RESOURCE_LEMERGIUM_BAR,
            RESOURCE_UTRIUM_BAR,
            RESOURCE_ZYNTHIUM_BAR,
            RESOURCE_GHODIUM_MELT,
            RESOURCE_OXIDANT,
            RESOURCE_REDUCTANT,
            RESOURCE_PURIFIER,
            RESOURCE_BATTERY
        ];
        const factory = this.parentRoom.layout.factory;
        if (factory) {
            if (factory.store[RES_ENERGY] < 1000) {
                result.push({
                    amount: 1000,
                    priority: 4 /* DistributionPriority.FACTORY */,
                    resource: RES_ENERGY,
                    structureId: factory.id
                });
            }
            for (const compressedResource of compressedResources) {
                const stored = this.parentRoom.getStoredResource(compressedResource);
                if (stored > 0) {
                    result.push({
                        amount: stored,
                        priority: 4 /* DistributionPriority.FACTORY */,
                        resource: compressedResource,
                        structureId: factory.id
                    });
                }
            }
            for (let key in factory.store) {
                const resource = key;
                if (!compressedResources.includes(resource) && resource !== RES_ENERGY && factory.store[resource] >= 100) {
                    result.push({
                        amount: -factory.store[resource],
                        priority: 4 /* DistributionPriority.FACTORY */,
                        resource: resource,
                        structureId: factory.id
                    });
                }
            }
            if (factory.store[RES_ENERGY] > 2000) {
                result.push({
                    amount: 2000 - factory.store[RES_ENERGY],
                    priority: 4 /* DistributionPriority.FACTORY */,
                    resource: RES_ENERGY,
                    structureId: factory.id
                });
            }
        }
        return result;
    }
    run() {
        const factory = this.parentRoom.layout.factory;
        if (factory && !factory.cooldown) {
            const decompressedResources = [
                RES_K,
                RES_L,
                RES_U,
                RES_Z,
                RES_G,
                RES_O,
                RES_H,
                RES_X,
                RES_ENERGY
            ];
            const resourceToDecompress = decompressedResources.find(dcr => _.every(COMMODITIES[dcr].components, (amount, component) => factory.store.getUsedCapacity(component) >= amount));
            if (resourceToDecompress) {
                factory.produce(resourceToDecompress);
            }
        }
    }
}
__decorate([
    check,
    profile()
], FactoryManager.prototype, "run", null);

class RoomCreateTask {
    constructor(roomName, roomPlan, outResult) {
        this.id = `RoomCreateTask_${roomName}`;
        this.roomName = roomName;
        this.plan = roomPlan;
        this.outResult = outResult;
    }
    *run() {
        let serializedRoomPlan = {
            pos: this.plan.pos.serialize(),
            core: _.mapValues(this.plan.core, rclPlan => {
                return _.mapValues(rclPlan, structureType => {
                    return structureType.map(s => s.serialize());
                });
            }),
            upgradeSite: _.mapValues(this.plan.upgradeSite, structureType => structureType.map(s => s.serialize())),
            extraction: _.mapValues(this.plan.extraction, structureType => structureType.map(s => s.serialize())),
            mines: _.mapValues(this.plan.mines, mine => {
                return _.mapValues(mine, structureType => {
                    return structureType.map(s => s.serialize());
                });
            })
        };
        while (true) {
            let freeSegment = SegmentManager.findFreeSegmentId();
            console.log(`${this.id} looking for free segment`);
            if (freeSegment === undefined) {
                yield EThreadStatus.FinishedTick;
                continue;
            }
            let savedLayout = SegmentManager.setSegment(freeSegment, serializedRoomPlan);
            console.log(`${this.id} saving in segment ${freeSegment}`);
            if (!savedLayout) {
                yield EThreadStatus.FinishedTick;
                continue;
            }
            Memory.myRooms[this.roomName] = Memory.myRooms[this.roomName] || {
                roomName: this.roomName
            };
            Memory.myRooms[this.roomName].layoutSegmentId = freeSegment;
            if (Memory.myRooms[this.roomName].outposts && _.size(Memory.myRooms[this.roomName].outposts) > 0) {
                GEmpire.reloadRoom(this.roomName);
                Memory.myRooms[this.roomName]['updateRoads'] = true;
            }
            this.outResult.put(true);
            break;
        }
        return EThreadStatus.Finished;
    }
}
class MyRoom {
    // ---------------------------------------------------------------------
    constructor(empire, roomName) {
        console.log(roomName, 'MyRoom::constructor');
        this.empire = empire;
        this.roomName = roomName;
        this.globalOperations = [];
        this.operator = {
            creep: undefined
        };
        //
        this.layout = new RoomLayout(this);
        // TODO - better condition - if operations weren't initialized
        if (!this.memory.storage) {
            this.memory.storage = OperationStorage.create();
            this.memory.upgrade = OperationUpgrade.create();
            this.memory.build = OperationBuild.create();
            this.memory.defend = OperationDefend.create();
            this.memory.recovery = OperationRecovery.create();
            this.memory.boostPickup = OperationBoostPickup.create();
            this.memory.maintenance = OperationMaintenance.create();
            this.memory.reinforcement = OperationReinforcement.create();
            this.memory.scout = OperationScout.create();
            this.memory.labManager = LabManager.create();
            this.memory.mines = {};
            this.memory.extractions = {};
            this.memory.inRoomMines = [];
            for (let source of this.room.find(FIND_SOURCES)) {
                const mineId = source.pos.serialize();
                this.memory.mines[mineId] = OperationMine.create(source.pos);
                this.memory.inRoomMines.push(mineId);
            }
            for (let mineral of this.room.find(FIND_MINERALS)) {
                const extractionId = mineral.pos.serialize();
                this.memory.extractions[extractionId] = OperationExtraction.create(mineral.pos);
            }
            this.memory.potentialOutposts = Common.findRoomsInRange(roomName, 3);
            this.memory.outposts = {};
            this.memory.wasEverSieged = false;
        }
        // TODO - temp
        if (!this.memory.boostPickup)
            this.memory.boostPickup = OperationBoostPickup.create();
        //
        //
        this.operationUpgrade = new OperationUpgrade(this);
        this.operationStorage = new OperationStorage(this);
        this.inRoomMines = this.memory.inRoomMines.map(mineId => new OperationMine(this, mineId));
        this.operationExtraction = new OperationExtraction(this, GIntel.rooms[this.roomName].mineralPos.serialize());
        this.operationRecovery = new OperationRecovery(this);
        this.operationBoostPickup = new OperationBoostPickup(this);
        this.operationDefend = new OperationDefend(this);
        this.operationBuild = new OperationBuild(this);
        this.operationMaintenance = new OperationMaintenance(this);
        this.operationReinforcement = new OperationReinforcement(this);
        this.operationScout = new OperationScout(this);
        for (let mine of this.inRoomMines)
            mine.sourceRoomIndex = 0;
        //
        this.operations = [
            this.operationStorage,
            this.operationUpgrade,
            ...this.inRoomMines,
            this.operationExtraction,
            this.operationBuild,
            this.operationDefend,
            this.operationRecovery,
            this.operationBoostPickup,
            this.operationMaintenance,
            this.operationReinforcement,
            this.operationScout
        ];
        this.spendingOperations = [
            this.operationStorage,
            this.operationExtraction,
            this.operationMaintenance,
            this.operationReinforcement,
            this.operationBuild,
            this.operationUpgrade
        ];
        //
        this.outposts = [];
        for (let key in this.memory.outposts) {
            let outpostMemory = this.memory.outposts[key];
            errGuard(() => {
                let outpost = new OutpostRoom(outpostMemory.roomName, this);
                this.outposts.push(outpost);
            });
        }
        this.activeOutposts = this.outposts.filter(o => o.isActive);
        //
        this.spawnManager = new SpawnManager(this);
        this.labManager = new LabManager(this.memory.labManager, this);
        this.factoryManager = new FactoryManager(this);
        //
        if (!this.memory.stats)
            this.memory.stats = {
                labUptime: undefined,
                spawnUptime: undefined,
                cpu: 0.6
            };
        //
        this.roomsInRange10 = Common.findRoomsInRange(this.roomName, 10);
    }
    // ---------------------------------------------------------------------
    get memory() {
        return Memory.myRooms[this.roomName];
    }
    get room() {
        return Game.rooms[this.roomName];
    }
    get layoutSegmentId() {
        return this.memory.layoutSegmentId;
    }
    get estimatedCpuUsage() {
        return this.memory.stats.cpu;
    }
    // ---------------------------------------------------------------------
    get evacResources() {
        return !!this.memory.evacResources;
    }
    get abandon() {
        return !!this.memory.abandon;
    }
    get activeMines() {
        let result = [];
        for (let mine of this.inRoomMines)
            result.push(mine.memory.pos);
        for (let outpost of this.activeOutposts) {
            for (let mine of outpost.operationMine)
                result.push(mine.memory.pos);
            if (outpost.operationExtraction)
                result.push(outpost.operationExtraction.memory.pos);
        }
        return result;
    }
    isRecoveryNeeded() {
        if (this._isRecoveryNeeded === undefined) {
            this._isRecoveryNeeded = (!this.isEnergyDistributionWorking() || this.operationStorage.getEnergy() === 0)
                && this.inRoomMines.every(mine => !mine.isWorking())
                && this.activeOutposts.every(outpost => !outpost.isWorking());
        }
        return this._isRecoveryNeeded;
    }
    isLowEnergy() {
        if (this._isLowEnergy === undefined)
            this._isLowEnergy = this.operationStorage.getEnergy() < Math.min(10000, this.operationStorage.getDesiredBank());
        return this._isLowEnergy;
    }
    getEnergyAmount() {
        return this.operationStorage.getEnergy();
    }
    getTargetBank() {
        return this.operationStorage.getDesiredBank();
    }
    isEnergyDistributionWorking() {
        return this.operationStorage.isWorking();
    }
    getCollectionPoint() {
        return this.operationStorage.getCollectionPoint();
    }
    getDistributionPoint(resourceType) {
        return this.operationStorage.getDistributionPoint(resourceType);
    }
    getResourceBalance() {
        if (!this._resourceBalance) {
            this._resourceBalance = {};
            for (let key in Config.TARGET_STOCK) {
                let r = key;
                this._resourceBalance[r] = (this.room.terminal && this.room.terminal.store[r] || 0)
                    + (this.room.storage && this.room.storage.store[r] || 0)
                    - Config.TARGET_STOCK[r].storage
                    - Config.TARGET_STOCK[r].terminal;
            }
            if (this.room.controller.level < 8)
                this._resourceBalance.energy -= 200000;
        }
        return this._resourceBalance;
    }
    getStoredResource(resourceType) {
        const inTerminal = this.room.terminal && this.room.terminal.store[resourceType] || 0;
        const inStorage = this.room.storage && this.room.storage.store[resourceType] || 0;
        return inTerminal + inStorage;
    }
    getTargetBarrier() {
        const barrierGreedy = {
            0: 0,
            1: 0,
            2: 0,
            3: 10000,
            4: 10000,
            5: 20000,
            6: 50000,
            7: 100000,
            8: 200000
        };
        const barrierByRCL = {
            1: 0,
            2: 0,
            3: 10000,
            4: 20000,
            5: 50000,
            6: 100000,
            7: 2000000,
            8: 15000000
        };
        const barrierByThreat = {
            0: 0,
            1: 0,
            2: 0,
            3: 10000,
            4: 10000,
            5: 20000,
            6: 100000,
            7: 1000000,
            8: 3000000
        };
        let maxHostileRclInRange = _(this.roomsInRange10)
            .map(r => {
            let roomIntel = GIntel.rooms[r];
            if (!roomIntel)
                return 0;
            if (!roomIntel.owner)
                return 0;
            if (roomIntel.isMy || roomIntel.isFriendly)
                return 0;
            return roomIntel.rcl;
        })
            .max();
        return Math.min(RAMPART_HITS_MAX[this.room.controller.level], this.memory.wasEverSieged
            ? Math.max(barrierByThreat[maxHostileRclInRange], barrierByRCL[this.room.controller.level])
            : barrierGreedy[this.room.controller.level]);
    }
    get spawnTimeMultiplier() {
        return this._spawnTimeMultiplier;
    }
    updateSpawnTimeMultiplier() {
        this._spawnTimeMultiplier = 1;
        if (this.operator.creep && this.operator.creep.shard && this.operator.creep.powers[PWR_OPERATE_SPAWN]) {
            let powerLevel = this.operator.creep.powers[PWR_OPERATE_SPAWN].level;
            this._spawnTimeMultiplier = POWER_INFO[PWR_OPERATE_SPAWN].effect[powerLevel];
        }
    }
    // ---------------------------------------------------------------------
    initForTick() {
        let startCpu = Game.cpu.getUsed();
        if (this.memory !== Memory.myRooms[this.roomName])
            console.log(this.roomName, 'STALE MEMORY');
        this._repairRequests = undefined;
        this._isLowEnergy = undefined;
        this._isRecoveryNeeded = undefined;
        this._resourceBalance = undefined;
        this._spawnRequests = undefined;
        this.layout.preRun();
        this.spawnManager.initForTick();
        this.labManager.initForTick();
        if (this.memory.operator)
            this.operator.creep = Game.powerCreeps[this.memory.operator];
        else
            this.operator.creep = undefined;
        this.updateSpawnTimeMultiplier();
        this.tickCpu = Game.cpu.getUsed() - startCpu;
        for (let outpost of this.activeOutposts)
            outpost.initForTick();
        for (let operation of this.operations)
            operation.initForTick();
    }
    // ---------------------------------------------------------------------
    updateTerminalDistributionRequests() {
        this.operationStorage.updateTerminalDistributionRequests();
    }
    updateTowerDistributionRequests() {
        this.operationStorage.updateTowerDistributionRequests();
    }
    getLabDistributionRequests() {
        return this.labManager.getDistributionRequests();
    }
    getFactoryDistributionRequests() {
        return this.factoryManager.getDistributionRequests();
    }
    // ---------------------------------------------------------------------
    getInterRoomResourceRequests() {
        return this.labManager.getDistributionRequests().filter(request => this.getStoredResource(request.resource) < request.amount);
    }
    // ---------------------------------------------------------------------
    requestBoost(creep, boost) {
        this.labManager.requestBoost(creep, boost);
    }
    requestUnboost(creep) {
        return this.labManager.requestUnboost(creep);
    }
    // ---------------------------------------------------------------------
    getRepairRequests() {
        if (this._repairRequests !== undefined)
            return this._repairRequests;
        let repairThreshold = 0.5;
        this._repairRequests = [];
        let activeModules = ['core', 'upgradeSite', 'extraction', ...this.activeMines];
        for (let id of activeModules) {
            let moduleStatus = this.layout.moduleStatus[id];
            if (!moduleStatus)
                continue;
            if (moduleStatus.lowestHits >= repairThreshold && moduleStatus.containerHits >= repairThreshold)
                continue;
            if (moduleStatus.pathRooms.some(r => !GIntel.rooms[r].isSafe || Game.time - GIntel.rooms[r].lastUnsafe < 1000))
                continue;
            this._repairRequests.push(id);
        }
        return this._repairRequests;
    }
    getSpawnRequests() {
        if (!this._spawnRequests) {
            this._spawnRequests = [].concat(...this.operations.map(o => o.getSpawnRequests()), ...this.activeOutposts.map(o => o.getSpawnRequests()), ...this.globalOperations.map(g => g.getSpawnRequests()));
        }
        return this._spawnRequests;
    }
    // ---------------------------------------------------------------------
    renderSpawnQueue() {
        const color = '#88ff88';
        const lineSize = 0.35;
        let line = 0;
        let visual = Common.getRoomVisual(this.roomName);
        let queuePos = {
            x: Visual.boxWidth,
            y: 0
        };
        let spawnRequests = this.getSpawnRequests();
        for (let request of spawnRequests) {
            visual.text(request.priority + ': ' + request.nameBase + ' (' + request.parts.serializedBody + ')', queuePos.x, queuePos.y + line * lineSize, {
                align: 'left',
                font: lineSize,
                color: color
            });
            ++line;
        }
    }
    // ---------------------------------------------------------------------
    assignOperator(creep) {
        this.memory.operator = creep.name;
    }
    dismissOperator() {
        let creepMemory = this.operator.creep.memory;
        creepMemory.roomName = undefined;
        this.memory.operator = undefined;
    }
    runOperator() {
        let operator = this.operator.creep;
        if (!operator.shard) {
            if (this.layout.powerSpawn && this.layout.powerSpawn.isActive() && Date.now() >= (operator.spawnCooldownTime || 0))
                operator.spawn(this.layout.powerSpawn);
            else if (Game.time % 50 === 0) {
                let respawnIn = operator.spawnCooldownTime - Date.now();
                let respawnInStr = Math.floor(respawnIn / (1000 * 60 * 60 * 24)) + 'd '
                    + Math.floor((respawnIn % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)) + 'h '
                    + Math.floor((respawnIn % (1000 * 60 * 60)) / (1000 * 60)) + 'm';
                console.log(`Operator ${operator.name} from room ${this.roomName} is dead. Respawn in ${respawnInStr}`);
            }
            return;
        }
        let moved = false;
        let usedPower = false;
        let minOps = operator.level > 3 ? operator.store.getCapacity() / 4 : 0;
        let maxOps = operator.level > 3 ? operator.store.getCapacity() / 2 : 0;
        let energyStoreSource = this.room.terminal && this.room.terminal.store.energy > Config.TARGET_STOCK.energy.terminal ? this.layout.terminal : this.layout.storage;
        // renew
        if (operator.ticksToLive && operator.ticksToLive < 2000) {
            if (!this.layout.powerSpawn)
                this.dismissOperator();
            else if (operator.pos.isNearTo(this.layout.powerSpawn.pos))
                operator.renew(this.layout.powerSpawn);
            else {
                operator.goTo(this.layout.powerSpawn.pos, 1);
                moved = true;
            }
        }
        // enable power
        else if (!this.room.controller.isPowerEnabled) {
            if (operator.pos.isNearTo(this.room.controller.pos))
                operator.enableRoom(this.room.controller);
            else
                operator.goTo(this.room.controller.pos, 1);
        }
        // store excess ops
        else if ((operator.store.ops || 0) > maxOps && this.layout.storage && this.layout.storage.isActive()) {
            if (operator.pos.isNearTo(this.layout.storage.pos))
                operator.transfer(this.layout.storage, RESOURCE_OPS, operator.store.ops / 2);
            else {
                operator.goTo(this.layout.storage.pos, 1);
                moved = true;
            }
        }
        // withdraw ops
        else if ((operator.store.ops || 0) < minOps && this.getStoredResource(RES_OPS) > 0) {
            const distributionPoint = this.getDistributionPoint(RES_OPS);
            if (operator.pos.isNearTo(distributionPoint.pos)) {
                if (distributionPoint instanceof Resource) {
                    operator.pickup(distributionPoint);
                }
                else {
                    operator.withdraw(distributionPoint, RESOURCE_OPS, Math.min(minOps - operator.store.ops, distributionPoint.store.ops));
                }
            }
            else {
                operator.goTo(distributionPoint.pos, 1);
                moved = true;
            }
        }
        // operate extension
        else if (operator.powers[PWR_OPERATE_EXTENSION]
            && (operator.store.ops || 0) >= POWER_INFO[PWR_OPERATE_EXTENSION].ops
            && !operator.powers[PWR_OPERATE_EXTENSION].cooldown
            && this.room.energyAvailable - _.sum(this.layout.spawns, s => s.energy) < this.room.energyCapacityAvailable - _.sum(this.layout.spawns, s => s.energyCapacity)) {
            if (operator.pos.inRangeTo(energyStoreSource.pos, POWER_INFO[PWR_OPERATE_EXTENSION].range)) {
                operator.usePower(PWR_OPERATE_EXTENSION, energyStoreSource);
                usedPower = true;
            }
            else {
                operator.goTo(energyStoreSource.pos, POWER_INFO[PWR_OPERATE_EXTENSION].range);
                moved = true;
            }
        }
        // operate spawn
        else if (operator.powers[PWR_OPERATE_SPAWN]
            && (operator.store.ops || 0) >= POWER_INFO[PWR_OPERATE_SPAWN].ops
            && !operator.powers[PWR_OPERATE_SPAWN].cooldown
            && this.getSpawnRequests().find(sr => Config.operateSpawnOperations.includes(sr.operation.constructor.name))
            && this.layout.spawns.some(s => !!s.spawning && (!s.effects || s.effects.length === 0))) {
            let spawnToOperate = this.layout.spawns.find(s => !!s.spawning && (!s.effects || s.effects.length === 0));
            if (operator.pos.inRangeTo(spawnToOperate.pos, POWER_INFO[PWR_OPERATE_SPAWN].range)) {
                operator.usePower(PWR_OPERATE_SPAWN, spawnToOperate);
                usedPower = true;
            }
            else {
                operator.goTo(spawnToOperate.pos, POWER_INFO[PWR_OPERATE_SPAWN].range);
                moved = true;
            }
        }
        // operate source
        else if (operator.powers[PWR_REGEN_SOURCE]
            && (operator.powers[PWR_REGEN_SOURCE].cooldown || 0) < 20
            && Game.time - (this.room.memory.lastUnsafe || 0) > 500
            && this.room.find(FIND_SOURCES).find(s => !s.effects || s.effects.length === 0)) {
            let sourceToRegen = this.room.find(FIND_SOURCES).find(s => !s.effects || s.effects.length === 0);
            if (operator.pos.inRangeTo(sourceToRegen.pos, POWER_INFO[PWR_REGEN_SOURCE].range)) {
                operator.usePower(PWR_REGEN_SOURCE, sourceToRegen);
                usedPower = true;
            }
            else {
                operator.goTo(sourceToRegen.pos, POWER_INFO[PWR_REGEN_SOURCE].range);
                moved = true;
            }
        }
        else if (!operator.pos.inRangeTo(this.layout.roomPlan.pos, 2)) {
            operator.goTo(this.layout.storage.pos, 2);
            moved = true;
        }
        // gen ops
        if (operator.powers[PWR_GENERATE_OPS] && !operator.powers[PWR_GENERATE_OPS].cooldown && !usedPower)
            operator.usePower(PWR_GENERATE_OPS);
        if (!moved)
            operator.giveWay();
    }
    // ---------------------------------------------------------------------
    createMine(serializedSourcePos) {
        const roadCost = 10;
        const roadCreationOpts = {
            plainCost: 12,
            swampCost: 15,
            maxOps: 20000,
            roomCallback: (aRoomName) => {
                let costMatrix = new PathFinder.CostMatrix();
                let modulePlans = [
                    this.layout.roomPlan.core[8],
                    this.layout.roomPlan.extraction,
                    this.layout.roomPlan.upgradeSite,
                    ...Object.values(this.layout.roomPlan.mines).filter(m => {
                        if (!this.memory['updatedMines'])
                            return true;
                        if (this.memory['updatedMines'].includes(_.findKey(this.layout.roomPlan.mines, m)))
                            return true;
                        return false;
                    })
                ];
                for (let modulePlan of modulePlans) {
                    for (let key in modulePlan) {
                        let structureType = key;
                        if (structureType === STRUCTURE_RAMPART)
                            continue;
                        let cost = (structureType === STRUCTURE_ROAD ? roadCost : structureType === STRUCTURE_CONTAINER ? 5 * roadCost : 0xff);
                        for (let pos of modulePlan[structureType]) {
                            if (pos.roomName === aRoomName) {
                                let value = costMatrix.get(pos.x, pos.y);
                                costMatrix.set(pos.x, pos.y, Math.max(value, cost));
                            }
                        }
                    }
                }
                let scoutedRoomIntel = GIntel.rooms[aRoomName];
                if (scoutedRoomIntel && scoutedRoomIntel.isSkRoom) {
                    for (let skSpot of scoutedRoomIntel.sourceKeeperSpots)
                        costMatrix.setArea(skSpot, 3, 45);
                }
                return costMatrix;
            }
        };
        let startPos = this.layout.roomPlan.pos;
        let sourcePos = RoomPosition.deserialize(serializedSourcePos);
        let searchResult = PathFinder.search(startPos, { pos: sourcePos, range: 1 }, roadCreationOpts);
        let containerPos = _.last(searchResult.path);
        if (!containerPos.isNearTo(sourcePos)) {
            console.log('failed adding mine module for ' + serializedSourcePos, 'last path pos:', containerPos, 'ops:', searchResult.ops);
            return false;
        }
        else {
            console.log('added mine module for ' + serializedSourcePos, 'conainer pos:', containerPos);
        }
        let linkPos;
        const linkPlans = this.layout.roomPlan.core[8][STRUCTURE_LINK];
        if (linkPlans && linkPlans.length > 0) {
            let terrain = Game.map.getRoomTerrain(this.roomName);
            for (let i = searchResult.path.length - 1; i && !linkPos; --i) {
                let tile = searchResult.path[i];
                if (tile.roomName !== this.roomName)
                    continue;
                for (let dir of DIRECTIONS_ALL) {
                    let nextToTile = tile.nextPosition(dir);
                    if (!nextToTile)
                        continue;
                    if (nextToTile.isExit())
                        continue;
                    if ((terrain.get(nextToTile.x, nextToTile.y) & TERRAIN_MASK_WALL) > 0)
                        continue;
                    if (DIRECTIONS_ALL.some(nextToNextDir => {
                        let nextToNext = nextToTile.nextPosition(nextToNextDir);
                        if (!nextToNext || nextToNext.isExit())
                            return true;
                        return false;
                    })) {
                        continue;
                    }
                    if (searchResult.path.find(p => p.isEqualTo(nextToTile)))
                        continue;
                    if (_.some(this.layout.roomPlan.mines, mine => mine.link && mine.link.length > 0 && mine.link[0].isEqualTo(nextToTile)))
                        continue;
                    if (_.some(this.layout.roomPlan.core[8], structures => _.some(structures, structurePos => structurePos.isEqualTo(nextToTile))))
                        continue;
                    linkPos = nextToTile;
                    break;
                }
            }
        }
        let buildings = {
            container: [containerPos],
            road: searchResult.path.slice(0, -1)
        };
        if (linkPos)
            buildings.link = [linkPos];
        this.layout.roomPlan.mines[serializedSourcePos] = buildings;
        this.layout.initModuleStatus();
        return true;
    }
    addOutpostOperations() {
        let added = [];
        this.outpostsToSave = this.outpostsToSave || [];
        let outpostRoomName = this.memory.potentialOutposts.find(potentialRemote => {
            if (Common.isHighway(potentialRemote) || this.outposts.find(o => o.roomName === potentialRemote) || Game.map.getRoomStatus(potentialRemote).status === 'closed') {
                added.push(potentialRemote);
                return false;
            }
            if (this.outpostsToSave.find(o => o.roomName === potentialRemote))
                return false;
            if (!GIntel.isScouted(potentialRemote))
                return false;
            return true;
        });
        if (outpostRoomName) {
            let minesAdded = 0;
            let minesExpected = 0;
            for (let sourcePos of GIntel.rooms[outpostRoomName].sources) {
                ++minesExpected;
                const mineId = sourcePos.serialize();
                let createMineResult = this.createMine(mineId);
                if (createMineResult)
                    ++minesAdded;
            }
            let isCenterRoom = Common.isCenterRoom(outpostRoomName);
            if (isCenterRoom) {
                ++minesExpected;
                const extractionId = GIntel.rooms[outpostRoomName].mineralPos.serialize();
                let createMineResult = this.createMine(extractionId);
                if (createMineResult)
                    ++minesAdded;
            }
            if (minesAdded === minesExpected) {
                let newOutpostMemory = OutpostRoom.create(this, outpostRoomName);
                if (newOutpostMemory) {
                    this.memory.outposts[newOutpostMemory.roomName] = newOutpostMemory;
                    let newOutpost = new OutpostRoom(outpostRoomName, this);
                    this.outpostsToSave.push(newOutpost);
                }
            }
            else {
                // no sources reachable in that room, remove it from list
                added.push(outpostRoomName);
            }
        }
        if (this.outpostsToSave.length > 0 && this.layout.serialize()) {
            for (let outpostToSave of this.outpostsToSave) {
                this.memory.outposts[outpostToSave.roomName] = outpostToSave.memory;
                this.outposts.push(outpostToSave);
                added.push(outpostToSave.roomName);
            }
            this.outpostsToSave = [];
        }
        this.memory.potentialOutposts = this.memory.potentialOutposts.filter(pr => !added.includes(pr));
        if (this.memory.potentialOutposts.length === 0)
            delete this.memory.potentialOutposts;
    }
    updateOutpostRoads() {
        if (this['serializeLayout'] && this.layout.serialize())
            delete this['serializeLayout'];
        if (!this.memory['updateRoads'])
            return;
        if (!this.memory['updatedMines'])
            this.memory['updatedMines'] = [];
        let serializedSourcePos = _(this.layout.roomPlan.mines)
            .keys()
            .filter(key => !this.memory['updatedMines'].includes(key))
            .min(key => this.layout.roomPlan.mines[key].road.length);
        if (!this.layout.roomPlan.mines[serializedSourcePos]) {
            delete this.memory['updateRoads'];
            delete this.memory['updatedMines'];
            return;
        }
        console.log('updating', serializedSourcePos);
        let createMineResult = this.createMine(serializedSourcePos);
        if (!createMineResult)
            delete this.layout.roomPlan.mines[serializedSourcePos];
        this.memory['updatedMines'].push(serializedSourcePos);
        this['serializeLayout'] = true;
    }
    // ---------------------------------------------------------------------
    runLinks() {
        const storageLink = this.layout.coreLink;
        if (storageLink && storageLink.store.energy === 0) {
            let energyThreshold = this.isLowEnergy() ? LINK_CAPACITY : 200;
            for (let link of this.layout.links) {
                if (!link.cooldown && link.energy >= energyThreshold) {
                    link.transferEnergy(storageLink);
                    break;
                }
            }
        }
    }
    // ---------------------------------------------------------------------
    updateStats() {
        if (this.layout.spawns.length > 0) {
            let activeSpawns = 0;
            for (let spawn of this.layout.spawns)
                if (spawn.spawning)
                    ++activeSpawns;
            activeSpawns /= this.layout.spawns.length;
            this.memory.stats.spawnUptime = activeSpawns / Config.ROOM_STATS_PERIOD + (this.memory.stats.spawnUptime || 0) * (Config.ROOM_STATS_PERIOD - 1) / Config.ROOM_STATS_PERIOD;
        }
        else
            this.memory.stats.spawnUptime = undefined;
        if (this.layout.labs.length > 0) {
            let activeLabs = 0;
            for (let lab of this.layout.labs)
                if (lab.cooldown > 0)
                    ++activeLabs;
            activeLabs /= this.layout.labs.length;
            this.memory.stats.labUptime = activeLabs / Config.ROOM_STATS_PERIOD + (this.memory.stats.labUptime || 0) * (Config.ROOM_STATS_PERIOD - 1) / Config.ROOM_STATS_PERIOD;
        }
        else
            this.memory.stats.labUptime = undefined;
    }
    // ---------------------------------------------------------------------
    unclaim() {
        for (let operation of this.operations) {
            operation.kill();
        }
        for (let outpost of this.outposts) {
            outpost.kill();
        }
        this.room.controller.unclaim();
    }
    // ---------------------------------------------------------------------
    run() {
        // TODO - get some ghodium to this room to generate safemode
        //this.memory.evacResources = (this.room.controller.safeModeAvailable === 0 || !!this.room.controller.safeModeCooldown);
        for (let operation of this.operations)
            operation.run();
        for (let outpost of this.activeOutposts)
            outpost.run();
        let startCpu = Game.cpu.getUsed();
        if (this.memory.potentialOutposts)
            this.addOutpostOperations();
        //
        this.spawnManager.run();
        this.labManager.run();
        this.factoryManager.run();
        //
        this.runLinks();
        //
        if (Memory.toggles.processPower && this.layout.powerSpawn)
            this.layout.powerSpawn.processPower();
        if (this.operator.creep)
            this.runOperator();
        //
        if (Memory.toggles.visualRoomPlan)
            this.layout.visualizeRoomPlan();
        if (Memory.toggles.visualSpawnQueue)
            this.renderSpawnQueue();
        //
        this.updateOutpostRoads();
        this.layout.updateLayout();
        //
        this.updateStats();
        this.tickCpu += Game.cpu.getUsed() - startCpu;
        const rollingPeriod = 1000;
        this.memory.stats.cpu = ((this.memory.stats.cpu || 0) * (rollingPeriod - 1) + this.tickCpu) / rollingPeriod;
        Stats.registerOperationCpu(this.constructor.name, this.tickCpu, this.memory.stats.cpu, 0);
    }
}
__decorate([
    profile()
], MyRoom.prototype, "getResourceBalance", null);
__decorate([
    profile()
], MyRoom.prototype, "initForTick", null);
__decorate([
    profile()
], MyRoom.prototype, "getRepairRequests", null);
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], MyRoom.prototype, "getSpawnRequests", null);
__decorate([
    profile()
], MyRoom.prototype, "renderSpawnQueue", null);
__decorate([
    check,
    profile()
], MyRoom.prototype, "runOperator", null);
__decorate([
    profile()
], MyRoom.prototype, "addOutpostOperations", null);
__decorate([
    check,
    profile()
], MyRoom.prototype, "run", null);

// ---------------------------------------------------------------------
let defaultMaxBuyAmount = {};
let defaultSendFilter = {};
let defaultMinimumStockUntillSell = {};
let defaultNoMarketValues = {};
for (let resourceType of RESOURCES_ALL) {
    defaultMaxBuyAmount[resourceType] = 3000;
    defaultSendFilter[resourceType] = 3000;
    defaultMinimumStockUntillSell[resourceType] = 3000;
    defaultNoMarketValues[resourceType] = 0;
}
// ---------------------------------------------------------------------
class Market {
    // ---------------------------------------------------------------------
    constructor() {
        Memory.market = Memory.market || {
            lastIncomingTransaction: '',
            lastOutgoingTransaction: '',
            lastPricesUpdate: 0,
            expectedTransactions: [],
            bannedTransactions: {},
            buyPricesMax: {},
            sellPricesMin: {},
            buyAvg: {},
            sellAvg: {},
            value: {},
            stddev: {},
            //
            lastHistoryCheck: 0
        };
        this.memory.buyPricesMax = this.memory.buyPricesMax || {};
        this.memory.sellPricesMin = this.memory.sellPricesMin || {};
        this.memory.expectedTransactions = this.memory.expectedTransactions || [];
        this.memory.bannedTransactions = this.memory.bannedTransactions || {};
        this.memory.buyAvg = this.memory.buyAvg || {};
        this.memory.sellAvg = this.memory.sellAvg || {};
        this.memory.value = this.memory.value || {};
        this.memory.stddev = this.memory.stddev || {};
        this.buyDealLock = {};
        this.sellDealLock = {};
        if (Config.hasMarket) {
            for (let orderId in Game.market.orders) {
                const order = Game.market.orders[orderId];
                if (order.type === ORDER_SELL)
                    this.sellDealLock[order.resourceType] = Game.time + Market.dealLockTime;
                else
                    this.buyDealLock[order.resourceType] = Game.time + Market.dealLockTime;
            }
        }
        this.lastMarketTick = Game.time;
    }
    get memory() {
        return Memory.market;
    }
    get resourceValue() {
        if (!Config.hasMarket)
            return Market.noMarketValues;
        if (_.isEmpty(this.memory.value))
            return Market.noMarketValues;
        return this.memory.value;
    }
    // ---------------------------------------------------------------------
    getMaximumTransferAmount(resourceType, energyInTerminal, distance) {
        const energyCostPerUnit = 1 - Math.exp(-distance / 30);
        if (resourceType === RESOURCE_ENERGY)
            return Math.floor(energyInTerminal / (1 + energyCostPerUnit));
        else
            return Math.floor(energyInTerminal / energyCostPerUnit);
    }
    // @profile()
    getEnergyProfit(roomName) {
        let energyBuyOrders = Game.market.getAllOrders({ resourceType: RESOURCE_ENERGY, type: ORDER_BUY });
        if (energyBuyOrders.length > 0) {
            return _(energyBuyOrders)
                .map(o => {
                if (this.memory.bannedTransactions[o.roomName])
                    return 0;
                const transportCost = Game.market.calcTransactionCost(1000, roomName, o.roomName);
                return o.price * 1000 / (1000 + transportCost);
            })
                .max();
        }
        else {
            return Market.defaultEnergyCost;
        }
    }
    shouldChangeBuyPrice(order) {
        return Math.abs(order.price - this.memory.buyPricesMax[order.resourceType]) / order.price > 0.1;
    }
    shouldChangeSellPrice(order) {
        return false;
    }
    // ---------------------------------------------------------------------
    // @profile()
    send(sourceRoomName, sinkRoomName, resourceType, amount, ignoreSendFilter) {
        if (sourceRoomName === sinkRoomName)
            return 0;
        if (this.usedTerminal.includes(sourceRoomName))
            return 0;
        const sourceRoom = Game.rooms[sourceRoomName];
        const sinkRoom = Game.rooms[sinkRoomName];
        const distance = Game.map.getRoomLinearDistance(sourceRoomName, sinkRoomName, true);
        const limitedByEnergy = this.getMaximumTransferAmount(resourceType, sourceRoom.terminal.store.energy, distance);
        const actualAmount = Math.min(amount, sourceRoom.terminal.store[resourceType] || 0, sinkRoom.terminal.store.getFreeCapacity(), limitedByEnergy);
        const transportCost = Game.market.calcTransactionCost(actualAmount, sourceRoomName, sinkRoomName);
        if (!ignoreSendFilter && actualAmount < Market.sendFilter[resourceType])
            return 0;
        const result = sourceRoom.terminal.send(resourceType, actualAmount, sinkRoomName);
        if (result !== OK) {
            console.log(resourceType, 'amount:', amount, 'actualAmount:', actualAmount, 'transportCost:', transportCost, sourceRoomName, '=>', sinkRoomName, result);
            return 0;
        }
        sinkRoom.myRoom.updateTerminalDistributionRequests();
        Stats.registerSpending(sourceRoomName, 'MarketSend', transportCost);
        this.usedTerminal.push(sourceRoomName);
        return actualAmount;
    }
    // @profile()
    forceSell(roomName, resourceType, amount) {
        if (this.usedTerminal.includes(roomName))
            return;
        let buyOrders = Game.market.getAllOrders({
            resourceType: resourceType
        }).filter(o => {
            const roomIntel = GIntel.rooms[o.roomName];
            if (o.type !== ORDER_BUY)
                return false;
            if (roomIntel && roomIntel.isMy)
                return false;
            if (this.memory.bannedTransactions[o.id])
                return false;
            if (roomIntel && roomIntel.owner && (!Memory.toggles.tradeWithPlayers || Config.EMBARGO.has(roomIntel.owner)))
                return false;
            return true;
        });
        if (buyOrders.length === 0)
            return;
        const room = Game.rooms[roomName];
        const energyProfit = this.getEnergyProfit(roomName);
        const bestOrder = _.max(buyOrders, o => o.price * 1000 - energyProfit * Game.market.calcTransactionCost(1000, roomName, o.roomName));
        const distance = Game.map.getRoomLinearDistance(roomName, bestOrder.roomName, true);
        const limitedByEnergy = this.getMaximumTransferAmount(resourceType, room.terminal.store.energy || 0, distance);
        const actualAmount = Math.min(room.terminal.store[resourceType] || 0, amount, bestOrder.amount, limitedByEnergy);
        //console.log(roomName, resourceType, room.storage.store[resourceType], terminalStore, amount, bestOrder.amount, limitedByEnergy, transportCost);
        if (actualAmount === 0)
            return;
        let result = Game.market.deal(bestOrder.id, actualAmount, roomName);
        if (result === OK) {
            room.myRoom.updateTerminalDistributionRequests();
            this.memory.expectedTransactions.push(bestOrder.id);
            ++this.dealsMade;
            this.usedTerminal.push(roomName);
            Stats.registerCreditChange(roomName, 2 /* EMarketActivityType.TransactionForceSell */, resourceType, bestOrder.price * actualAmount);
            this.sellDealLock[resourceType] = Game.time + Market.dealLockTime;
        }
        const isNPC = Common.isHighway(bestOrder.roomName);
        const transportCost = Game.market.calcTransactionCost(actualAmount, roomName, bestOrder.roomName);
        console.log('<font color="' + RESOURCE_COLORS[resourceType] + '" type="highlight">' +
            'SELL: ' + roomName + '->' + bestOrder.roomName +
            ' ' + (actualAmount * bestOrder.price).toFixed(3) + ' credits' +
            ', id: ' + bestOrder.id +
            ', resource: ' + resourceType +
            ', price: ' + bestOrder.price +
            ', energyProfit: ' + energyProfit +
            ', amount: ' + actualAmount +
            ', transportCost: ' + transportCost +
            ', result: ' + result +
            (isNPC ? ' ---NPC---</font>' : '</font>'));
    }
    sell(roomName, resourceType, amount) {
        if (!Market.sellList.includes(resourceType))
            return;
        if (Market.forceSellList.has(resourceType)) {
            if (this.dealsMade < Market.maxDealsPerTick)
                this.forceSell(roomName, resourceType, amount);
            return;
        }
        if (!Memory.toggles.tradeWithPlayers)
            return;
        let order = _.find(Game.market.orders, (o) => {
            if (o.type !== ORDER_SELL)
                return false;
            if (o.resourceType !== resourceType)
                return false;
            if (o.roomName !== roomName)
                return false;
            return true;
        });
        const resourceSellValue = this.memory.sellPricesMin[resourceType];
        // create order
        if (!order && resourceSellValue) {
            const result = Game.market.createOrder({
                type: ORDER_SELL,
                resourceType: resourceType,
                price: resourceSellValue,
                totalAmount: amount,
                roomName: roomName
            });
            if (result === OK) {
                const operationCost = resourceSellValue * amount * 0.05;
                Stats.registerCreditChange(roomName, 5 /* EMarketActivityType.CreateSellOrder */, resourceType, -operationCost);
                this.availableCredits -= operationCost;
                this.sellDealLock[resourceType] = Game.time + Market.dealLockTime;
            }
        }
        // force sell - there is no sell order market
        else if (!order && this.dealsMade < Market.maxDealsPerTick) {
            this.forceSell(roomName, resourceType, amount);
        }
        // change price
        else if (this.shouldChangeSellPrice(order)) {
            const result = Game.market.changeOrderPrice(order.id, resourceSellValue);
            if (result === OK && order.price < resourceSellValue) {
                const operationCost = (resourceSellValue - order.price) * order.remainingAmount * 0.05;
                Stats.registerCreditChange(roomName, 7 /* EMarketActivityType.AlterSellOrder */, resourceType, -operationCost);
            }
        }
        // force sell - sell orders weren't fulfilled for some time
        else if (order.remainingAmount > 0 && (this.sellDealLock[resourceType] || Infinity) <= Game.time && this.dealsMade < Market.maxDealsPerTick) {
            this.forceSell(roomName, resourceType, amount);
        }
        // extend order
        else if (order.remainingAmount < amount) {
            const addAmount = amount - order.remainingAmount;
            const result = Game.market.extendOrder(order.id, addAmount);
            if (result === OK) {
                const operationCost = order.price * addAmount * 0.05;
                Stats.registerCreditChange(roomName, 5 /* EMarketActivityType.CreateSellOrder */, resourceType, -operationCost);
                this.availableCredits -= operationCost;
                this.sellDealLock[resourceType] = Game.time + Market.dealLockTime;
            }
        }
    }
    // @profile()
    forceBuy(roomName, resourceType, amount) {
        if (this.usedTerminal.includes(roomName))
            return;
        if (resourceType === RESOURCE_ENERGY)
            return;
        let mineralSellOrders = Game.market.getAllOrders({
            resourceType: resourceType
        }).filter(o => {
            const roomIntel = GIntel.rooms[o.roomName];
            if (o.type !== ORDER_SELL)
                return false;
            if (roomIntel && roomIntel.isMy)
                return false;
            if (this.memory.bannedTransactions[o.id])
                return false;
            if (roomIntel && roomIntel.owner && (!Memory.toggles.tradeWithPlayers || Config.EMBARGO.has(roomIntel.owner)))
                return false;
            return true;
        });
        if (mineralSellOrders.length === 0)
            return;
        const room = Game.rooms[roomName];
        const energyProfit = this.getEnergyProfit(roomName);
        const bestOrder = _.min(mineralSellOrders, o => o.price * 1000 + energyProfit * Game.market.calcTransactionCost(1000, roomName, o.roomName));
        // anti scam
        const buyOrderPrice = this.memory.buyPricesMax[resourceType];
        if (buyOrderPrice && bestOrder.price > 2 * buyOrderPrice)
            return;
        const distance = Game.map.getRoomLinearDistance(roomName, bestOrder.roomName, true);
        const limitedByEnergy = this.getMaximumTransferAmount(resourceType, room.terminal.store.energy || 0, distance);
        const transportCost = Game.market.calcTransactionCost(amount, roomName, bestOrder.roomName);
        const actualAmount = Math.min(amount, bestOrder.amount, limitedByEnergy, Math.floor(Game.market.credits / bestOrder.price));
        if (actualAmount === 0)
            return;
        let result = Game.market.deal(bestOrder.id, actualAmount, roomName);
        if (result === OK) {
            room.myRoom.updateTerminalDistributionRequests();
            ++this.dealsMade;
            Stats.registerCreditChange(roomName, 3 /* EMarketActivityType.TransactionForceBuy */, resourceType, -bestOrder.price * actualAmount);
            this.usedTerminal.push(roomName);
            this.buyDealLock[resourceType] = Game.time + Market.dealLockTime;
        }
        const isNPC = Common.isHighway(bestOrder.roomName);
        console.log('<font color="' + RESOURCE_COLORS[resourceType] + '" type="highlight">' +
            'BUY: ' + roomName + '->' + bestOrder.roomName +
            ' ' + (-actualAmount * bestOrder.price).toFixed(3) + ' credits' +
            ', resource: ' + resourceType +
            ', price: ' + bestOrder.price +
            ', amount: ' + actualAmount +
            ', transportCost: ' + transportCost +
            ', result: ' + result +
            (isNPC ? ' ---NPC---</font>' : '</font>'));
    }
    // @profile()
    buy(roomName, resourceType, amount) {
        if (!Market.buyList.includes(resourceType))
            return;
        if (resourceType === GIntel.rooms[roomName].mineralType)
            return;
        if (resourceType === RESOURCE_POWER && (Game.rooms[roomName].controller.level < 8 || Game.market.credits < Market.powerBuyThreshold))
            return;
        let order = _.find(Game.market.orders, (o) => {
            if (o.type !== ORDER_BUY)
                return false;
            if (o.resourceType !== resourceType)
                return false;
            if (o.roomName !== roomName)
                return false;
            return true;
        });
        const resourceBuyValue = this.memory.buyPricesMax[resourceType];
        // create order
        if (Memory.toggles.tradeWithPlayers && !order && resourceBuyValue) {
            if (this.availableCredits >= resourceBuyValue * amount) {
                const result = Game.market.createOrder({
                    type: ORDER_BUY,
                    resourceType: resourceType,
                    price: resourceBuyValue,
                    totalAmount: amount,
                    roomName: roomName
                });
                if (result === OK) {
                    const operationCost = resourceBuyValue * amount * 0.05;
                    Stats.registerCreditChange(roomName, 4 /* EMarketActivityType.CreateBuyOrder */, resourceType, -operationCost);
                    this.availableCredits -= resourceBuyValue * amount + operationCost;
                    this.buyDealLock[resourceType] = Game.time + Market.dealLockTime;
                }
            }
        }
        // force buy - there is no buy order market
        else if ((!Memory.toggles.tradeWithPlayers || !order) && this.dealsMade < Market.maxDealsPerTick) {
            this.forceBuy(roomName, resourceType, amount);
        }
        // change price
        else if (this.shouldChangeBuyPrice(order)) {
            const result = Game.market.changeOrderPrice(order.id, resourceBuyValue);
            if (result === OK && order.price < resourceBuyValue) {
                const operationCost = (resourceBuyValue - order.price) * order.remainingAmount * 0.05;
                Stats.registerCreditChange(roomName, 6 /* EMarketActivityType.AlterBuyOrder */, resourceType, -operationCost);
            }
        }
        // force buy - buy orders weren't fulfilled for some time
        else if (order.remainingAmount > 0 && Game.time <= (this.buyDealLock[resourceType] || Infinity) && this.dealsMade < Market.maxDealsPerTick) {
            this.forceBuy(roomName, resourceType, order.remainingAmount);
        }
        // extend order
        else if (order.remainingAmount < amount) {
            const addAmount = amount - order.remainingAmount;
            if (this.availableCredits >= addAmount * order.price) {
                const result = Game.market.extendOrder(order.id, addAmount);
                if (result === OK) {
                    const operationCost = order.price * addAmount * 0.05;
                    Stats.registerCreditChange(roomName, 4 /* EMarketActivityType.CreateBuyOrder */, resourceType, -operationCost);
                    this.availableCredits -= addAmount * order.price + operationCost;
                    this.buyDealLock[resourceType] = Game.time + Market.dealLockTime;
                }
            }
        }
    }
    updatePrices() {
        if (!Config.hasMarket)
            return;
        if (this.memory.lastPricesUpdate && Game.time - this.memory.lastPricesUpdate < Market.priceUpdatePeriod)
            return;
        // update from daily market history
        if ((this.memory.lastHistoryCheck || 0) < Date.now() - 86400000) {
            let history = Game.market.getHistory();
            if (history && _.isArray(history) && history.length > 0) {
                const lastDate = _.max(history, h => h.date).date;
                for (let entry of history) {
                    if (entry.date === lastDate) {
                        this.memory.value[entry.resourceType] = entry.avgPrice;
                        this.memory.stddev[entry.resourceType] = entry.stddevPrice;
                    }
                }
            }
            this.memory.lastHistoryCheck = Date.now();
        }
        let marketData = {};
        for (let resourceType of MARKET_RESOURCES_ALL) {
            marketData[resourceType] = {
                avgBuyPrice: 0,
                buyVolume: 0,
                maxBuyPrice: 0,
                avgSellPrice: 0,
                sellVolume: 0,
                minSellPrice: Infinity
            };
        }
        const allOrders = Game.market.getAllOrders();
        for (let order of allOrders) {
            let resourceData = marketData[order.resourceType];
            if (order.type === ORDER_BUY) {
                resourceData.avgBuyPrice += order.price * order.amount;
                resourceData.buyVolume += order.amount;
                if (resourceData.maxBuyPrice < order.price)
                    resourceData.maxBuyPrice = order.price;
            }
            else {
                resourceData.avgSellPrice += order.price * order.amount;
                resourceData.sellVolume += order.amount;
                if (resourceData.minSellPrice > order.price)
                    resourceData.minSellPrice = order.price;
            }
        }
        for (let resourceType of MARKET_RESOURCES_ALL) {
            let resourceData = marketData[resourceType];
            if (resourceData.buyVolume > 0) {
                resourceData.avgBuyPrice /= resourceData.buyVolume;
                this.memory.buyAvg[resourceType] = resourceData.avgBuyPrice;
                this.memory.buyPricesMax[resourceType] = this.memory.buyPricesMax[resourceType] || resourceData.maxBuyPrice;
                this.memory.buyPricesMax[resourceType] = rollingAvg(this.memory.buyPricesMax[resourceType], resourceData.maxBuyPrice, Market.priceRollingPeriod);
            }
            if (resourceData.sellVolume > 0) {
                resourceData.avgSellPrice /= resourceData.sellVolume;
                this.memory.sellAvg[resourceType] = resourceData.avgSellPrice;
                this.memory.sellPricesMin[resourceType] = this.memory.sellPricesMin[resourceType] || resourceData.minSellPrice;
                this.memory.sellPricesMin[resourceType] = rollingAvg(this.memory.sellPricesMin[resourceType], resourceData.minSellPrice, Market.priceRollingPeriod);
            }
        }
        this.memory.lastPricesUpdate = Game.time;
    }
    // ---------------------------------------------------------------------
    // @profile()
    logTransactions() {
        let transactionsLog = '';
        let lastIncomingTransactionI = Game.market.incomingTransactions.findIndex(t => t.transactionId === this.memory.lastIncomingTransaction);
        if (lastIncomingTransactionI === -1)
            lastIncomingTransactionI = Game.market.incomingTransactions.length;
        for (let i = 0; i < lastIncomingTransactionI; ++i) {
            let transaction = Game.market.incomingTransactions[i];
            if (transaction.order && (!transaction.sender || transaction.sender.username !== Common.USERNAME)) {
                transactionsLog += '<font color="' + RESOURCE_COLORS[transaction.resourceType] + '" type="highlight">'
                    + 'BUY '
                    + transaction.amount + '*' + transaction.resourceType + ', '
                    + transaction.order.price + 'cr, '
                    + transaction.from + ' (' + (transaction.sender ? transaction.sender.username : '?') + ') -> ' + transaction.to
                    + '</font><br/>';
                Stats.registerCreditChange(transaction.to, 1 /* EMarketActivityType.TransactionBuy */, transaction.resourceType, -transaction.order.price * transaction.amount);
                this.buyDealLock[transaction.resourceType] = Game.time + Market.dealLockTime;
            }
            else {
                transactionsLog += '<font color="' + RESOURCE_COLORS[transaction.resourceType] + '" type="highlight">'
                    + transaction.amount + '*' + transaction.resourceType + ', '
                    + transaction.from + ' -> ' + transaction.to
                    + '</font><br/>';
            }
        }
        let lastOutgoingTransactionI = Game.market.outgoingTransactions.findIndex(t => t.transactionId === this.memory.lastOutgoingTransaction);
        if (lastOutgoingTransactionI === -1)
            lastOutgoingTransactionI = Game.market.outgoingTransactions.length;
        for (let i = 0; i < lastOutgoingTransactionI; ++i) {
            let transaction = Game.market.outgoingTransactions[i];
            if (transaction.order && (!transaction.recipient || transaction.recipient.username !== Common.USERNAME)) {
                transactionsLog += '<font color="' + RESOURCE_COLORS[transaction.resourceType] + '" type="highlight">'
                    + 'SELL '
                    + transaction.amount + '*' + transaction.resourceType + ', '
                    + transaction.order.price + 'cr, '
                    + transaction.from + ' -> ' + transaction.to + ' (' + (transaction.recipient ? transaction.recipient.username : '?') + ')'
                    + '</font><br/>';
                Stats.registerCreditChange(transaction.to, 0 /* EMarketActivityType.TransactionSell */, transaction.resourceType, transaction.order.price * transaction.amount);
                this.sellDealLock[transaction.resourceType] = Game.time + Market.dealLockTime;
            }
        }
        if (transactionsLog.length > 0)
            console.log(transactionsLog);
        if (Game.market.incomingTransactions[0])
            this.memory.lastIncomingTransaction = Game.market.incomingTransactions[0].transactionId;
        if (Game.market.outgoingTransactions[0])
            this.memory.lastOutgoingTransaction = Game.market.outgoingTransactions[0].transactionId;
    }
    buyPixels() {
        if (Game.market.credits < Market.pixelBuyThreshold)
            return;
        if (this.dealsMade >= Market.maxDealsPerTick)
            return;
        const history = Game.market.getHistory(PIXEL);
        if (!history || !_.isArray(history) || history.length === 0)
            return;
        const lastDayPrices = _.findLast(history, price => price.stddevPrice < price.avgPrice * 2);
        if (!lastDayPrices)
            return;
        const maxPrice = lastDayPrices.avgPrice;
        const sellOrders = Game.market.getAllOrders(o => {
            if (o.resourceType !== PIXEL)
                return false;
            if (o.type !== ORDER_SELL)
                return false;
            if (o.price > maxPrice)
                return false;
            return true;
        });
        sellOrders.sort((a, b) => a.price - b.price);
        let creditsAvailable = Game.market.credits - 5000000;
        while (sellOrders.length > 0 && this.dealsMade < Market.maxDealsPerTick && creditsAvailable > 0) {
            const order = sellOrders.shift();
            const amount = Math.min(order.remainingAmount, Math.floor(creditsAvailable / order.price));
            const result = Game.market.deal(order.id, amount);
            if (result === OK)
                Stats.registerCreditChange('none', 1 /* EMarketActivityType.TransactionBuy */, PIXEL, -order.price * amount);
            creditsAvailable -= amount * order.price;
            ++this.dealsMade;
        }
    }
    updateBannedOrders() {
        for (let expected of this.memory.expectedTransactions)
            if (!Game.market.outgoingTransactions.find(t => t.order && t.order.id === expected)) {
                console.log('banning order id:', expected);
                this.memory.bannedTransactions[expected] = Game.time + 1000;
            }
        this.memory.expectedTransactions.length = 0;
        for (let id in this.memory.bannedTransactions)
            if (this.memory.bannedTransactions[id] < Game.time)
                delete this.memory.bannedTransactions[id];
    }
    cleanUpMyOrders() {
        for (let orderId in Game.market.orders) {
            let order = Game.market.orders[orderId];
            if (order.type === ORDER_BUY && !Game.market.orders[orderId].active)
                Game.market.cancelOrder(orderId);
        }
    }
    // ---------------------------------------------------------------------
    sendRequestedResources(myRooms) {
        for (let mr of myRooms) {
            if (!mr.room.terminal)
                continue;
            const interRoomResourceRequests = mr.getInterRoomResourceRequests();
            for (let request of interRoomResourceRequests) {
                let sourceRoom = myRooms.find(sr => {
                    if (sr === mr)
                        return false;
                    if (!sr.room.terminal)
                        return false;
                    if (this.usedTerminal.includes(sr.roomName))
                        return false;
                    if (sr.room.terminal.store.getUsedCapacity(request.resource) === 0)
                        return false;
                    return true;
                });
                if (sourceRoom)
                    this.send(sourceRoom.roomName, mr.roomName, request.resource, Math.min(request.amount, sourceRoom.room.terminal.store[request.resource]), true);
            }
        }
    }
    // ---------------------------------------------------------------------
    run(myRooms) {
        // apparently accessing Game.market.incomingTransactions for the first time is expensive
        if (Game.time % 10 === 1)
            this.logTransactions();
        this.updateBannedOrders();
        const marketCooldown = TickSkipper.slowMarket ? 50 : 10;
        if (Game.time - this.lastMarketTick < marketCooldown)
            return;
        this.lastMarketTick = Game.time;
        this.updatePrices();
        if (Config.hasMarket && _.random(0, 99) === 0)
            this.cleanUpMyOrders();
        this.usedTerminal = [];
        this.dealsMade = 0;
        this.availableCredits = Game.market.credits;
        for (let orderId in Game.market.orders) {
            const order = Game.market.orders[orderId];
            if (order.type === ORDER_BUY) {
                this.availableCredits -= order.remainingAmount * order.price;
            }
        }
        this.sendRequestedResources(myRooms);
        const energyFunnelingFlag = _.find(Game.flags, f => f.name.startsWith('Funnel') && f.room && f.room.controller.my && f.room.terminal);
        const funnelRcl = energyFunnelingFlag === null || energyFunnelingFlag === void 0 ? void 0 : energyFunnelingFlag.color;
        const funnelRoom = energyFunnelingFlag && myRooms.find(mr => mr.roomName === energyFunnelingFlag.pos.roomName);
        const isFunneling = funnelRoom && funnelRoom.room.controller.level < funnelRcl;
        if (isFunneling) {
            let freeCapacity = (funnelRoom.room.storage && funnelRoom.room.storage.store.getFreeCapacity() || 0) + (funnelRoom.room.terminal && funnelRoom.room.terminal.store.getFreeCapacity() || 0);
            if (freeCapacity > 200000) {
                for (let mr of myRooms) {
                    if (mr.roomName === funnelRoom.roomName)
                        continue;
                    if (!mr.room.terminal)
                        continue;
                    if ((mr.room.storage && mr.room.storage.store[RESOURCE_ENERGY] || 0) + (mr.room.terminal && mr.room.terminal.store[RESOURCE_ENERGY] || 0) < 150000)
                        continue;
                    if ((mr.room.terminal.store[RESOURCE_ENERGY] || 0) < 15000)
                        continue;
                    let sendResult = this.send(mr.roomName, funnelRoom.roomName, RESOURCE_ENERGY, 15000, false);
                    console.log(mr.roomName, 'funneling energy to', funnelRoom.roomName, 'result=' + sendResult);
                    freeCapacity -= sendResult;
                    if (freeCapacity < 200000)
                        break;
                }
            }
        }
        let shuffledResources = _.shuffle(RESOURCES_ALL);
        for (let resourceType of shuffledResources) {
            const sellAll = Market.sellAllList.has(resourceType);
            const sendThreshold = Market.sendFilter[resourceType];
            const sellThreshold = sellAll ? 0 : Market.minimumStockUntillSell[resourceType];
            let tradingRooms = myRooms.filter(mr => {
                if (!mr.room.terminal)
                    return false;
                if (mr.evacResources && resourceType !== RESOURCE_ENERGY)
                    return false;
                if (mr.room.find(FIND_FLAGS).find(f => f.name.startsWith('noBalance')))
                    return false;
                if (resourceType === RESOURCE_ENERGY && isFunneling && energyFunnelingFlag.pos.roomName === mr.roomName)
                    return false;
                return true;
            });
            let avg = _.sum(tradingRooms, mr => mr.getStoredResource(resourceType)) / tradingRooms.length;
            let sinkRooms = tradingRooms.filter(mr => {
                if (sellAll)
                    return false;
                if (mr.abandon)
                    return false;
                return mr.getStoredResource(resourceType) < avg;
            });
            let sinkAvg = _.sum(sinkRooms, mr => mr.getStoredResource(resourceType)) / sinkRooms.length;
            let buyRooms = [];
            let sourceRooms = [];
            let sellRooms = [];
            for (let mr of tradingRooms) {
                const stored = mr.getStoredResource(resourceType);
                const balance = sellAll ? stored : mr.getResourceBalance()[resourceType];
                if (stored >= sinkAvg + sendThreshold)
                    sourceRooms.push(mr);
                if (balance === undefined || balance > sellThreshold)
                    sellRooms.push(mr);
                if (!sellAll && balance !== undefined && balance < 0)
                    buyRooms.push(mr);
            }
            if (sourceRooms.length > 0)
                buyRooms.length = 0;
            if (sourceRooms.length === 0 && sinkRooms.length === 0 && sellRooms.length === 0 && buyRooms.length === 0)
                continue;
            sourceRooms = _.shuffle(sourceRooms);
            sinkRooms = _.shuffle(sinkRooms);
            sellRooms = _.shuffle(sellRooms);
            buyRooms = _.shuffle(buyRooms);
            if (Memory.toggles.logMarketDebug) {
                console.log('<font color="' + RESOURCE_COLORS[resourceType] + '" type="highlight">'
                    + 'resource: ' + resourceType
                    + ', sendThreshold: ' + sendThreshold
                    + ', sellThreshold: ' + sellThreshold
                    + ', avg: ' + avg
                    + ', sourceRooms:' + JSON.stringify(sourceRooms.map(s => s.roomName))
                    + ', sinkRooms:' + JSON.stringify(sinkRooms.map(s => s.roomName))
                    + ', sellRooms:' + JSON.stringify(sellRooms.map(s => s.roomName))
                    + ', buyRooms:' + JSON.stringify(buyRooms.map(s => s.roomName))
                    + '</font>');
            }
            // send
            let gathered = {};
            for (let i = 0; i < sourceRooms.length && sinkRooms.length > 0; ++i) {
                let sourceRoom = sourceRooms[i];
                sinkRooms.sort((a, b) => Game.map.getRoomLinearDistance(sourceRoom.roomName, a.roomName, true) - Game.map.getRoomLinearDistance(sourceRoom.roomName, b.roomName, true));
                for (let sinkRoom of sinkRooms) {
                    let sinkRoomName = sinkRoom.roomName;
                    let sourceRoomAmount = sourceRoom.getStoredResource(resourceType);
                    let sinkRoomAmount = sinkRoom.getStoredResource(resourceType);
                    let amount = (sourceRoomAmount - sinkRoomAmount) / 2;
                    let sendResult = this.send(sourceRoom.roomName, sinkRoomName, resourceType, amount, false);
                    gathered[sinkRoomName] = gathered[sinkRoomName] || 0;
                    gathered[sinkRoomName] += sendResult;
                    let terminalFreeCapacity = Game.rooms[sinkRoomName].terminal.store.getFreeCapacity();
                    if (gathered[sinkRoomName] + avg - sinkRoomAmount >= 0 || gathered[sinkRoomName] >= terminalFreeCapacity)
                        _.remove(sinkRooms, sinkRoom);
                    if (sendResult > 0)
                        break;
                }
            }
            if (Config.hasMarket) {
                // sell
                for (let room of sellRooms)
                    this.sell(room.roomName, resourceType, sellAll
                        ? room.getStoredResource(resourceType)
                        : Math.min(Market.maxSellAmount[resourceType], room.getResourceBalance()[resourceType] - sellThreshold));
                // buy
                for (let room of buyRooms)
                    this.buy(room.roomName, resourceType, Math.min(Market.maxBuyAmount[resourceType], -room.getResourceBalance()[resourceType]));
            }
        }
        // resource evac
        for (let mr of myRooms) {
            if ((mr.abandon || mr.evacResources || mr.room.find(FIND_FLAGS).find(f => f.name.startsWith('noBalance'))) && mr.room.terminal) {
                let resource = _.findKey(mr.room.terminal.store, (amount, resourceType) => !!amount && resourceType !== RESOURCE_ENERGY);
                if (resource) {
                    let sinkRoom = _.sample(myRooms.filter(r => !r.evacResources && r.room.terminal && r.room.terminal.store.getFreeCapacity() > 50000));
                    this.send(mr.roomName, sinkRoom.roomName, resource, mr.room.terminal.store.getUsedCapacity(resource), true);
                }
                else if (mr.abandon && mr.room.terminal.store[RESOURCE_ENERGY]) {
                    let sinkRoom = _.sample(myRooms.filter(r => !r.evacResources && r.room.terminal && r.room.terminal.store.getFreeCapacity() > 50000));
                    this.send(mr.roomName, sinkRoom.roomName, RESOURCE_ENERGY, mr.room.terminal.store.getUsedCapacity(RESOURCE_ENERGY), true);
                }
            }
        }
        if (Config.isPixelsShard) {
            this.buyPixels();
        }
    }
}
Market.noMarketValues = Object.assign(Object.assign({}, defaultNoMarketValues), { energy: 0.1, O: 1, H: 1, Z: 1, K: 1, L: 1, U: 1, X: 3 });
Market.maxBuyAmount = Object.assign(Object.assign({}, defaultMaxBuyAmount), { energy: 10000 });
Market.maxSellAmount = Object.assign({}, defaultMaxBuyAmount);
Market.sendFilter = Object.assign(Object.assign({}, defaultSendFilter), { energy: 10000, power: 300, ops: 200 });
Market.minimumStockUntillSell = Object.assign(Object.assign({}, defaultMinimumStockUntillSell), { energy: 100000, default: 3000 });
Market.powerBuyThreshold = 1000000;
Market.pixelBuyThreshold = 5000000;
Market.defaultEnergyCost = 1;
Market.balanceCD = 10;
Market.dealLockTime = 1000;
Market.maxDealsPerTick = 10;
Market.buyList = [
    RESOURCE_ENERGY,
    RESOURCE_OXYGEN,
    RESOURCE_HYDROGEN,
    RESOURCE_KEANIUM,
    RESOURCE_LEMERGIUM,
    RESOURCE_ZYNTHIUM,
    RESOURCE_UTRIUM,
    RESOURCE_CATALYST,
    //
    RESOURCE_POWER
];
Market.sellList = [
    RESOURCE_ENERGY,
    RESOURCE_OXYGEN,
    RESOURCE_HYDROGEN,
    RESOURCE_KEANIUM,
    RESOURCE_LEMERGIUM,
    RESOURCE_ZYNTHIUM,
    RESOURCE_UTRIUM,
    RESOURCE_CATALYST,
    //
    RESOURCE_OPS,
    //
    RESOURCE_METAL,
    RESOURCE_BIOMASS,
    RESOURCE_SILICON,
    RESOURCE_MIST,
    //
    RESOURCE_POWER
];
Market.forceSellList = new Set([
    RESOURCE_METAL,
    RESOURCE_BIOMASS,
    RESOURCE_SILICON,
    RESOURCE_MIST
]);
Market.sellAllList = new Set([
    RESOURCE_METAL,
    RESOURCE_BIOMASS,
    RESOURCE_SILICON,
    RESOURCE_MIST
]);
Market.priceUpdatePeriod = 150;
Market.priceRollingPeriod = 8;
__decorate([
    profile()
], Market.prototype, "updatePrices", null);
__decorate([
    check,
    profile()
], Market.prototype, "run", null);

class BaseStrategy {
    constructor(empire) {
        this.empire = empire;
    }
}

class BaseGlobalOperation extends BaseOperation {
    /// it's important that id starts with SomeOperation.OperationType because of stuff I did in Strategist constructor
    constructor(empire, id) {
        super(empire);
        this.id = id;
        if (this.memory && this.memory.spawnRoom)
            this.onAssignSpawnRoom();
    }
    get memory() {
        return Memory.operations[this.id];
    }
    get spawnRoomName() {
        return this.memory && this.memory.spawnRoom;
    }
    get roomName() {
        return this.memory && this.memory.roomName;
    }
    get spawnRoom() {
        return this.spawnRoomName && Game.rooms[this.spawnRoomName];
    }
    assignSpawnRoom(roomName) {
        const previousSpawnRoom = this.memory.spawnRoom;
        this.memory.spawnRoom = roomName;
        if (previousSpawnRoom !== roomName)
            this.onAssignSpawnRoom();
    }
    onAssignSpawnRoom() {
    }
    get readyToDelete() {
        return !this.memory || this.memory.closing && this.memory.creeps.length === 0;
    }
    deleteMemory() {
        delete Memory.operations[this.id];
    }
    close() {
        this.memory.closing = true;
    }
    abort() {
        for (let creep of this.creeps)
            this.dismissCreep(creep, true, true);
        this.memory.closing = true;
    }
    get isClosing() {
        return this.memory.closing;
    }
}
class BaseFlagOperation extends BaseGlobalOperation {
    constructor(empire, id) {
        super(empire, id);
    }
    init(roomName) {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            spawnRoom: undefined,
            closing: false,
            roomName: roomName
        };
        Memory.flags[this.flagName] = memory;
    }
    get memory() {
        return Memory.flags[this.id];
    }
    get readyToDelete() {
        return !this.flag || super.readyToDelete;
    }
    deleteMemory() {
        delete Memory.flags[this.id];
    }
    get flag() {
        return Game.flags[this.flagName];
    }
    get flagName() {
        return this.id;
    }
    get roomName() {
        return this.flag.pos.roomName;
    }
}

var rp;
(function (rp) {
    rp[rp["TILE_OBSTACLE"] = 1] = "TILE_OBSTACLE";
    rp[rp["TILE_INVALID"] = 2] = "TILE_INVALID";
    rp[rp["TILE_ROAD"] = 4] = "TILE_ROAD";
    rp[rp["TILE_UNBUILDABLE"] = 8] = "TILE_UNBUILDABLE";
    rp[rp["TILE_EXIT"] = 16] = "TILE_EXIT";
    rp[rp["TILE_URBANIZED"] = 32] = "TILE_URBANIZED";
    rp[rp["TILE_UPGRADE"] = 64] = "TILE_UPGRADE";
    rp[rp["TILE_TMP_SELECT"] = 128] = "TILE_TMP_SELECT";
    rp[rp["TILE_CLOSED_OFF"] = 256] = "TILE_CLOSED_OFF";
    rp[rp["TILE_MINE"] = 512] = "TILE_MINE";
    rp[rp["TILE_HOSTILE_REACHABLE"] = 2048] = "TILE_HOSTILE_REACHABLE";
    rp[rp["TILE_FORTIFICATION"] = 4096] = "TILE_FORTIFICATION";
    rp[rp["TILE_WALL"] = 8192] = "TILE_WALL";
    rp[rp["TILE_EXTRACTION"] = 16384] = "TILE_EXTRACTION";
    rp[rp["TILE_CHECKED"] = 1073741824] = "TILE_CHECKED";
})(rp || (rp = {}));
class RoomPlannerMatrix {
    constructor(roomName) {
        this.roomName = roomName;
        this.data = new Array(2500).fill(0);
    }
    get(x, y) {
        return this.data[y * 50 + x];
    }
    set(x, y, flag) {
        this.data[y * 50 + x] |= flag;
    }
    unset(x, y, flag) {
        this.data[y * 50 + x] &= ~flag;
    }
    findInRange(posX, posY, range, filter) {
        let result = [];
        let left = Math.max(0, posX - range);
        let top = Math.max(0, posY - range);
        let right = Math.min(49, posX + range);
        let bottom = Math.min(49, posY + range);
        for (let x = left; x <= right; ++x)
            for (let y = top; y <= bottom; ++y)
                if (this.check(x, y, filter))
                    result.push({
                        x: x,
                        y: y
                    });
        return result;
    }
    isInRange(posX, posY, range, filter) {
        let left = Math.max(0, posX - range);
        let top = Math.max(0, posY - range);
        let right = Math.min(49, posX + range);
        let bottom = Math.min(49, posY + range);
        for (let x = left; x <= right; ++x)
            for (let y = top; y <= bottom; ++y)
                if (this.check(x, y, filter))
                    return true;
        return false;
    }
    check(x, y, filter) {
        if (!filter)
            return true;
        let tile = this.data[y * 50 + x];
        if (typeof filter === 'function')
            return filter(x, y, tile);
        else
            return (!filter.is || (tile & filter.is) === filter.is) && (!filter.isNot || (tile & ~filter.isNot) === tile);
    }
    clear(filter, flag) {
        for (let y = 0; y < 50; ++y)
            for (let x = 0; x < 50; ++x)
                if (this.check(x, y, filter))
                    this.unset(x, y, flag);
    }
    fill(filter, flag) {
        for (let y = 0; y < 50; ++y)
            for (let x = 0; x < 50; ++x)
                if (this.check(x, y, filter))
                    this.set(x, y, flag);
    }
    floodFill(startX, startY, filter, flag, maxDepth = Infinity) {
        for (let i = 0; i < this.data.length; ++i)
            this.data[i] &= ~rp.TILE_CHECKED;
        let nodes = [{
                x: startX,
                y: startY,
                depth: 0
            }];
        do {
            let node = nodes.shift();
            for (let dir = TOP; dir <= TOP_LEFT; ++dir) {
                let newNode = {
                    x: node.x + Common.offsetX[dir],
                    y: node.y + Common.offsetY[dir],
                    depth: node.depth + 1
                };
                if (newNode.depth > maxDepth)
                    continue;
                if (newNode.x < 1 || newNode.x > 48 || newNode.y < 1 || newNode.y > 48)
                    continue;
                if (this.check(newNode.x, newNode.y, { is: rp.TILE_CHECKED }))
                    continue;
                if (!this.check(newNode.x, newNode.y, filter))
                    continue;
                this.set(newNode.x, newNode.y, flag | rp.TILE_CHECKED);
                nodes.push(newNode);
            }
        } while (nodes.length > 0);
    }
    bfs(startX, startY, obstacleFlags, leaveCondition) {
        for (let i = 0; i < this.data.length; ++i)
            this.data[i] &= ~rp.TILE_CHECKED;
        let nodes = [{
                x: startX,
                y: startY,
                depth: 0
            }];
        do {
            let node = nodes.shift();
            let x = node.x;
            let y = node.y;
            for (let dir in Common.offset) {
                let o = Common.offset[dir];
                let newX = x + o.x;
                let newY = y + o.y;
                let newDepth = node.depth + 1;
                if (newX < 1 || newX > 48 || newY < 1 || newY > 48)
                    continue;
                if (this.check(newX, newY, { is: rp.TILE_CHECKED }))
                    continue;
                if ((this.get(newX, newY) & obstacleFlags) > 0)
                    continue;
                if (this.check(newX, newY, leaveCondition)) {
                    return {
                        pos: new RoomPosition(newX, newY, this.roomName),
                        pathLength: newDepth
                    };
                }
                this.set(newX, newY, rp.TILE_CHECKED);
                nodes.push({
                    x: newX,
                    y: newY,
                    depth: newDepth
                });
            }
        } while (nodes.length > 0);
        return {
            pos: undefined,
            pathLength: Infinity
        };
    }
    updateHostileReachable() {
        for (let i = 0; i < this.data.length; ++i)
            this.data[i] &= ~rp.TILE_HOSTILE_REACHABLE;
        let exitTiles = Common.getExitTiles(this.roomName);
        exitTiles.forEach(e => {
            this.set(e.x, e.y, rp.TILE_HOSTILE_REACHABLE);
            this.floodFill(e.x, e.y, { is: 0, isNot: rp.TILE_OBSTACLE | rp.TILE_FORTIFICATION | rp.TILE_HOSTILE_REACHABLE }, rp.TILE_HOSTILE_REACHABLE);
        });
    }
    toCostMatrix() {
        let terrain = Game.map.getRoomTerrain(this.roomName);
        let cm = new PathFinder.CostMatrix();
        for (let x = 0; x < 50; ++x)
            for (let y = 0; y < 50; ++y)
                if (this.get(x, y) & (rp.TILE_ROAD))
                    cm.set(x, y, 10);
                else if ((terrain.get(x, y) & TERRAIN_MASK_WALL) > 0)
                    cm.set(x, y, 200);
                else if (this.get(x, y) & rp.TILE_OBSTACLE)
                    cm.set(x, y, 0xff);
                else if (this.get(x, y) & (rp.TILE_MINE | rp.TILE_EXTRACTION | rp.TILE_UPGRADE))
                    cm.set(x, y, 45);
        return cm;
    }
}
class RoomLayoutGenerator {
    constructor(roomName, initialSpawn, outRoomPlan) {
        this.roomName = roomName;
        this.initialSpawn = initialSpawn;
        this.outRoomPlan = outRoomPlan;
    }
    createBuildableDistanceCM(roomName) {
        let terrain = Game.map.getRoomTerrain(roomName);
        let distances = new Int16Array(2500).fill(0);
        let exits = Common.getExitTiles(roomName);
        for (let exit of exits)
            distances[exit.y * 50 + exit.x] = -1;
        for (let y = 1; y < 49; ++y)
            for (let x = 1; x < 49; ++x) {
                let index = y * 50 + x;
                if (terrain.get(x, y) & TERRAIN_MASK_WALL)
                    distances[index] = 0;
                else {
                    distances[index] = Math.min(distances[index - 50] + 1, distances[index - 1] + 1, distances[index - 51] + 1, distances[index - 49] + 1);
                }
            }
        for (let y = 48; y > 0; --y)
            for (let x = 48; x > 0; --x) {
                let index = y * 50 + x;
                distances[index] = Math.min(distances[index], distances[index + 50] + 1, distances[index + 1] + 1, distances[index + 51] + 1, distances[index + 49] + 1);
            }
        return distances;
    }
    createPathDistanceCM(origin, roomMatrix) {
        let distanceCM = new Int16Array(2500);
        let nodes = [{
                x: origin.x,
                y: origin.y,
                distance: 0
            }];
        do {
            let node = nodes.shift();
            for (let dir = TOP; dir <= TOP_LEFT; ++dir) {
                let newNode = {
                    x: node.x + Common.offsetX[dir],
                    y: node.y + Common.offsetY[dir],
                    distance: node.distance + 1
                };
                if (newNode.x < 1 || newNode.x > 48 || newNode.y < 1 || newNode.y > 48)
                    continue;
                let currentValue = distanceCM[newNode.y * 50 + newNode.x];
                if (currentValue !== 0 && currentValue <= newNode.distance)
                    continue;
                if (roomMatrix.get(newNode.x, newNode.y) & rp.TILE_OBSTACLE)
                    continue;
                distanceCM[newNode.y * 50 + newNode.x] = newNode.distance;
                nodes.push(newNode);
            }
        } while (nodes.length > 0);
        return distanceCM;
    }
    addBuildingsToRoomMatrix(roomMatrix, buildings, addFlags) {
        let terrain = Game.map.getRoomTerrain(roomMatrix.roomName);
        for (let entry in buildings) {
            let structureType = entry;
            buildings[structureType].forEach(s => {
                if (s.roomName !== roomMatrix.roomName)
                    return;
                if ((terrain.get(s.x, s.y) & TERRAIN_MASK_WALL) > 0 && structureType !== STRUCTURE_ROAD)
                    roomMatrix.set(s.x, s.y, rp.TILE_INVALID);
                if (structureType === STRUCTURE_ROAD)
                    roomMatrix.set(s.x, s.y, rp.TILE_ROAD);
                else if (structureType === STRUCTURE_CONTAINER) {
                    if (roomMatrix.get(s.x, s.y) & rp.TILE_UNBUILDABLE)
                        roomMatrix.set(s.x, s.y, rp.TILE_INVALID);
                }
                else if (structureType !== STRUCTURE_RAMPART) {
                    if (roomMatrix.get(s.x, s.y) & rp.TILE_UNBUILDABLE)
                        roomMatrix.set(s.x, s.y, rp.TILE_INVALID);
                    roomMatrix.set(s.x, s.y, rp.TILE_OBSTACLE);
                }
                roomMatrix.set(s.x, s.y, rp.TILE_URBANIZED);
                if (addFlags)
                    roomMatrix.set(s.x, s.y, addFlags);
            });
        }
    }
    createRoomMatrix(roomName) {
        let terrain = Game.map.getRoomTerrain(roomName);
        let roomMatrix = new RoomPlannerMatrix(roomName);
        roomMatrix.fill((x, y) => (terrain.get(x, y) & TERRAIN_MASK_WALL) > 0, rp.TILE_OBSTACLE | rp.TILE_WALL);
        Common.getExitTiles(roomName).forEach(e => {
            roomMatrix.set(e.x, e.y, rp.TILE_EXIT);
            let left = Math.max(0, e.x - 1);
            let top = Math.max(0, e.y - 1);
            let right = Math.min(49, e.x + 1);
            let bottom = Math.min(49, e.y + 1);
            for (let x = left; x <= right; ++x)
                for (let y = top; y <= bottom; ++y)
                    roomMatrix.set(x, y, rp.TILE_UNBUILDABLE);
        });
        return roomMatrix;
    }
    addUpgradeSite(corePos, plan, roomMatrix) {
        let controllerPos = GIntel.rooms[corePos.roomName].controllerPos;
        let r3 = roomMatrix.bfs(corePos.x, corePos.y, rp.TILE_OBSTACLE, (x, y, value) => {
            return !(value & rp.TILE_URBANIZED) && !(value & rp.TILE_UNBUILDABLE) && Math.max(Math.abs(x - controllerPos.x), Math.abs(y - controllerPos.y)) <= 3;
        });
        let r2 = roomMatrix.bfs(corePos.x, corePos.y, rp.TILE_OBSTACLE, (x, y, value) => {
            return !(value & rp.TILE_URBANIZED) && Math.max(Math.abs(x - controllerPos.x), Math.abs(y - controllerPos.y)) <= 2;
        });
        const MAX_R2_OVERHEAD = 3;
        let upgradeSitePos = (r2.pathLength - r3.pathLength <= MAX_R2_OVERHEAD) ? r2.pos : r3.pos;
        plan.upgradeSite = {
            [STRUCTURE_CONTAINER]: [upgradeSitePos],
            [STRUCTURE_ROAD]: []
        };
        for (let x = upgradeSitePos.x - 1; x <= upgradeSitePos.x + 1; ++x)
            for (let y = upgradeSitePos.y - 1; y <= upgradeSitePos.y + 1; ++y)
                if (roomMatrix.check(x, y, { isNot: rp.TILE_OBSTACLE }))
                    plan.upgradeSite[STRUCTURE_ROAD].push(new RoomPosition(x, y, corePos.roomName));
        this.addBuildingsToRoomMatrix(roomMatrix, plan.upgradeSite, rp.TILE_UPGRADE);
    }
    addExtraction(corePos, mineralPos, plan, roomMatrix, roadCreationOpts) {
        const pathToMineral = PathFinder.search(corePos, { pos: mineralPos, range: 1 }, roadCreationOpts).path;
        const newExtraction = {
            [STRUCTURE_CONTAINER]: [_.last(pathToMineral)],
            [STRUCTURE_EXTRACTOR]: [mineralPos]
        };
        plan.extraction = newExtraction;
        this.addBuildingsToRoomMatrix(roomMatrix, newExtraction, rp.TILE_EXTRACTION);
    }
    static createVisualizationData(plan) {
        let visualizationData = {
            roads: [],
            ramparts: [],
            buildings: []
        };
        const addModule = (structures, rcl) => {
            for (let key in structures) {
                let structureType = key;
                if (!structures[structureType])
                    continue;
                for (let structurePos of structures[structureType]) {
                    if (structureType === STRUCTURE_ROAD) {
                        if (!visualizationData.roads.find(r => r.pos.isEqualTo(structurePos)))
                            visualizationData.roads.push({ pos: structurePos, rcl: rcl });
                    }
                    else if (!visualizationData.buildings.find(s => s.structureType === structureType && s.pos.isEqualTo(structurePos))) {
                        visualizationData.buildings.push({
                            pos: structurePos,
                            structureType: structureType,
                            rcl: rcl
                        });
                    }
                }
            }
        };
        for (let id in plan.mines)
            addModule(plan.mines[id], 2);
        for (let i = 1; i <= 8; ++i)
            addModule(plan.core[i], i);
        addModule(plan.upgradeSite, 3);
        addModule(plan.extraction, 6);
        visualizationData.buildings.sort((a, b) => (a.structureType === STRUCTURE_RAMPART ? 50 + a.pos.y : a.pos.y) - (b.structureType === STRUCTURE_RAMPART ? 50 + b.pos.y : b.pos.y));
        return visualizationData;
    }
    static visualizePlan(plan) {
        const visualizationData = this.createVisualizationData(plan);
        const visual = new RoomVisual(plan.pos.roomName);
        // cover existing structures
        //let coverColor = {
        //  plain: '#2B2B2B',
        //  swamp: '#2B3B2B',
        //  };
        //for (let y=0; y<50; ++y)
        //  for (let x=0; x<50; ++x)
        //    {
        //    let terrain = Game.map.getRoomTerrain(this.memory.roomName).get(x, y);
        //    if (Game.rooms[this.memory.roomName] &&
        //        (terrain & TERRAIN_MASK_WALL) === 0 &&
        //        Game.rooms[this.memory.roomName].lookForAt(LOOK_STRUCTURES, x, y).length > 0)
        //      {
        //      Common.getRoomVisual(this.memory.roomName).rect(x-0.65, y-0.65, 1.3, 1.3, { fill: coverColor[terrain], opacity: 1 });
        //      }
        //    }
        //
        const rclToColor = {
            1: Common.hslToRgb(0.2, 1, 1),
            2: Common.hslToRgb(0.3, 1, 1),
            3: Common.hslToRgb(0.4, 1, 1),
            4: Common.hslToRgb(0.5, 1, 1),
            5: Common.hslToRgb(0.6, 1, 1),
            6: Common.hslToRgb(0.7, 1, 1),
            7: Common.hslToRgb(0.8, 1, 1),
            8: Common.hslToRgb(1, 1, 1)
        };
        const visualizeOpts = {
            opacity: 1 //0.75
        };
        //
        for (let s of visualizationData.roads)
            visual.structure(s.pos.x, s.pos.y, STRUCTURE_ROAD, visualizeOpts);
        visual.connectRoads(visualizeOpts);
        let dupes = visualizationData.buildings.filter((v, i, a) => v.structureType !== STRUCTURE_RAMPART && i !== a.findIndex(vv => vv.structureType !== STRUCTURE_RAMPART && vv.pos.isEqualTo(v)));
        for (let s of visualizationData.buildings) {
            visual.structure(s.pos.x, s.pos.y, s.structureType, visualizeOpts);
        }
        for (let r of visualizationData.ramparts) {
            visual.structure(r.x, r.y, STRUCTURE_RAMPART, visualizeOpts);
        }
        for (let dupe of dupes)
            visual.text('X', dupe.pos.x, dupe.pos.y + 0.25, { align: 'center', color: '#ff0000' });
    }
}

// require('util.min_cut').test('W5N9');
/**
 * Posted 10 may 2018 by @saruss
 *
 * Code for calculating the minCut in a room, written by Saruss
 * adapted (for Typescript by Chobobobo , is it somewhere?)
 * some readability added by Chobobobo @typescript was included here
 * (15Aug2019) Updated Game.map.getTerrainAt to Game.map.getRoomTerrain method -Shibdib
 * adapted for typescript by Robalian. Copied names and comments from Vipo's Kotlin implementation, for better clarity.
 * Added second way to define protected area - Robalian
 */
const UNWALKABLE = -1;
const NORMAL = 0;
const PROTECTED = 1;
const CANNOT_BUILD = 2;
const EXIT = 3;
/**
 * An Array with Terrain information: -1 not usable, 2 Sink (Leads to Exit)
 * @param room - the room to generate the terrain map from
 */
function getRoom2dArray(roomName, bounds = { x1: 0, y1: 0, x2: 49, y2: 49 }) {
    let result = new Array(50).fill(null).map(() => new Int8Array(50).fill(UNWALKABLE));
    const terrain = Game.map.getRoomTerrain(roomName);
    for (let i = bounds.x1; i <= bounds.x2; i++) {
        for (let j = bounds.y1; j <= bounds.y2; j++) {
            if (terrain.get(i, j) !== TERRAIN_MASK_WALL) {
                // mark unwalkable
                result[i][j] = NORMAL;
                if (i === bounds.x1 || j === bounds.y1 || i === bounds.x2 || j === bounds.y2)
                    // Sink Tiles mark from given bounds
                    result[i][j] = CANNOT_BUILD;
                if (i === 0 || j === 0 || i === 49 || j === 49)
                    // Exit Tiles mark
                    result[i][j] = EXIT;
            }
        }
    }
    // Marks tiles as unbuildable if they are proximate to exits
    for (let y = bounds.y1 + 1; y < bounds.y2; y++) {
        if (result[bounds.x1][y] === EXIT)
            for (let dy = -1; dy <= 1; ++dy)
                if (result[bounds.x1 + 1][y + dy] !== UNWALKABLE)
                    result[bounds.x1 + 1][y + dy] = CANNOT_BUILD;
        if (result[bounds.x2][y] === EXIT)
            for (let dy = -1; dy <= 1; ++dy)
                if (result[bounds.x2 - 1][y + dy] !== UNWALKABLE)
                    result[bounds.x2 - 1][y + dy] = CANNOT_BUILD;
    }
    for (let x = bounds.x1 + 1; x < bounds.x2; x++) {
        if (result[x][bounds.y1] === EXIT)
            for (let dx = -1; dx <= 1; ++dx)
                if (result[x + dx][bounds.y1 + 1] !== UNWALKABLE)
                    result[x + dx][bounds.y1 + 1] = CANNOT_BUILD;
        if (result[x][bounds.y2] === EXIT)
            for (let dx = -1; dx <= 1; ++dx)
                if (result[x + dx][bounds.y2 - 1] !== UNWALKABLE)
                    result[x + dx][bounds.y2 - 1] = CANNOT_BUILD;
    }
    return result;
}
class Graph {
    constructor(vertCount) {
        this.vertCount = vertCount;
        this.level = new Int32Array(vertCount);
        this.edges = new Array(vertCount).fill(0).map(() => []);
    }
    /**
     * Create a new edge in the graph as well as a corresponding reverse edge on the residual graph
     * @param from - vertex edge starts at
     * @param to - vertex edge leads to
     * @param capacity - max flow capacity for this edge
     */
    newEdge(from, to, capacity) {
        // Normal forward Edge,
        this.edges[from].push({
            to: to,
            resEdge: this.edges[to].length,
            capacity: capacity,
            flow: 0
        });
        // reverse Edge for Residal Graph
        this.edges[to].push({
            to: from,
            resEdge: this.edges[from].length - 1,
            capacity: 0,
            flow: 0
        });
    }
    /**
     * Uses Breadth First Search to see if a path exists to the vertex 'to' and generate the level graph
     * @param from - vertex to start from
     * @param to - vertex to try and reach
     */
    createLevelGraph(from, to) {
        if (to >= this.vertCount)
            return false;
        // reset old levels
        this.level.fill(-1);
        this.level[from] = 0;
        // queue with from as starting point
        let q = [from];
        let u = 0;
        while (q.length > 0) {
            u = q.splice(0, 1)[0];
            for (let edge of this.edges[u]) {
                if (this.level[edge.to] < 0 && edge.flow < edge.capacity) {
                    this.level[edge.to] = this.level[u] + 1;
                    q.push(edge.to);
                }
            }
        }
        // return if theres a path to t -> no level, no path!
        return this.level[to] >= 0;
    }
    /**
     * Depth First Search-like: send flow at along path from from->to recursively while increasing the level of the
     * visited vertices by one
     * @param start - the vertex to start at
     * @param end - the vertex to try and reach
     * @param targetFlow - the amount of flow to try and achieve
     * @param count - keep track of which vertices have been visited so we don't include them twice
     */
    calcFlow(start, end, targetFlow, count) {
        if (start === end) // Sink reached , aboard recursion
            return targetFlow;
        let flowTillHere = 0;
        let flowToT = 0;
        // Visit all edges of the vertex  one after the other
        while (count[start] < this.edges[start].length) {
            let edge = this.edges[start][count[start]];
            // Edge leads to Vertex with a level one higher, and has flow left
            if (this.level[edge.to] === this.level[start] + 1 && edge.flow < edge.capacity) {
                flowTillHere = Math.min(targetFlow, edge.capacity - edge.flow);
                flowToT = this.calcFlow(edge.to, end, flowTillHere, count);
                if (flowToT > 0) {
                    // Add Flow to current edge
                    edge.flow += flowToT;
                    // subtract from reverse Edge -> Residual Graph neg. Flow to use backward direction of BFS/DFS
                    this.edges[edge.to][edge.resEdge].flow -= flowToT;
                    return flowToT;
                }
            }
            count[start]++;
        }
        return 0;
    }
    /**
     * Uses Breadth First Search to find the vertices in the minCut for the graph
     * - Must call calcMinCut first to prepare the graph
     * @param from - the vertex to start from
     */
    getMinCut(from) {
        let eInCut = [];
        this.level.fill(-1);
        this.level[from] = 1;
        let q = [];
        q.push(from);
        let u = 0;
        while (q.length > 0) {
            u = q.splice(0, 1)[0];
            for (let edge of this.edges[u]) {
                if (edge.flow < edge.capacity) {
                    if (this.level[edge.to] < 1) {
                        this.level[edge.to] = 1;
                        q.push(edge.to);
                    }
                }
                // blocking edge -> could be in min cut
                if (edge.flow === edge.capacity && edge.capacity > 0) {
                    eInCut.push({ v: edge.to, u: u });
                }
            }
        }
        let minCut = [];
        for (let cutEdge of eInCut) {
            // Only edges which are blocking and lead to from s unreachable vertices are in the min cut
            if (this.level[cutEdge.v] === -1)
                minCut.push(cutEdge.u);
        }
        return minCut;
    }
    /**
     * Calculates min-cut graph using Dinic's Algorithm.
     * use getMinCut to get the actual verticies in the minCut
     * @param source - Source vertex
     * @param sink - Sink vertex
     */
    calcMinCut(source, sink) {
        if (source === sink)
            return -1;
        let returnvalue = 0;
        let flow = 0;
        while (this.createLevelGraph(source, sink) === true) {
            const count = new Array(this.vertCount + 1).fill(0);
            flow = 0;
            do {
                flow = this.calcFlow(source, sink, Number.MAX_VALUE, count);
                if (flow > 0)
                    returnvalue += flow;
            } while (flow);
        }
        return returnvalue;
    }
}
class UtilMincut {
    /**
     * Function to create Source, Sink, Tiles arrays: takes a rectangle-Array as input for Tiles that are to Protect
     * @param room - the room to consider
     * @param toProtect - the coordinates to protect inside the walls
     * @param bounds - the area to consider for the minCut
     */
    static createGraph(roomName, toProtect, bounds) {
        let roomArray = getRoom2dArray(roomName, bounds);
        // Check bounds
        if (bounds.x1 >= bounds.x2 || bounds.y1 >= bounds.y2 || bounds.x1 < 0 || bounds.y1 < 0 || bounds.x2 > 49 || bounds.y2 > 49) {
            throw new Error(`ERROR: Invalid bounds ${JSON.stringify(bounds)}`);
        }
        if (_.isArray(toProtect)) {
            // For all Rectangles, set edges as source (to protect area) and area as unused
            for (let j = 0; j < toProtect.length; j++) {
                const r = toProtect[j];
                // Test sizes of rectangles
                if (r.x1 >= r.x2 || r.y1 >= r.y2) {
                    throw new Error(`ERROR: Rectangle Nr. ${j} ${JSON.stringify(r)} invalid.`);
                }
                else if (r.x1 < bounds.x1 || r.x2 > bounds.x2 || r.y1 < bounds.y1 || r.y2 > bounds.y2) {
                    throw new Error(`ERROR: Rectangle Nr. ${j} ${JSON.stringify(r)} out of bounds: ${JSON.stringify(bounds)}`);
                }
                for (let x = r.x1; x < r.x2 + 1; x++) {
                    for (let y = r.y1; y < r.y2 + 1; y++) {
                        if (x === r.x1 || x === r.x2 || y === r.y1 || y === r.y2) {
                            if (roomArray[x][y] === NORMAL)
                                roomArray[x][y] = PROTECTED;
                        }
                        else {
                            roomArray[x][y] = UNWALKABLE;
                        }
                    }
                }
            }
        }
        else {
            for (let tile of toProtect.edgeTiles)
                if (roomArray[tile.x][tile.y] === NORMAL)
                    roomArray[tile.x][tile.y] = PROTECTED;
            for (let tile of toProtect.insideTiles)
                roomArray[tile.x][tile.y] = UNWALKABLE;
        }
        // ********************** Visualization
        //let visual = new RoomVisual(roomName);
        //for (let x = 0; x < 50; x++) {
        //  for (let y = 0; y < 50; y++) {
        //    switch (roomArray[x][y]) {
        //      case UNWALKABLE:
        //        visual.circle(x, y, { radius: 0.5, fill: '#111166', opacity: 0.3 });
        //        break;
        //      case NORMAL:
        //        visual.circle(x, y, { radius: 0.5, fill: '#e8e863', opacity: 0.3 });
        //        break;
        //      case PROTECTED:
        //        visual.circle(x, y, { radius: 0.5, fill: '#75e863', opacity: 0.3 });
        //        break;
        //      case CANNOT_BUILD:
        //        visual.circle(x, y, { radius: 0.5, fill: '#b063e8', opacity: 0.3 });
        //        break;
        //    }
        //  }
        //}
        // initialise graph
        // possible 2*50*50 +2 (st) Vertices (Walls etc set to unused later)
        let graph = new Graph(2 * 50 * 50 + 2);
        let surr = [
            [0, -1],
            [-1, -1],
            [-1, 0],
            [-1, 1],
            [0, 1],
            [1, 1],
            [1, 0],
            [1, -1]
        ];
        // per Tile (0 in Array) top + bot with edge of c=1 from top to bott  (use every tile once!)
        // infini edge from bot to top vertices of adjacent tiles if they not protected (array =1) (no reverse edges in normal graph)
        // per prot. Tile (1 in array) Edge from source to this tile with infini cap.
        // per exit Tile (2in array) Edge to sink with infini cap.
        // source is at  pos 2*50*50, sink at 2*50*50+1 as first tile is 0,0 => pos 0
        // top vertices <-> x,y : v=y*50+x   and x= v % 50  y=v/50 (math.floor?)
        // bot vertices <-> top + 2500
        let source = 2 * 50 * 50;
        let sink = 2 * 50 * 50 + 1;
        let top = 0;
        let bot = 0;
        let dx = 0;
        let dy = 0;
        for (let x = 1; x < 49; x++) {
            for (let y = 1; y < 49; y++) {
                top = y * 50 + x;
                bot = top + 2500;
                if (roomArray[x][y] === NORMAL) {
                    graph.newEdge(top, bot, 1);
                    for (let i = 0; i < 8; i++) {
                        dx = x + surr[i][0];
                        dy = y + surr[i][1];
                        if (roomArray[dx][dy] === NORMAL || roomArray[dx][dy] === CANNOT_BUILD)
                            graph.newEdge(bot, dy * 50 + dx, Number.MAX_VALUE);
                    }
                }
                else if (roomArray[x][y] === PROTECTED) {
                    graph.newEdge(source, top, Number.MAX_VALUE);
                    graph.newEdge(top, bot, 1);
                    for (let i = 0; i < 8; i++) {
                        dx = x + surr[i][0];
                        dy = y + surr[i][1];
                        if (roomArray[dx][dy] === NORMAL || roomArray[dx][dy] === CANNOT_BUILD)
                            graph.newEdge(bot, dy * 50 + dx, Number.MAX_VALUE);
                    }
                }
                else if (roomArray[x][y] === CANNOT_BUILD) {
                    graph.newEdge(top, sink, Number.MAX_VALUE);
                }
            }
        }
        return graph;
    }
    /**
     * Removes unnecessary tiles if they are blocking the path to a dead end
     * Useful if minCut has been run on a subset of the room
     * @param roomName - Room to work in
     * @param cutTiles - Array of tiles which are in the minCut
     */
    static pruneDeadEnds(roomName, cutTiles) {
        // Get Terrain and set all cut-tiles as unwalkable
        let roomArray = getRoom2dArray(roomName);
        for (let i = cutTiles.length - 1; i >= 0; i--) {
            roomArray[cutTiles[i].x][cutTiles[i].y] = UNWALKABLE;
        }
        // Floodfill from exits: save exit tiles in array and do a bfs-like search
        let unvisitedPos = [];
        for (let y = 0; y < 49; y++) {
            if (roomArray[1][y] === CANNOT_BUILD)
                unvisitedPos.push(50 * y + 1);
            if (roomArray[48][y] === CANNOT_BUILD)
                unvisitedPos.push(50 * y + 48);
        }
        for (let x = 0; x < 49; x++) {
            if (roomArray[x][1] === CANNOT_BUILD)
                unvisitedPos.push(50 + x);
            if (roomArray[x][48] === CANNOT_BUILD)
                unvisitedPos.push(2400 + x); // 50*48=2400
        }
        // Iterate over all unvisited TO_EXIT- Tiles and mark neigbours as TO_EXIT tiles, if walkable (NORMAL), and add to unvisited
        let surr = [[0, -1], [-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1]];
        let index, dx, dy;
        while (unvisitedPos.length > 0) {
            index = unvisitedPos.pop();
            const x = index % 50;
            const y = Math.floor(index / 50);
            for (let i = 0; i < 8; i++) {
                dx = x + surr[i][0];
                dy = y + surr[i][1];
                if (roomArray[dx][dy] === NORMAL) {
                    unvisitedPos.push(50 * dy + dx);
                    roomArray[dx][dy] = CANNOT_BUILD;
                }
            }
        }
        // Remove min-Cut-Tile if there is no TO-EXIT  surrounding it
        let leadsToExit = false;
        for (let i = cutTiles.length - 1; i >= 0; i--) {
            leadsToExit = false;
            const x = cutTiles[i].x;
            const y = cutTiles[i].y;
            for (let j = 0; j < 8; j++) {
                dx = x + surr[j][0];
                dy = y + surr[j][1];
                if (roomArray[dx][dy] === CANNOT_BUILD) {
                    leadsToExit = true;
                }
            }
            if (!leadsToExit) {
                cutTiles.splice(i, 1);
            }
        }
    }
    /**
     * Main function to be called by user: calculate min cut tiles from room using rectangles as protected areas
     * @param room - the room to use
     * @param rectangles - the areas to protect, defined as rectangles
     * @param bounds - the area to be considered for the minCut
     */
    static getCutTiles(roomName, toProtect, bounds = { x1: 0, y1: 0, x2: 49, y2: 49 }) {
        let graph = this.createGraph(roomName, toProtect, bounds);
        let source = 2 * 50 * 50; // Position Source / Sink in Room-Graph
        let sink = 2 * 50 * 50 + 1;
        let count = graph.calcMinCut(source, sink);
        //console.log('Number of Tiles in Cut:', count);
        let positions = [];
        if (count > 0) {
            let cutEdges = graph.getMinCut(source);
            // Get Positions from Edge
            for (let edge of cutEdges) {
                positions.push({
                    x: edge % 50,
                    y: Math.floor(edge / 50)
                });
            }
        }
        // if bounds are given,
        // try to dectect islands of walkable tiles, which are not conntected to the exits, and delete them from the cut-tiles
        const wholeRoom = (bounds.x1 === 0 && bounds.y1 === 0 && bounds.x2 === 49 && bounds.y2 === 49);
        if (positions.length > 0 && !wholeRoom)
            this.pruneDeadEnds(roomName, positions);
        // Visualise Result
        //if (positions.length > 0) {
        //  let visual = new RoomVisual(roomName);
        //  for (let i = positions.length - 1; i >= 0; i--) {
        //    visual.circle(positions[i].x, positions[i].y, { radius: 0.5, fill: '#ff7722', opacity: 0.9 });
        //  }
        //}
        return positions;
    }
    /**
     * Example function: demonstrates how to get a min cut with 2 rectangles, which define a "to protect" area
     * @param roomName - the name of the room to use for the test, must be visible
     */
    static test(roomName) {
        let cpu = Game.cpu.getUsed();
        // Rectangle Array, the Rectangles will be protected by the returned tiles
        let rectArray = [];
        rectArray.push({ x1: 20, y1: 6, x2: 28, y2: 27 });
        rectArray.push({ x1: 29, y1: 13, x2: 34, y2: 16 });
        // Boundary Array for Maximum Range
        let bounds = { x1: 0, y1: 0, x2: 49, y2: 49 };
        // Get Min cut
        let positions = this.getCutTiles(roomName, rectArray, bounds); // Positions is an array where to build walls/ramparts
        // Test output
        console.log('Positions returned', positions.length);
        cpu = Game.cpu.getUsed() - cpu;
        console.log('Needed', cpu, ' cpu time');
        return 'Finished';
    }
}

const coreTemplate = {
    [STRUCTURE_LINK]: [
        { x: 2, y: 2 }
    ],
    [STRUCTURE_TERMINAL]: [
        { x: 1, y: 2 }
    ],
    [STRUCTURE_CONTAINER]: [
        { x: -1, y: 0 },
        { x: -1, y: -5 }
    ],
    [STRUCTURE_STORAGE]: [
        { x: 0, y: 0 }
    ],
    [STRUCTURE_ROAD]: [
        { x: 0, y: -1 },
        { x: 0, y: 1 },
        { x: -1, y: 0 },
        { x: 1, y: 0 },
        { x: -1, y: -1 },
        { x: 1, y: -1 },
        { x: -1, y: 1 },
        { x: 1, y: 1 },
        { x: 0, y: -2 },
        { x: 0, y: 2 },
        { x: -2, y: 0 },
        { x: 2, y: 0 },
        { x: 0, y: -2 },
        { x: -1, y: -3 },
        { x: 1, y: -3 },
        { x: -2, y: -4 },
        { x: 2, y: -4 },
        { x: -1, y: -5 },
        { x: 1, y: -5 },
        { x: 0, y: -6 }
    ],
    [STRUCTURE_TOWER]: [
        { x: -2, y: -2 },
        { x: -1, y: -2 },
        { x: 2, y: -2 },
        { x: 2, y: -1 },
        { x: -2, y: 1 },
        { x: -2, y: 2 }
    ],
    [STRUCTURE_SPAWN]: [
        { x: -2, y: -1 },
        { x: 1, y: -2 },
        { x: 2, y: 1 }
    ],
    [STRUCTURE_POWER_SPAWN]: [
        { x: -1, y: 2 }
    ],
    [STRUCTURE_LAB]: [
        { x: -1, y: -4 },
        { x: 0, y: -4 },
        { x: 1, y: -4 },
        { x: 0, y: -5 },
        { x: -2, y: -3 },
        { x: 0, y: -3 },
        { x: 2, y: -3 },
        { x: -2, y: -5 },
        { x: 2, y: -5 },
        { x: -1, y: -6 }
    ],
    [STRUCTURE_NUKER]: [
        { x: -2, y: -6 }
    ],
    [STRUCTURE_FACTORY]: [
        { x: 1, y: -6 }
    ]
};
const coreContainersPerRCL = { 1: 0, 2: 1, 3: 1, 4: 1, 5: 1, 6: 2, 7: 2 };
class RoomLayoutGeneratorFlex extends RoomLayoutGenerator {
    constructor(roomName, initialSpawn, outRoomPlan) {
        super(roomName, initialSpawn, outRoomPlan);
    }
    *update() {
        const visual = Common.getRoomVisual(this.roomName);
        const controllerPos = GIntel.rooms[this.roomName].controllerPos;
        const distances = this.createBuildableDistanceCM(this.roomName);
        let roomMatrix = this.createRoomMatrix(this.roomName);
        const distanceToController = this.createPathDistanceCM(controllerPos, roomMatrix);
        const roadCreationOpts = {
            plainCost: 12,
            swampCost: 15,
            maxOps: 20000,
            maxRooms: 1,
            roomCallback: (roomName) => roomMatrix.toCostMatrix()
        };
        let validCorePositions = [];
        for (let y = 3; y < 46; ++y) {
            for (let x = 3; x < 46; ++x) {
                if (distanceToController[y * 50 + x] >= 5
                    && !roomMatrix.isInRange(x, y, 5, { is: rp.TILE_EXIT })
                    && GIntel.rooms[this.roomName].sources.every(sourcePos => sourcePos.getRangeTo(x, y) >= 6)
                    && distances[y * 50 + x] >= 3
                    && (distances[y * 50 + x + 4] >= 3
                        || distances[y * 50 + x - 4] >= 3
                        || distances[y * 50 + x + 200] >= 3
                        || distances[y * 50 + x - 200] >= 3)) {
                    validCorePositions.push(new RoomPosition(x, y, this.roomName));
                }
            }
        }
        if (validCorePositions.length === 0)
            return;
        for (let pos of validCorePositions)
            visual.rect(pos.x - 0.5, pos.y - 0.5, 1, 1, { fill: '#ffff33', opacity: 0.7 });
        const corePos = this.initialSpawn
            ? validCorePositions.find(spot => !!coreTemplate[STRUCTURE_SPAWN].find(spawnPos => spot.x + spawnPos.x === this.initialSpawn.pos.x && spot.y + spawnPos.y === this.initialSpawn.pos.y))
            : _.min(validCorePositions, s => distanceToController[s.y * 50 + s.x]);
        console.log(this.initialSpawn, corePos);
        visual.rect(corePos.x - 0.5, corePos.y - 0.5, 1, 1, { strokeWidth: 1, stroke: 'ff0000', fill: null, opacity: 0.7 });
        yield;
        let plan = {
            core: {
                1: {},
                2: {},
                3: {},
                4: {},
                5: {},
                6: {},
                7: {},
                8: {}
            },
            extraction: {},
            mines: {},
            upgradeSite: {},
            pos: corePos
        };
        //
        let coreOrientation;
        if (distances[corePos.y * 50 + corePos.x + 4] >= 3)
            coreOrientation = RIGHT;
        else if (distances[corePos.y * 50 + corePos.x - 4] >= 3)
            coreOrientation = LEFT;
        else if (distances[corePos.y * 50 + corePos.x + 200] >= 3)
            coreOrientation = BOTTOM;
        else if (distances[corePos.y * 50 + corePos.x - 200] >= 3)
            coreOrientation = TOP;
        else
            return undefined;
        let rcl8CorePlan = _.mapValues(coreTemplate, s => s.map(p => {
            let x = p.x;
            let y = p.y;
            if (coreOrientation === RIGHT || coreOrientation === LEFT) {
                let tmp = x;
                x = -y;
                y = tmp;
            }
            if (coreOrientation === BOTTOM || coreOrientation === LEFT) {
                x = -x;
                y = -y;
            }
            return new RoomPosition(corePos.x + x, corePos.y + y, this.roomName);
        }));
        for (let i = 1; i <= 7; ++i) {
            for (let structureType in rcl8CorePlan) {
                if (CONTROLLER_STRUCTURES[structureType][i] === 0)
                    continue;
                if (i < 2 && structureType !== STRUCTURE_SPAWN)
                    continue;
                if (structureType === STRUCTURE_CONTAINER)
                    plan.core[i][structureType] = rcl8CorePlan[structureType].slice(0, coreContainersPerRCL[i]);
                else
                    plan.core[i][structureType] = rcl8CorePlan[structureType].slice(0, CONTROLLER_STRUCTURES[structureType][i]);
            }
        }
        plan.core[8] = rcl8CorePlan;
        this.addBuildingsToRoomMatrix(roomMatrix, rcl8CorePlan);
        yield;
        // MINES -------
        for (let sourcePos of GIntel.rooms[this.roomName].sources) {
            let serializedSourcePos = sourcePos.serialize();
            let mineBfsLeaveCondition = (x, y, value) => {
                return !(value & rp.TILE_URBANIZED) && /*!(value & rp.TILE_UNBUILDABLE) &&*/ !(value & rp.TILE_OBSTACLE) && Math.max(Math.abs(x - sourcePos.x), Math.abs(y - sourcePos.y)) === 1;
            };
            let containerPos = roomMatrix.bfs(corePos.x, corePos.y, rp.TILE_OBSTACLE, mineBfsLeaveCondition);
            plan.mines[serializedSourcePos] = {
                [STRUCTURE_CONTAINER]: [containerPos.pos]
            };
            this.addBuildingsToRoomMatrix(roomMatrix, plan.mines[serializedSourcePos], rp.TILE_MINE);
        }
        // UPGRADE -----
        this.addUpgradeSite(corePos, plan, roomMatrix);
        yield;
        // SOURCE LINKS
        for (let serializedSourcePos in plan.mines) {
            let containerPos = plan.mines[serializedSourcePos].container[0];
            let orientationOffset = _(Common.offset)
                .filter((o) => {
                let op = new RoomPosition(containerPos.x + o.x, containerPos.y + o.y, containerPos.roomName);
                if (roomMatrix.check(op.x, op.y, { is: rp.TILE_OBSTACLE })
                    || roomMatrix.check(op.x, op.y, { is: rp.TILE_UNBUILDABLE })
                    || roomMatrix.check(op.x, op.y, { is: rp.TILE_ROAD })
                    || roomMatrix.check(op.x, op.y, { is: rp.TILE_MINE }))
                    return false;
                return true;
            })
                .min(op => {
                return Math.sqrt(Math.pow(Math.abs(op.x - corePos.x), 2) + Math.pow(Math.abs(op.y - corePos.y), 2));
            });
            if (orientationOffset !== Infinity) {
                let orientation = _.findKey(Common.offset, orientationOffset);
                let linkPos = containerPos.nextPosition(orientation);
                if (linkPos)
                    plan.mines[serializedSourcePos][STRUCTURE_LINK] = [linkPos];
                this.addBuildingsToRoomMatrix(roomMatrix, plan.mines[serializedSourcePos], rp.TILE_MINE);
            }
        }
        yield;
        // MINERAL -----
        this.addExtraction(corePos, GIntel.rooms[this.roomName].mineralPos, plan, roomMatrix, roadCreationOpts);
        this.addBuildingsToRoomMatrix(roomMatrix, rcl8CorePlan);
        yield;
        // EXTENSIONS -------
        rcl8CorePlan.extension = [];
        let extensions = rcl8CorePlan.extension;
        let roads = rcl8CorePlan.road;
        let extensionsPlaced = 0;
        const maxExtensions = 60;
        let distanceCM = this.createPathDistanceCM(corePos, roomMatrix);
        const NO_ACCESS = 0;
        let accessPointCM = new PathFinder.CostMatrix();
        for (let x = 1; x < 49; ++x)
            for (let y = 1; y < 49; ++y) {
                accessPointCM.set(x, y, NO_ACCESS);
                if (roomMatrix.check(x, y, { is: rp.TILE_OBSTACLE, isNot: rp.TILE_URBANIZED }))
                    continue;
                let value = _.sum(Common.offset, o => (roomMatrix.get(x + o.x, y + o.y) & rp.TILE_OBSTACLE) ? 0 : 1);
                accessPointCM.set(x, y, value);
            }
        let emergencyBreak = 30;
        let distance = 1;
        mainLoop: while (emergencyBreak--) {
            for (let d = 0; d <= distance; ++d)
                for (let tileIndex = 0; tileIndex <= 2 * d; ++tileIndex)
                    for (let edgeIndex = 0; edgeIndex < 4; ++edgeIndex) {
                        let tilePos = tileIndex - d;
                        let xOffset = [tilePos, d, -tilePos, -d];
                        let yOffset = [-d, tilePos, d, -tilePos];
                        let coordsX = corePos.x + xOffset[edgeIndex];
                        let coordsY = corePos.y + yOffset[edgeIndex];
                        if (coordsX < 1 || coordsX > 48 || coordsY < 1 || coordsY > 48)
                            continue;
                        if (roomMatrix.get(coordsX, coordsY) & (rp.TILE_ROAD | rp.TILE_MINE | rp.TILE_UPGRADE | rp.TILE_EXTRACTION | rp.TILE_CLOSED_OFF | rp.TILE_OBSTACLE))
                            continue;
                        if (roomMatrix.isInRange(coordsX, coordsY, 2, { is: rp.TILE_EXIT }))
                            continue;
                        if (distanceCM[coordsY * 50 + coordsX] > distance)
                            continue;
                        yield;
                        let coords = new RoomPosition(coordsX, coordsY, this.roomName);
                        //
                        let accessBlocked = [];
                        _.forEach(Common.offset, o => {
                            let op = new RoomPosition(coords.x + o.x, coords.y + o.y, coords.roomName);
                            if (accessPointCM.get(op.x, op.y) === 1)
                                accessBlocked.push(op);
                        });
                        //
                        // O x O    O O
                        // x O W -> x O W
                        // O O W    O O W
                        let extensionAtAccessBlockedIndex = -1;
                        if (accessBlocked.length > 0)
                            extensionAtAccessBlockedIndex = extensions.findIndex(p => p.isEqualTo(accessBlocked[0]));
                        if (accessBlocked.length === 1 && accessPointCM.get(coords.x, coords.y) === 1 && extensionAtAccessBlockedIndex !== -1) {
                            roomMatrix.unset(accessBlocked[0].x, accessBlocked[0].y, rp.TILE_OBSTACLE | rp.TILE_URBANIZED);
                            roomMatrix.set(accessBlocked[0].x, accessBlocked[0].y, rp.TILE_CLOSED_OFF);
                            extensions.splice(extensionAtAccessBlockedIndex, 1, new RoomPosition(coords.x, coords.y, coords.roomName));
                            roomMatrix.set(coords.x, coords.y, rp.TILE_OBSTACLE | rp.TILE_URBANIZED);
                            _.forEach(Common.offset, o => {
                                let currentValue = accessPointCM.get(coords.x + o.x, coords.y + o.y);
                                if (currentValue !== NO_ACCESS)
                                    accessPointCM.set(coords.x + o.x, coords.y + o.y, currentValue - 1);
                            });
                            accessPointCM.set(accessBlocked[0].x, accessBlocked[0].y, NO_ACCESS);
                            if (!rcl8CorePlan.observer) {
                                rcl8CorePlan.observer = [accessBlocked[0]];
                                roomMatrix.set(accessBlocked[0].x, accessBlocked[0].y, rp.TILE_OBSTACLE | rp.TILE_URBANIZED);
                            }
                            continue;
                        }
                        //
                        let wouldBlockAccess = (accessBlocked.length > 0);
                        if (wouldBlockAccess)
                            continue;
                        //
                        let isDeadEnd = (accessPointCM.get(coords.x, coords.y) === 1);
                        let isOnThinGrid = (Math.min((coords.x - coords.y - corePos.x + corePos.y + 2).mod(4), (coords.x + coords.y - corePos.x - corePos.y + 2).mod(4)) !== 0);
                        if (!isDeadEnd && !isOnThinGrid)
                            continue;
                        //     x
                        //   x O x
                        // x O O O x
                        //   x x x
                        //     W
                        let isOnThickGrid = ((coords.x % 2 === coords.y % 2) !== (corePos.x % 2 === corePos.y % 2));
                        let isCrossSide = (isOnThickGrid && coords.y % 2 === corePos.y % 2);
                        let isCrossEnd = (isOnThickGrid && !isCrossSide);
                        let XmYDiagonalSign = ((coords.x - corePos.x - coords.y + corePos.y).mod(4) === 1 ? 1 : -1);
                        if (isCrossEnd &&
                            roomMatrix.check(coords.x - 1, coords.y, { isNot: rp.TILE_OBSTACLE }) &&
                            roomMatrix.check(coords.x + 1, coords.y, { isNot: rp.TILE_OBSTACLE }) &&
                            roomMatrix.check(coords.x, coords.y - XmYDiagonalSign, { is: rp.TILE_OBSTACLE })) {
                            continue;
                        }
                        if (isCrossSide &&
                            roomMatrix.check(coords.x, coords.y - 1, { isNot: rp.TILE_OBSTACLE }) &&
                            roomMatrix.check(coords.x, coords.y + 1, { isNot: rp.TILE_OBSTACLE }) &&
                            roomMatrix.check(coords.x + XmYDiagonalSign, coords.y, { is: rp.TILE_OBSTACLE })) {
                            continue;
                        }
                        let roadPointsAround = _(Common.offset)
                            .filter((o) => {
                            let m = ((o.x !== 0 && o.y !== 0) ? 1 : 2);
                            let x = coords.x + m * o.x;
                            let y = coords.y + m * o.y;
                            if (x < 1 || x > 48 || y < 1 || y > 48)
                                return false;
                            if (roomMatrix.get(x, y) & rp.TILE_OBSTACLE)
                                return false;
                            return true;
                        })
                            .map((o) => {
                            let m = ((o.x !== 0 && o.y !== 0) ? 1 : 2);
                            return new RoomPosition(coords.x + m * o.x, coords.y + m * o.y, coords.roomName);
                        })
                            .value();
                        let isBlockingCross = false;
                        crossRoadPointsOuterLoop: for (let i = 0; i < roadPointsAround.length; ++i) {
                            roomMatrix.clear(null, rp.TILE_TMP_SELECT);
                            roomMatrix.floodFill(roadPointsAround[i].x, roadPointsAround[i].y, { isNot: rp.TILE_OBSTACLE }, rp.TILE_TMP_SELECT, 6);
                            roomMatrix.set(coords.x, coords.y, rp.TILE_OBSTACLE);
                            roomMatrix.clear(null, rp.TILE_TMP_SELECT);
                            roomMatrix.floodFill(roadPointsAround[i].x, roadPointsAround[i].y, { isNot: rp.TILE_OBSTACLE }, rp.TILE_TMP_SELECT, 6);
                            roomMatrix.unset(coords.x, coords.y, rp.TILE_OBSTACLE);
                            for (let j = i + 1; j < roadPointsAround.length; ++j)
                                if (roomMatrix.check(roadPointsAround[j].x, roadPointsAround[j].y, { isNot: rp.TILE_TMP_SELECT })) {
                                    isBlockingCross = true;
                                    break crossRoadPointsOuterLoop;
                                }
                        }
                        if (isBlockingCross) {
                            // is reachable from storage
                            roomMatrix.clear(null, rp.TILE_TMP_SELECT);
                            roomMatrix.floodFill(corePos.x, corePos.y, { isNot: rp.TILE_OBSTACLE }, rp.TILE_TMP_SELECT, distance);
                            if (!(roomMatrix.get(coords.x, coords.y) & rp.TILE_TMP_SELECT)) {
                                roomMatrix.set(coords.x, coords.y, rp.TILE_URBANIZED | rp.TILE_ROAD);
                                roads.push(new RoomPosition(coords.x, coords.y, coords.roomName));
                            }
                            continue;
                        }
                        if (extensionsPlaced < maxExtensions) {
                            extensions.push(new RoomPosition(coords.x, coords.y, coords.roomName));
                            roomMatrix.set(coords.x, coords.y, rp.TILE_URBANIZED | rp.TILE_OBSTACLE);
                            ++extensionsPlaced;
                        }
                        else if (!rcl8CorePlan.observer) {
                            rcl8CorePlan.observer = [new RoomPosition(coords.x, coords.y, coords.roomName)];
                            roomMatrix.set(coords.x, coords.y, rp.TILE_URBANIZED | rp.TILE_OBSTACLE);
                        }
                        _.forEach(Common.offset, o => {
                            let currentValue = accessPointCM.get(coords.x + o.x, coords.y + o.y);
                            if (currentValue !== NO_ACCESS)
                                accessPointCM.set(coords.x + o.x, coords.y + o.y, currentValue - 1);
                        });
                        if (extensionsPlaced === maxExtensions && rcl8CorePlan.observer)
                            break mainLoop;
                    }
            ++distance;
        }
        for (let i = 1; i < 8; ++i)
            plan.core[i].extension = extensions.slice(0, CONTROLLER_STRUCTURES.extension[i]);
        this.addBuildingsToRoomMatrix(roomMatrix, rcl8CorePlan);
        // CORE ROADS -----
        for (let x = 1; x < 49; ++x)
            for (let y = 1; y <= 49; ++y) {
                if (roomMatrix.get(x, y) & (rp.TILE_OBSTACLE | rp.TILE_CLOSED_OFF))
                    continue;
                let adjBuildings = roomMatrix.findInRange(x, y, 1, { is: rp.TILE_OBSTACLE | rp.TILE_URBANIZED, isNot: rp.TILE_MINE | rp.TILE_EXTRACTION | rp.TILE_UPGRADE });
                if (adjBuildings.length === 0 || adjBuildings.length === 1 && adjBuildings[0].x !== x && adjBuildings[0].y !== y)
                    continue;
                for (let i = 1; i <= 8; ++i)
                    if (plan.core[i].extension.find((e) => e.isNearTo(x, y))) {
                        for (let j = i; j <= 8; ++j) {
                            plan.core[j][STRUCTURE_ROAD] = plan.core[j][STRUCTURE_ROAD] || [];
                            plan.core[j][STRUCTURE_ROAD].push(new RoomPosition(x, y, this.roomName));
                        }
                    }
            }
        this.addBuildingsToRoomMatrix(roomMatrix, rcl8CorePlan);
        yield;
        // DEFENCE -----
        let ramparts = [];
        roomMatrix.clear(null, rp.TILE_TMP_SELECT);
        roomMatrix.floodFill(corePos.x, corePos.y, (x, y, value) => {
            if ((value & (rp.TILE_UNBUILDABLE | rp.TILE_WALL)) > 0)
                return false;
            return roomMatrix.isInRange(x, y, 3, { is: rp.TILE_URBANIZED });
        }, rp.TILE_TMP_SELECT);
        roomMatrix.fill((x, y, value) => {
            if ((value & rp.TILE_TMP_SELECT) === 0)
                return false;
            if ((value & rp.TILE_WALL) > 0)
                return false;
            if (!roomMatrix.isInRange(x, y, 1, { isNot: rp.TILE_TMP_SELECT }))
                return false;
            return true;
        }, rp.TILE_FORTIFICATION);
        let baseEdgeTiles = [];
        let baseInsideTiles = [];
        for (let y = 0; y < 50; ++y)
            for (let x = 0; x < 50; ++x) {
                if (roomMatrix.check(x, y, { is: rp.TILE_TMP_SELECT, isNot: rp.TILE_FORTIFICATION }))
                    baseInsideTiles.push({ x: x, y: y });
                if (roomMatrix.check(x, y, { is: rp.TILE_FORTIFICATION }))
                    baseEdgeTiles.push({ x: x, y: y });
            }
        roomMatrix.clear(null, rp.TILE_TMP_SELECT | rp.TILE_FORTIFICATION);
        //
        let bounds = {
            x1: corePos.x,
            y1: corePos.y,
            x2: corePos.x,
            y2: corePos.y
        };
        for (let tile of baseEdgeTiles) {
            if (tile.x < bounds.x1)
                bounds.x1 = tile.x;
            if (tile.x > bounds.x2)
                bounds.x2 = tile.x;
            if (tile.y < bounds.y1)
                bounds.y1 = tile.y;
            if (tile.y > bounds.y2)
                bounds.y2 = tile.y;
        }
        const maxRampartDistanceFromBase = 12;
        bounds.x1 = Math.max(1, bounds.x1 - maxRampartDistanceFromBase);
        bounds.x2 = Math.min(49, bounds.x2 + maxRampartDistanceFromBase);
        bounds.y1 = Math.max(1, bounds.y1 - maxRampartDistanceFromBase);
        bounds.y2 = Math.min(49, bounds.y2 + maxRampartDistanceFromBase);
        let mincutFortification = UtilMincut.getCutTiles(this.roomName, { edgeTiles: baseEdgeTiles, insideTiles: baseInsideTiles }, bounds);
        for (let pos of mincutFortification) {
            roomMatrix.set(pos.x, pos.y, rp.TILE_FORTIFICATION);
            for (let i = 5; i <= 8; ++i)
                plan.core[i][STRUCTURE_ROAD].push(new RoomPosition(pos.x, pos.y, this.roomName));
        }
        //
        roomMatrix.clear(null, rp.TILE_TMP_SELECT);
        for (let pos of mincutFortification) {
            if (roomMatrix.check(pos.x, pos.y, { is: rp.TILE_TMP_SELECT }))
                continue;
            let rampartGroup = [new RoomPosition(pos.x, pos.y, this.roomName)];
            roomMatrix.floodFill(pos.x, pos.y, (x, y, value) => {
                if ((value & rp.TILE_FORTIFICATION) === 0)
                    return false;
                rampartGroup.push(new RoomPosition(x, y, this.roomName));
                return true;
            }, rp.TILE_TMP_SELECT);
            const pathToRampartGroup = PathFinder.search(corePos, rampartGroup, roadCreationOpts).path;
            for (let pathTile of pathToRampartGroup) {
                roomMatrix.set(pathTile.x, pathTile.y, rp.TILE_URBANIZED);
                for (let i = 5; i <= 8; ++i)
                    plan.core[i][STRUCTURE_ROAD].push(pathTile);
            }
        }
        yield;
        // controller
        _.forEach(Common.offset, o => {
            let nextPos = {
                x: controllerPos.x + o.x,
                y: controllerPos.y + o.y
            };
            if (roomMatrix.check(nextPos.x, nextPos.y, { isNot: rp.TILE_OBSTACLE }))
                roomMatrix.set(nextPos.x, nextPos.y, rp.TILE_FORTIFICATION);
        });
        roomMatrix.updateHostileReachable();
        roomMatrix.clear((x, y, value) => !roomMatrix.isInRange(x, y, 3, { is: rp.TILE_HOSTILE_REACHABLE }), rp.TILE_FORTIFICATION);
        roomMatrix.fill((x, y, value) => {
            if ((value & (rp.TILE_WALL | rp.TILE_UNBUILDABLE | rp.TILE_EXTRACTION | rp.TILE_MINE | rp.TILE_UPGRADE)) > 0)
                return false;
            if ((value & rp.TILE_URBANIZED) === 0)
                return false;
            return roomMatrix.isInRange(x, y, 3, { is: rp.TILE_HOSTILE_REACHABLE });
        }, rp.TILE_FORTIFICATION);
        for (let y = 0; y < 50; ++y)
            for (let x = 0; x < 50; ++x)
                if (roomMatrix.check(x, y, { is: rp.TILE_FORTIFICATION, isNot: rp.TILE_WALL }))
                    ramparts.push(new RoomPosition(x, y, this.roomName));
        yield;
        let RCL3Ramparts = ramparts.filter(pos => roomMatrix.isInRange(pos.x, pos.y, 1, { is: rp.TILE_HOSTILE_REACHABLE }));
        plan.core[3].rampart = RCL3Ramparts;
        plan.core[4].rampart = RCL3Ramparts;
        plan.core[5].rampart = RCL3Ramparts;
        let RCL6Ramparts = ramparts.filter(r => roomMatrix.isInRange(r.x, r.y, 1, { is: rp.TILE_HOSTILE_REACHABLE }) || _.some(plan.core[6], structures => _.some(structures, s => s.isEqualTo(r))));
        plan.core[6].rampart = RCL6Ramparts;
        let RCL7Ramparts = ramparts.filter(r => roomMatrix.isInRange(r.x, r.y, 2, { is: rp.TILE_HOSTILE_REACHABLE }) || _.some(plan.core[7], structures => _.some(structures, s => s.isEqualTo(r))));
        plan.core[7].rampart = RCL7Ramparts;
        plan.core[8].rampart = ramparts;
        this.addBuildingsToRoomMatrix(roomMatrix, rcl8CorePlan);
        // ROADS -----
        const extraction = plan.extraction;
        extraction.road = PathFinder.search(corePos, { pos: extraction.container[0], range: 1 }, roadCreationOpts).path;
        this.addBuildingsToRoomMatrix(roomMatrix, extraction);
        plan.upgradeSite.road = PathFinder.search(corePos, { pos: plan.upgradeSite.container[0], range: 1 }, roadCreationOpts).path;
        this.addBuildingsToRoomMatrix(roomMatrix, plan.upgradeSite);
        for (let mineId in plan.mines) {
            plan.mines[mineId].road = PathFinder.search(corePos, { pos: plan.mines[mineId].container[0], range: 1 }, roadCreationOpts).path;
            this.addBuildingsToRoomMatrix(roomMatrix, plan.mines[mineId]);
        }
        yield;
        //
        this.outRoomPlan.put(plan);
        return;
    }
}

const bunkerTemplate = {
    [STRUCTURE_ROAD]: [
        { x: 0, y: 0 },
        { x: 1, y: -1 },
        { x: 1, y: -2 },
        { x: 0, y: -3 },
        { x: -1, y: -4 },
        //
        { x: -2, y: -5 },
        { x: -3, y: -4 },
        //
        { x: -1, y: -1 },
        { x: -1, y: -2 },
        { x: -4, y: -3 },
        { x: -5, y: -2 },
        { x: -4, y: -1 },
        { x: -3, y: 0 },
        { x: -2, y: -1 },
        //
        { x: -1, y: 1 },
        { x: -2, y: 1 },
        { x: -4, y: 1 },
        { x: -5, y: 2 },
        { x: -4, y: 3 },
        { x: -3, y: 4 },
        { x: -2, y: 5 },
        { x: -1, y: 4 },
        { x: 0, y: 3 },
        { x: -1, y: 2 },
        { x: 1, y: 1 },
        //
        { x: 1, y: 4 },
        { x: 2, y: 5 },
        { x: 3, y: 4 },
        { x: 4, y: 3 },
        { x: 5, y: 2 },
        { x: 4, y: 1 },
        { x: 3, y: 0 },
        { x: 2, y: 1 },
        //
        { x: 1, y: 2 },
        { x: 2, y: -1 },
        //
        { x: 3, y: 6 },
        { x: -4, y: -6 },
        { x: -3, y: -6 },
        { x: -1, y: -6 },
        { x: 0, y: -6 },
        { x: 1, y: -6 },
        { x: 3, y: -5 },
        { x: 4, y: -6 },
        { x: -5, y: -5 },
        { x: 2, y: -5 },
        { x: 5, y: -5 },
        { x: -6, y: -4 },
        { x: 1, y: -4 },
        { x: 4, y: -4 },
        { x: 6, y: -4 },
        { x: -6, y: -3 },
        { x: 5, y: -3 },
        { x: 5, y: -2 },
        { x: -6, y: -1 },
        { x: 4, y: -1 },
        { x: 6, y: -1 },
        { x: -6, y: 0 },
        { x: 6, y: 0 },
        { x: -6, y: 1 },
        { x: 6, y: 1 },
        { x: -6, y: 3 },
        { x: 6, y: 3 },
        { x: -6, y: 4 },
        { x: 6, y: 4 },
        { x: -5, y: 5 },
        { x: 5, y: 5 },
        { x: -4, y: 6 },
        { x: -3, y: 6 },
        { x: -1, y: 6 },
        { x: 0, y: 6 },
        { x: 1, y: 6 },
        { x: 4, y: 6 }
    ],
    [STRUCTURE_EXTENSION]: [
        { x: 0, y: -4 },
        { x: 0, y: -5 },
        { x: -1, y: -5 },
        { x: -2, y: -4 },
        { x: -2, y: -3 },
        //
        { x: -2, y: -6 },
        { x: -3, y: -5 },
        { x: -4, y: -5 },
        { x: -4, y: -4 },
        { x: -3, y: -3 },
        //
        { x: -5, y: -4 },
        { x: -5, y: -3 },
        { x: -4, y: -2 },
        { x: -3, y: -2 },
        { x: -6, y: -2 },
        { x: -5, y: -1 },
        { x: -5, y: 0 },
        { x: -4, y: 0 },
        { x: -3, y: -1 },
        { x: -5, y: 1 },
        //
        { x: -3, y: 1 },
        { x: -3, y: 2 },
        { x: -4, y: 2 },
        { x: -5, y: 3 },
        { x: -3, y: 3 },
        { x: -2, y: 3 },
        { x: -1, y: 3 },
        { x: -2, y: 4 },
        { x: -5, y: 4 },
        { x: -4, y: 4 },
        //
        { x: -4, y: 5 },
        { x: -3, y: 5 },
        { x: -1, y: 5 },
        { x: 0, y: 4 },
        { x: 1, y: 3 },
        { x: 0, y: 5 },
        { x: 1, y: 5 },
        { x: 2, y: 3 },
        { x: 2, y: 4 },
        { x: 3, y: 2 },
        //
        { x: -6, y: 2 },
        { x: -2, y: 6 },
        { x: 2, y: 6 },
        { x: 3, y: 3 },
        { x: 4, y: 2 },
        { x: 3, y: 5 },
        { x: 4, y: 4 },
        { x: 4, y: 5 },
        { x: 5, y: 3 },
        { x: 5, y: 4 },
        //
        { x: 4, y: 0 },
        { x: 5, y: 0 },
        { x: 5, y: 1 },
        { x: 6, y: 2 },
        { x: 2, y: -6 },
        { x: 3, y: -6 },
        { x: 4, y: -5 },
        { x: 5, y: -4 },
        { x: 6, y: -3 },
        { x: 6, y: -2 }
    ],
    [STRUCTURE_LAB]: [
        { x: 1, y: -3 },
        { x: 2, y: -3 },
        { x: 2, y: -2 },
        //
        { x: 3, y: -2 },
        { x: 3, y: -1 },
        { x: 3, y: -3 },
        //
        { x: 2, y: -4 },
        { x: 3, y: -4 },
        { x: 4, y: -3 },
        { x: 4, y: -2 }
    ],
    [STRUCTURE_NUKER]: [
        { x: 5, y: -1 }
        //{ x: 5, y:-4 } // penguin nose
    ],
    [STRUCTURE_CONTAINER]: [
        { x: 1, y: -2 },
        { x: 2, y: -1 }
    ],
    [STRUCTURE_OBSERVER]: [
        { x: 1, y: -5 }
        //{ x: 4, y:-5 } // penguin eye
    ],
    [STRUCTURE_TOWER]: [
        { x: -1, y: -3 },
        //
        { x: -2, y: -2 },
        //
        { x: 1, y: 0 },
        //
        { x: -2, y: 2 },
        { x: 2, y: 2 },
        { x: 3, y: 1 }
    ],
    [STRUCTURE_SPAWN]: [
        { x: 0, y: -2 },
        { x: 2, y: 0 },
        { x: 0, y: 2 }
    ],
    [STRUCTURE_RAMPART]: [],
    [STRUCTURE_STORAGE]: [
        { x: 0, y: 0 }
    ],
    [STRUCTURE_POWER_SPAWN]: [
        { x: -2, y: 0 }
    ],
    [STRUCTURE_TERMINAL]: [
        { x: 0, y: 1 }
    ],
    [STRUCTURE_FACTORY]: [
        { x: -1, y: 0 }
    ],
    [STRUCTURE_LINK]: [
        { x: 0, y: -1 }
    ]
};
const bunkerStructuresByRCL = {
    [STRUCTURE_ROAD]: { 1: 0, 2: 5, 3: 7, 4: 14, 5: 24, 6: 72, 7: 72 },
    [STRUCTURE_EXTENSION]: { 1: 0, 2: 5, 3: 10, 4: 20, 5: 30, 6: 40, 7: 50 },
    [STRUCTURE_LAB]: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 3, 7: 6 },
    [STRUCTURE_NUKER]: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0 },
    [STRUCTURE_CONTAINER]: { 1: 0, 2: 1, 3: 1, 4: 1, 5: 1, 6: 2, 7: 2 },
    [STRUCTURE_OBSERVER]: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0 },
    [STRUCTURE_TOWER]: { 1: 0, 2: 0, 3: 1, 4: 1, 5: 2, 6: 2, 7: 3 },
    [STRUCTURE_SPAWN]: { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 2 },
    [STRUCTURE_RAMPART]: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0 },
    [STRUCTURE_STORAGE]: { 1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 1, 7: 1 },
    [STRUCTURE_POWER_SPAWN]: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0 },
    [STRUCTURE_TERMINAL]: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 1, 7: 1 },
    [STRUCTURE_LINK]: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 1, 6: 1, 7: 1 },
    [STRUCTURE_FACTORY]: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 1 }
};
class RoomLayoutGeneratorBunker extends RoomLayoutGenerator {
    constructor(roomName, initialSpawn, outRoomPlan) {
        super(roomName, initialSpawn, outRoomPlan);
    }
    *update() {
        const visual = Common.getRoomVisual(this.roomName);
        const controllerPos = GIntel.rooms[this.roomName].controllerPos;
        const distances = this.createBuildableDistanceCM(this.roomName);
        let roomMatrix = this.createRoomMatrix(this.roomName);
        const distanceToController = this.createPathDistanceCM(controllerPos, roomMatrix);
        const roadCreationOpts = {
            plainCost: 12,
            swampCost: 15,
            maxOps: 20000,
            maxRooms: 1,
            roomCallback: (roomName) => roomMatrix.toCostMatrix()
        };
        let validCorePositions = [];
        for (let y = 8; y < 42; ++y) {
            for (let x = 8; x < 42; ++x) {
                if (distances[y * 50 + x] >= 6
                    && distances[y * 50 + x + 2] >= 5
                    && distances[y * 50 + x - 2] >= 5
                    && distances[y * 50 + x + 100] >= 5
                    && distances[y * 50 + x - 100] >= 5) {
                    validCorePositions.push(new RoomPosition(x, y, this.roomName));
                }
            }
        }
        if (validCorePositions.length === 0)
            return;
        for (let pos of validCorePositions)
            visual.rect(pos.x - 0.5, pos.y - 0.5, 1, 1, { fill: '#33ff33', opacity: 0.7 });
        const corePos = this.initialSpawn
            ? validCorePositions.find(spot => !!bunkerTemplate[STRUCTURE_SPAWN].find(spawnPos => spot.x + spawnPos.x === this.initialSpawn.pos.x && spot.y + spawnPos.y === this.initialSpawn.pos.y))
            : _.min(validCorePositions, s => distanceToController[s.y * 50 + s.x]);
        visual.rect(corePos.x - 0.5, corePos.y - 0.5, 1, 1, { strokeWidth: 1, stroke: 'ff0000', fill: null, opacity: 0.7 });
        yield;
        let plan = {
            core: {
                1: {},
                2: {},
                3: {},
                4: {},
                5: {},
                6: {},
                7: {},
                8: {}
            },
            extraction: {},
            mines: {},
            upgradeSite: {},
            pos: corePos
        };
        let rcl8CorePlan = _.mapValues(bunkerTemplate, s => s.map(p => new RoomPosition(p.x + corePos.x, p.y + corePos.y, this.roomName)));
        for (let i = 1; i <= 7; ++i) {
            for (let structureType in rcl8CorePlan)
                plan.core[i][structureType] = rcl8CorePlan[structureType].slice(0, bunkerStructuresByRCL[structureType][i]);
        }
        plan.core[8] = rcl8CorePlan;
        this.addBuildingsToRoomMatrix(roomMatrix, rcl8CorePlan);
        // UPGRADE -----
        this.addUpgradeSite(corePos, plan, roomMatrix);
        // MINES -------
        for (let sourcePos of GIntel.rooms[this.roomName].sources) {
            let serializedSourcePos = sourcePos.serialize();
            let mineBfsLeaveCondition = (x, y, value) => {
                return !(value & rp.TILE_URBANIZED) && /*!(value & rp.TILE_UNBUILDABLE) &&*/ !(value & rp.TILE_OBSTACLE) && Math.max(Math.abs(x - sourcePos.x), Math.abs(y - sourcePos.y)) === 1;
            };
            let containerPos = roomMatrix.bfs(corePos.x, corePos.y, rp.TILE_OBSTACLE, mineBfsLeaveCondition);
            plan.mines[serializedSourcePos] = {
                [STRUCTURE_CONTAINER]: [containerPos.pos]
            };
            this.addBuildingsToRoomMatrix(roomMatrix, plan.mines[serializedSourcePos], rp.TILE_MINE);
        }
        for (let serializedSourcePos in plan.mines) {
            let containerPos = plan.mines[serializedSourcePos].container[0];
            let orientationOffset = _(Common.offset)
                .filter((o) => {
                let op = new RoomPosition(containerPos.x + o.x, containerPos.y + o.y, containerPos.roomName);
                if (roomMatrix.check(op.x, op.y, { is: rp.TILE_OBSTACLE })
                    || roomMatrix.check(op.x, op.y, { is: rp.TILE_UNBUILDABLE })
                    || roomMatrix.check(op.x, op.y, { is: rp.TILE_ROAD })
                    || roomMatrix.check(op.x, op.y, { is: rp.TILE_MINE }))
                    return false;
                return true;
            })
                .min(op => {
                return Math.sqrt(Math.pow(Math.abs(op.x - corePos.x), 2) + Math.pow(Math.abs(op.y - corePos.y), 2));
            });
            if (orientationOffset !== Infinity) {
                let orientation = _.findKey(Common.offset, orientationOffset);
                let linkPos = containerPos.nextPosition(orientation);
                if (linkPos)
                    plan.mines[serializedSourcePos][STRUCTURE_LINK] = [linkPos];
                this.addBuildingsToRoomMatrix(roomMatrix, plan.mines[serializedSourcePos], rp.TILE_MINE);
            }
        }
        // MINERAL -----
        this.addExtraction(corePos, GIntel.rooms[this.roomName].mineralPos, plan, roomMatrix, roadCreationOpts);
        this.addBuildingsToRoomMatrix(roomMatrix, rcl8CorePlan);
        // DEFENCE -----
        let ramparts = [];
        for (let y = 0; y < 50; ++y)
            for (let x = 0; x < 50; ++x) {
                let inAttackRange = roomMatrix.isInRange(x, y, 3, { isNot: rp.TILE_URBANIZED });
                let isBase = roomMatrix.check(x, y, { is: rp.TILE_URBANIZED, isNot: rp.TILE_WALL | rp.TILE_UNBUILDABLE | rp.TILE_EXTRACTION | rp.TILE_MINE | rp.TILE_UPGRADE });
                let withinBase = roomMatrix.isInRange(x, y, 1, { is: rp.TILE_URBANIZED, isNot: rp.TILE_WALL | rp.TILE_UNBUILDABLE | rp.TILE_EXTRACTION | rp.TILE_MINE | rp.TILE_UPGRADE });
                if (inAttackRange && (isBase || withinBase && roomMatrix.check(x, y, { is: rp.TILE_URBANIZED })))
                    roomMatrix.set(x, y, rp.TILE_FORTIFICATION);
            }
        // controller
        _.forEach(Common.offset, o => {
            let nextPos = {
                x: controllerPos.x + o.x,
                y: controllerPos.y + o.y
            };
            if (roomMatrix.check(nextPos.x, nextPos.y, { isNot: rp.TILE_OBSTACLE }))
                roomMatrix.set(nextPos.x, nextPos.y, rp.TILE_FORTIFICATION);
        });
        roomMatrix.updateHostileReachable();
        roomMatrix.clear((x, y, value) => !roomMatrix.isInRange(x, y, 3, { is: rp.TILE_HOSTILE_REACHABLE }), rp.TILE_FORTIFICATION);
        for (let y = 0; y < 50; ++y)
            for (let x = 0; x < 50; ++x)
                if (roomMatrix.check(x, y, { is: rp.TILE_FORTIFICATION, isNot: rp.TILE_WALL }))
                    ramparts.push(new RoomPosition(x, y, this.roomName));
        let RCL3Ramparts = ramparts.filter(pos => roomMatrix.isInRange(pos.x, pos.y, 1, { is: rp.TILE_HOSTILE_REACHABLE }));
        plan.core[3].rampart = RCL3Ramparts;
        plan.core[4].rampart = RCL3Ramparts;
        plan.core[5].rampart = RCL3Ramparts;
        let RCL6Ramparts = ramparts.filter(r => roomMatrix.isInRange(r.x, r.y, 1, { is: rp.TILE_HOSTILE_REACHABLE }) || _.some(plan.core[6], structures => _.some(structures, s => s.isEqualTo(r))));
        plan.core[6].rampart = RCL6Ramparts;
        let RCL7Ramparts = ramparts.filter(r => roomMatrix.isInRange(r.x, r.y, 2, { is: rp.TILE_HOSTILE_REACHABLE }) || _.some(plan.core[7], structures => _.some(structures, s => s.isEqualTo(r))));
        plan.core[7].rampart = RCL7Ramparts;
        plan.core[8].rampart = ramparts;
        this.addBuildingsToRoomMatrix(roomMatrix, rcl8CorePlan);
        // ROADS -----
        const extraction = plan.extraction;
        extraction.road = PathFinder.search(corePos, { pos: extraction.container[0], range: 1 }, roadCreationOpts).path;
        this.addBuildingsToRoomMatrix(roomMatrix, extraction);
        plan.upgradeSite.road = PathFinder.search(corePos, { pos: plan.upgradeSite.container[0], range: 1 }, roadCreationOpts).path;
        this.addBuildingsToRoomMatrix(roomMatrix, plan.upgradeSite);
        for (let mineId in plan.mines) {
            plan.mines[mineId].road = PathFinder.search(corePos, { pos: plan.mines[mineId].container[0], range: 1 }, roadCreationOpts).path;
            this.addBuildingsToRoomMatrix(roomMatrix, plan.mines[mineId]);
        }
        //
        this.outRoomPlan.put(plan);
        return;
    }
}

class Future {
    constructor() {
        this.resolved = false;
    }
    put(value) {
        if (this.resolved)
            // TODO - error
            throw "";
        this.value = value;
        this.resolved = true;
    }
}

class RoomPlanner {
    constructor(roomName, initialSpawn, customGenerator, roomPlan) {
        this.id = `RoomPlanner_${roomName}`;
        this.roomName = roomName;
        this.initialSpawn = initialSpawn;
        this.roomPlan = roomPlan;
        this.generators = customGenerator ? [customGenerator] : [RoomLayoutGeneratorBunker, RoomLayoutGeneratorFlex];
    }
    // ----------------------------------------------------
    *run() {
        for (let generatorClass of this.generators) {
            const generator = new generatorClass(this.roomName, this.initialSpawn, this.roomPlan);
            const updateGen = generator.update();
            while (!updateGen.next().done)
                yield EThreadStatus.Ready;
            if (this.roomPlan.resolved) {
                break;
            }
        }
        if (!this.roomPlan.resolved)
            this.roomPlan.put(null);
        return EThreadStatus.Finished;
    }
}
RoomPlanner.FlagColor = COLOR_GREEN;
__decorate([
    check,
    profile("Other" /* ProfilerFunctionType.Other */)
], RoomPlanner.prototype, "run", null);
class RoomPlannerTestTool {
    static run() {
        var _a;
        const flag = Game.flags['Plan'];
        if (flag) {
            let planner = this.planners[Math.min(flag.color - 1, this.planners.length)];
            if (!this.roomPlan || this.roomPlan.resolved && (this.roomPlan.value.pos.roomName !== flag.pos.roomName || this.planner !== planner)) {
                this.roomPlan = new Future();
                this.planner = planner;
                GKernel.createThread(RoomPlanner, flag.pos.roomName, null, this.planner, this.roomPlan);
            }
            if ((_a = this.roomPlan) === null || _a === void 0 ? void 0 : _a.resolved) {
                RoomLayoutGenerator.visualizePlan(this.roomPlan.value);
            }
        }
        else {
            this.roomPlan = null;
        }
    }
}
RoomPlannerTestTool.planners = [
    RoomLayoutGeneratorBunker,
    RoomLayoutGeneratorFlex
];
RoomPlannerTestTool.roomPlan = null;
RoomPlannerTestTool.planner = null;
global.RoomPlannerTestTool = RoomPlannerTestTool;

var RoomType;
(function (RoomType) {
    RoomType[RoomType["Default"] = 0] = "Default";
})(RoomType || (RoomType = {}));
class OperationClaim extends BaseGlobalOperation {
    constructor(empire, id) {
        super(empire, id);
        this.attempts = 0;
        this.roomPlan = null;
        this.createRoomResult = null;
    }
    init(roomName, roomType) {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            closing: false,
            roomName: roomName,
            roomType: roomType
        };
        Memory.operations[this.id] = memory;
    }
    get memory() {
        return super.memory;
    }
    get roomName() {
        return this.memory.roomName;
    }
    updateEstimatedStats() {
        this.estimatedStats.energyPerTick = 0;
        this.estimatedStats.spawnTime = 0;
        this.estimatedStats.baseCpu = 0.2;
    }
    close() {
        if (this.attempts > 0)
            super.close();
    }
    isValidSpawnRoom(myRoom) {
        const minimumCreepCost = BODYPART_COST[CLAIM] + BODYPART_COST[MOVE];
        if (myRoom.room.energyCapacityAvailable < minimumCreepCost)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_CLAIM_LIFE_TIME)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        return true;
    }
    getSpawnRequestsInternal() {
        if (this.memory.closing)
            return [];
        if (this.creeps.length > 0)
            return [];
        if (this.room && this.room.controller && this.room.controller.owner)
            return [];
        let nameBase = Config.CreepNames.Claimer;
        if (Common.isHighway(this.roomName)) {
            let capitalizedShardName = Game.shard.name.charAt(0).toUpperCase() + Game.shard.name.slice(1);
            nameBase += 'From' + capitalizedShardName;
        }
        let result = [];
        const moveCount = this.spawnRoom.energyCapacityAvailable >= BODYPART_COST[CLAIM] + 5 * BODYPART_COST[MOVE]
            ? 5
            : 1;
        result.push({
            id: generateRandomKey(5),
            nameBase: nameBase,
            priority: FlagSpawnPriority,
            minEnergy: BODYPART_COST[CLAIM] + BODYPART_COST[MOVE],
            parts: new CreepBody(`X${moveCount}M`),
            memory: {},
            boostOptions: [null],
            noRepurpose: false,
            operation: this
        });
        return result;
    }
    claimerFunc(creep) {
        let goToOpts = {
            ignoreRoads: true,
            ensurePath: true,
            maxOps: 20000,
            offroad: creep.getActiveBodyparts(MOVE) >= 5 * creep.getActiveBodyparts(CLAIM),
            allowPortals: !Common.isControllerRoom(this.roomName),
            obstacles: this.creeps.map(c => c.pos)
        };
        const roomIntel = GIntel.rooms[this.roomName];
        if (creep.getActiveBodyparts(CLAIM) === 0)
            creep.suicide();
        else if (creep.pos.roomName === this.roomName && this.room.controller) {
            if (creep.pos.isNearTo(this.room.controller.pos)) {
                if (roomIntel.isHostile)
                    creep.attackController(this.room.controller);
                else
                    creep.claimController(this.room.controller);
            }
            else
                creep.goTo(this.room.controller.pos, 1, goToOpts);
        }
        // intershard portal claiming
        else if (creep.pos.roomName === this.roomName) {
            let claimFlag = creep.room.find(FIND_FLAGS).find(f => f.name.startsWith('Claim'));
            if (claimFlag)
                creep.goTo(claimFlag.pos, 0, Object.assign(Object.assign({}, goToOpts), { allowPortals: true }));
            else {
                creep.say('???');
                if (creep.pos.isExit())
                    creep.moveOffExit();
                else
                    creep.giveWay(true);
            }
        }
        else if (roomIntel && roomIntel.controllerPos) {
            creep.goTo(roomIntel.controllerPos, 1, goToOpts);
        }
        else {
            creep.goToRoom(this.roomName, goToOpts);
        }
    }
    onRun() {
        var _a, _b;
        if (_.size(Memory.myRooms) >= Game.gcl.level
            && _.every(Memory.myRooms, (memory, roomName) => Game.rooms[roomName]
                && Game.rooms[roomName].controller.my)) {
            this.abort();
            return;
        }
        const roomIntel = GIntel.rooms[this.roomName];
        if (roomIntel && roomIntel.owner && !roomIntel.isMy) {
            this.abort();
            return;
        }
        let room = Game.rooms[this.roomName];
        if ((_a = room === null || room === void 0 ? void 0 : room.controller) === null || _a === void 0 ? void 0 : _a.my) {
            let hostileStructures = room.find(FIND_STRUCTURES, { filter: s => !s.isMy() && s.structureType !== STRUCTURE_ROAD });
            for (let hostileStructure of hostileStructures)
                hostileStructure.destroy();
            if (Memory.myRooms[this.roomName]) {
                for (let creep of this.creeps)
                    creep.suicide();
                if (this.creeps.length === 0)
                    this.memory.closing = true;
            }
            else if (!this.memory.layoutPlaced) {
                if (!this.roomPlan) {
                    this.roomPlan = new Future();
                    GKernel.createThread(RoomPlanner, this.roomName, null, null, this.roomPlan);
                }
                else if (this.roomPlan.resolved && !this.createRoomResult) {
                    this.createRoomResult = new Future();
                    GKernel.createThread(RoomCreateTask, this.roomName, this.roomPlan.value, this.createRoomResult);
                }
                else if ((_b = this.createRoomResult) === null || _b === void 0 ? void 0 : _b.resolved) {
                    this.memory.layoutPlaced = true;
                    this.memory.closing = true;
                }
            }
            return;
        }
        // intershard
        let intershardClaimer = _.find(Game.creeps, c => c.getActiveBodyparts(CLAIM) > 0 && c.name.startsWith('ClaimerFrom') && Game.map.getRoomLinearDistance(c.pos.roomName, this.roomName) * 50 <= c.ticksToLive);
        if (intershardClaimer && !this.memory.creeps.includes(intershardClaimer.name))
            this.memory.creeps.push(intershardClaimer.name);
        //
        if (this.creeps.length > 0 && this.creeps[0].ticksToLive === CREEP_CLAIM_LIFE_TIME - 1)
            ++this.attempts;
        if (this.attempts >= 3)
            this.memory.closing = true;
        for (let creep of this.creeps)
            this.claimerFunc(creep);
    }
}
OperationClaim.OperationType = 'Claim';
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationClaim.prototype, "getSpawnRequestsInternal", null);
__decorate([
    check,
    profile()
], OperationClaim.prototype, "onRun", null);

class StrategyClaim extends BaseStrategy {
    constructor(empire) {
        super(empire);
        if (!this.memory) {
            let strategyMemory = {};
            Memory.strategies['Claim'] = strategyMemory;
        }
    }
    get memory() {
        return Memory.strategies['Claim'];
    }
    createGlobalOperations(activeOperations) {
        let myRooms = this.empire.myRooms;
        let preferredRooms = _(Game.flags).filter((f) => f.name.startsWith('Claim') && (!f.room || !f.room.myRoom)).map(f => f.pos.roomName).value();
        if (preferredRooms.length === 0 && (!Memory.toggles || !Memory.toggles.autoclaim))
            return null;
        let claimedRoomsCount = this.empire.info.totalRoomCount;
        let claimingOperations = _.filter(activeOperations, go => go instanceof OperationClaim);
        if (claimedRoomsCount + claimingOperations.length >= Game.gcl.level)
            return null;
        let consideredRooms = [];
        let maxConsideredRoomsKey = 0;
        let nodes = myRooms
            .filter(mr => mr.room.energyCapacityAvailable >= 650)
            .map(mr => ({
            roomName: mr.roomName,
            distance: 0
        }));
        if (nodes.length === 0)
            return null;
        let checkedRooms = new Set();
        for (let myRoom of myRooms) {
            checkedRooms.add(myRoom.roomName);
        }
        do {
            let node = nodes.shift();
            let exits = Game.map.describeExits(node.roomName);
            for (let exitDir in exits) {
                const exitRoomName = exits[exitDir];
                const newDistance = node.distance + 1;
                if (newDistance > Config.ROOM_SPREAD_MAX)
                    continue;
                if (checkedRooms.has(exitRoomName))
                    continue;
                checkedRooms.add(exitRoomName);
                if (Game.map.getRoomStatus(exitRoomName).status === 'closed')
                    continue;
                const roomIntel = GIntel.rooms[exitRoomName];
                if (roomIntel && roomIntel.owner)
                    continue;
                if (roomIntel && !roomIntel.isSafe)
                    continue;
                if (!Treaties.canBeClaimed(exitRoomName))
                    continue;
                const isFarEnough = newDistance >= Config.ROOM_SPREAD_MIN;
                const hasController = Common.isControllerRoom(exitRoomName);
                const isReserved = roomIntel && roomIntel.reservation && !roomIntel.isFriendly;
                const hasEnoughSources = !roomIntel || roomIntel.sources && roomIntel.sources.length > 1;
                if (isFarEnough && hasController && !isReserved && hasEnoughSources) {
                    let distanceFromPrefered = Math.abs(Config.ROOM_SPREAD_PREFERRED - newDistance);
                    if (!consideredRooms[distanceFromPrefered])
                        consideredRooms[distanceFromPrefered] = [];
                    consideredRooms[distanceFromPrefered].push(exitRoomName);
                    if (distanceFromPrefered > maxConsideredRoomsKey)
                        maxConsideredRoomsKey = distanceFromPrefered;
                }
                nodes.push({
                    roomName: exitRoomName,
                    distance: newDistance
                });
            }
        } while (nodes.length > 0);
        let chosenRoom = undefined;
        if (preferredRooms.length > 0) {
            chosenRoom = _.sample(preferredRooms);
        }
        else {
            for (let i = 0; i < maxConsideredRoomsKey; ++i) {
                if (consideredRooms[i]) {
                    chosenRoom = _.sample(consideredRooms[i]);
                    break;
                }
            }
        }
        if (!chosenRoom)
            return null;
        let operation = new OperationClaim(this.empire, 'Claim_' + chosenRoom + '_' + Game.time);
        operation.init(chosenRoom, RoomType.Default);
        return [operation];
    }
}
__decorate([
    check
], StrategyClaim.prototype, "createGlobalOperations", null);

class OperationHarassResults {
    static registerResult(roomName, result) {
        this.cachedSegment[roomName] = this.cachedSegment[roomName] || [];
        this.cachedSegment[roomName].push(result);
        if (this.cachedSegment[roomName].length > 3)
            this.cachedSegment[roomName].shift();
        SegmentManager.setSegment(Config.segments.harassResults, this.cachedSegment);
    }
    static getResults(roomName) {
        return this.cachedSegment[roomName] || [];
    }
    static load() {
        if (!this.cachedSegment) {
            this.cachedSegment = SegmentManager.getSegment(Config.segments.harassResults);
            if (this.cachedSegment) {
                console.log('loaded OperationHarassResults segment');
            }
            else if (SegmentManager.isSegmentLoaded(Config.segments.harassResults)) {
                if (SegmentManager.setSegment(Config.segments.harassResults, {})) {
                    console.log('initialized OperationHarassResults segment');
                    this.cachedSegment = {};
                }
            }
        }
        return !!this.cachedSegment;
    }
}

class BaseHarassOperation extends BaseGlobalOperation {
    // ---------------------------------------------------------------------
    constructor(empire, id) {
        super(empire, id);
        if (this.memory) {
            this.remoteList = this.makeRemoteList(this.memory.roomName);
            this.naturalRemotes = this.makeNaturalRemoteList(this.memory.roomName);
        }
    }
    // ---------------------------------------------------------------------
    get memory() {
        return super.memory;
    }
    get roomName() {
        return this.memory.roomName;
    }
    // ---------------------------------------------------------------------
    init(roomName) {
        this.remoteList = this.makeRemoteList(roomName);
        this.naturalRemotes = this.makeNaturalRemoteList(roomName);
    }
    onInitForTick() {
        super.onInitForTick();
        this._hostiles = {};
        this._structures = {};
    }
    // ---------------------------------------------------------------------
    makeRemoteList(roomName) {
        let result = [];
        let checked = new Set([]);
        const mainRoomOwner = GIntel.rooms[roomName].owner;
        let nodes = [{
                roomName: roomName,
                depth: 0
            }];
        while (nodes.length > 0) {
            const node = nodes.shift();
            const exits = Game.map.describeExits(node.roomName);
            for (let exitDir in exits) {
                const neighbour = exits[exitDir];
                if (checked.has(neighbour))
                    continue;
                checked.add(neighbour);
                const roomIntel = GIntel.rooms[neighbour];
                if (!roomIntel)
                    continue;
                if (!roomIntel.usedByHostile)
                    continue;
                if (roomIntel.usedByHostile.username !== mainRoomOwner)
                    continue;
                result.push(neighbour);
                if (node.depth < 3) {
                    nodes.push({
                        roomName: neighbour,
                        depth: node.depth + 1
                    });
                }
            }
        }
        return result;
    }
    makeNaturalRemoteList(roomName) {
        let result = [];
        const exits = Game.map.describeExits(roomName);
        for (let dir in exits) {
            const exit = exits[dir];
            if (GIntel.rooms[exit] && GIntel.rooms[exit].isControllerRoom || Common.isControllerRoom(exit))
                result.push(exit);
        }
        return result;
    }
    changeCurrentRemote() {
        let remotesToAttack = this.remoteList.filter((r, i, a) => {
            if (GIntel.rooms[r] && GIntel.rooms[r].owner)
                return false;
            if (this.memory.currentRemote && r === this.memory.currentRemote)
                return false;
            if (a.length > 2 && this.memory.lastRemote && r === this.memory.lastRemote)
                return false;
            return true;
        });
        if (remotesToAttack.length === 0) {
            remotesToAttack = this.naturalRemotes.filter((r, i, a) => {
                if (GIntel.rooms[r] && GIntel.rooms[r].owner)
                    return false;
                if (this.memory.currentRemote && r === this.memory.currentRemote)
                    return false;
                if (a.length > 2 && this.memory.lastRemote && r === this.memory.lastRemote)
                    return false;
                return true;
            });
        }
        if (remotesToAttack.length === 0) {
            this.memory.currentRemote = this.roomName;
            return;
        }
        let opts = {
            dontIgnoreCreeps: true,
            ignoreRoads: true,
            avoidHostileRooms: true,
            maxOps: 20000
        };
        const goals = remotesToAttack.map(r => ({
            pos: new RoomPosition(25, 25, r),
            range: 23
        }));
        const searchResult = Pather.findPathToClosest(this.creeps[0].pos, goals, opts);
        const lastPosRoomName = searchResult.incomplete
            ? goals[0].pos.roomName
            : searchResult.path.length > 0
                ? _.last(searchResult.path).roomName
                : this.creeps[0].pos.roomName;
        if (remotesToAttack.includes(lastPosRoomName)) {
            this.memory.lastRemote = this.memory.currentRemote;
            this.memory.currentRemote = lastPosRoomName;
            this.memory.boredomCounter = 0;
            for (let creep of this.creeps) {
                const creepMemory = creep.memory;
                creepMemory.targetPos = undefined;
                creepMemory.targetId = undefined;
                creepMemory.healerId = undefined;
            }
        }
    }
    // ---------------------------------------------------------------------
    findNewTarget(creep, hostiles, structures) {
        if (creep.pos.roomName !== this.memory.currentRemote) {
            return {
                targetPos: undefined,
                targetId: undefined
            };
        }
        const range = creep.body.find(bp => bp.type === RANGED_ATTACK) ? 3 : 1;
        const canAttackCreeps = !!creep.body.find(bp => bp.type === RANGED_ATTACK || bp.type === ATTACK);
        const healingPower = _.sum(creep.pos.lookInRange(LOOK_CREEPS, 1), c => c.my ? HEAL_POWER * getBodypartPower(HEAL, c) : 0);
        const opts = {
            avoidDamage: healingPower || 1,
            avoidDamageMargin: 2,
            ignoreRoads: true
        };
        // pick target list, prefer creeps over structures
        let targets;
        let searchResult = undefined;
        if (canAttackCreeps && hostiles.length > 0) {
            targets = hostiles;
            searchResult = Pather.findPathToClosest(creep.pos, targets.map(t => ({ pos: t.pos, range: range })), opts);
        }
        if ((!searchResult || searchResult.incomplete) && structures.length > 0 && !GIntel.rooms[creep.pos.roomName].usedByAlly) {
            targets = structures;
            searchResult = Pather.findPathToClosest(creep.pos, targets.map(t => ({ pos: t.pos, range: range })), opts);
        }
        //
        if (searchResult && !searchResult.incomplete) {
            let target = targets.find(t => t.pos.inRangeTo(_.last(searchResult.path) || creep.pos, range));
            // it could find tile "in range" from another room
            if (!target) {
                return {
                    targetPos: undefined,
                    targetId: undefined
                };
            }
            else {
                return {
                    targetPos: target.pos.serialize(),
                    targetId: target.id
                };
            }
        }
        else {
            return {
                targetPos: undefined,
                targetId: undefined
            };
        }
    }
    shouldFlee(creep, hostiles) {
        const meleeHostiles = hostiles.filter(h => h.getActiveBodyparts(ATTACK));
        const rangedHostiles = hostiles.filter(h => h.getActiveBodyparts(RANGED_ATTACK));
        const mPowerInRange = _.sum(meleeHostiles, h => creep.pos.inRangeTo(h.pos, 2) ? ATTACK_POWER * getBodypartPower(ATTACK, h) : 0);
        const rPowerInRange = _.sum(rangedHostiles, h => creep.pos.inRangeTo(h.pos, 4) ? RANGED_ATTACK_POWER * getBodypartPower(RANGED_ATTACK, h) : 0);
        const healingPower = _.sum(creep.pos.lookInRange(LOOK_CREEPS, 1), c => c.my ? HEAL_POWER * getBodypartPower(HEAL, c) : 0);
        //const ourPower = _.sum(creep.pos.lookInRange(LOOK_CREEPS, 1), c => c.my ? RANGED_ATTACK_POWER * Utils.getBodypartPower(RANGED_ATTACK, c) + ATTACK_POWER * Utils.getBodypartPower(ATTACK, c) : 0);
        return mPowerInRange + rPowerInRange > healingPower; // + ourPower;
    }
    getHostiles(roomName) {
        if (!this._hostiles[roomName]) {
            this._hostiles[roomName] = Game.rooms[roomName].findHostileCreeps().filter(h => {
                if (h.owner.username === 'Source Keeper')
                    return false;
                if (h.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_RAMPART))
                    return false;
                return true;
            });
        }
        return this._hostiles[roomName];
    }
    getStructures(roomName) {
        if (!this._structures[roomName]) {
            let roomIntel = GIntel.rooms[roomName];
            if (roomIntel && roomIntel.isFriendly) {
                this._structures[roomName] = [];
            }
            else {
                this._structures[roomName] = Game.rooms[roomName].find(FIND_STRUCTURES).filter(s => {
                    if (!s.isBuildable())
                        return false;
                    if (s.hits >= 10000)
                        return false;
                    return true;
                });
            }
        }
        return this._structures[roomName];
    }
    moveToCurrentRemote(creep) {
        let opts = {
            dontIgnoreCreeps: true,
            ensurePath: true
        };
        const creepMemory = creep.memory;
        if (creepMemory.targetPos)
            creep.goTo(RoomPosition.deserialize(creepMemory.targetPos), 3, opts);
        else
            creep.goToRoom(this.memory.currentRemote, opts);
    }
    flee(creep) {
        const creepMemory = creep.memory;
        const healer = Game.getObjectById(creepMemory.healerId);
        let healingPower = HEAL_POWER * getBodypartPower(HEAL, creep);
        if (healer)
            healingPower += HEAL_POWER * getBodypartPower(HEAL, healer);
        const roomFleeOpts = {
            avoidDamage: healingPower || 1,
            avoidDamageWeight: 240,
            avoidDamageMargin: 2,
            forceRecalc: true
        };
        creep.fleeFromRoom(this.memory.currentRemote, roomFleeOpts);
    }
    visualize(creep, targetPos) {
        if (targetPos) {
            let visual = Common.getRoomVisual(targetPos.roomName);
            visual.text('\u{274C}', targetPos, {});
            visual.multiRoomLine(creep.pos, targetPos, { color: '#ff0000', lineStyle: 'dotted', opacity: 0.75, width: 0.1 });
        }
    }
    // ---------------------------------------------------------------------
    updateExpensesCaused() {
        let checkedRooms = new Set([]);
        for (let creep of this.creeps) {
            const room = creep.room;
            const roomIntel = GIntel.rooms[room.name];
            if (checkedRooms.has(room.name))
                continue;
            if (roomIntel && roomIntel.isFriendly)
                continue;
            let tombstones = room.find(FIND_TOMBSTONES);
            for (let t of tombstones) {
                if (t.deathTime === Game.time - 1 && t.creep.ticksToLive > 1)
                    this.memory.expensesCaused += _.sum(t.creep.body, bp => BODYPART_COST[bp.type]);
            }
            let ruins = room.find(FIND_RUINS);
            for (let r of ruins) {
                if (r.destroyTime === Game.time - 1)
                    this.memory.expensesCaused += CONSTRUCTION_COST[r.structure.structureType] || 0;
            }
        }
    }
    // ---------------------------------------------------------------------
    get rallyPos() {
        if (this._rallyPos) {
            const rallySize = this.targetCreepCount >= 4 ? 3 : 2;
            for (let i = 0; i < this.targetCreepCount; ++i) {
                if (Common.getRallyCreepPosition(this._rallyPos, rallySize, i).lookFor(LOOK_CREEPS).find(c => !this.creeps.includes(c))) {
                    this._rallyPos = undefined;
                    break;
                }
            }
        }
        if (!this._rallyPos)
            this._rallyPos = Common.findRally(Game.rooms[this.spawnRoomName], this.targetCreepCount, new RoomPosition(25, 25, this.spawnRoomName), this.creeps);
        return this._rallyPos;
    }
    rally() {
        if (this.targetCreepCount === 1) {
            this.memory.status = 2 /* HarassOperationStatus.Traveling */;
            this.memory.travelStart = Game.time;
            return;
        }
        if (!this.rallyPos) {
            for (let creep of this.creeps) {
                creep.say('\u{1F635}');
                creep.giveWay();
            }
            return;
        }
        Game.rooms[this.spawnRoomName].visual.text(this.id, this.rallyPos.x - 0.5, this.rallyPos.y - 0.6, { align: 'left', color: '#ff00ff', font: 0.25 });
        Game.rooms[this.spawnRoomName].visual.rect(this.rallyPos.x - 0.5, this.rallyPos.y - 0.5, 3, 3, { fill: null, stroke: '#ff00ff', strokeWidth: 0.05 });
        const rallySize = this.targetCreepCount >= 4 ? 3 : 2;
        let areRallied = this.creeps.length >= this.targetCreepCount;
        let giveWayers = [];
        for (let i = 0; i < this.creeps.length; ++i) {
            const creep = this.creeps[i];
            const spot = Common.getRallyCreepPosition(this.rallyPos, rallySize, i);
            if (!creep.pos.isEqualTo(spot)) {
                creep.goTo(spot, 0);
                areRallied = false;
            }
            else {
                giveWayers.push(creep);
            }
        }
        if (areRallied) {
            this.memory.status = 2 /* HarassOperationStatus.Traveling */;
            this.memory.travelStart = Game.time;
        }
        else {
            for (let c of giveWayers)
                c.giveWay();
        }
    }
    travel() {
        if (this.creeps.length === 0)
            return;
        const travelOpts = {
            dontIgnoreCreeps: true,
            ignoreRoads: true,
            avoidHostileRooms: true,
            ensurePath: true
        };
        const targetRoomName = this.memory.currentRemote || this.roomName;
        Pather.sneakGoTo(this.creeps, new RoomPosition(25, 25, targetRoomName), 22, travelOpts);
        for (let creep of this.creeps) {
            if (creep.getActiveBodyparts(HEAL)) {
                let lowestInRange = _.max(this.creeps, c => c.pos.isNearTo(creep.pos) ? c.hitsMax - c.hits : -Infinity);
                if (lowestInRange.hits < lowestInRange.hitsMax)
                    creep.heal(lowestInRange);
            }
            if (creep.getActiveBodyparts(RANGED_ATTACK))
                creep.shootAtWill(creep.room.findHostileCreeps());
        }
        if (this.creeps.some(c => c.pos.roomName === targetRoomName)) {
            this.memory.travelTime = Game.time - this.memory.travelStart;
            this.memory.status = 3 /* HarassOperationStatus.Attacking */;
        }
    }
    // ---------------------------------------------------------------------
    healerFunc(healer) {
        let healerMemory = healer.memory;
        let target = Game.getObjectById(healerMemory.targetId);
        if (!target) {
            const creepsNeedingHealer = this.creeps.filter(c => c.memory.role !== 3 /* CreepRole.Healer */ && !Game.getObjectById(c.memory.healerId));
            const newTarget = creepsNeedingHealer.find(c => !!c.body.find(bp => bp.type === ATTACK))
                || creepsNeedingHealer.find(c => !c.body.find(bp => bp.type === HEAL))
                || creepsNeedingHealer[0];
            if (newTarget) {
                target = newTarget;
                let targetMemory = target.memory;
                healerMemory.targetId = target.id;
                targetMemory.healerId = healer.id;
            }
        }
        if (!target) {
            healer.heal(healer);
            healer.giveWay();
            return;
        }
        if (healer.pos.isNearTo(target.pos)) {
            target.pull(healer);
            healer.move(target);
        }
        else {
            healer.goTo(target.pos, 0);
        }
        if (healer.hitsMax - healer.hits > target.hitsMax - target.hits)
            healer.heal(healer);
        else if (healer.pos.isNearTo(target.pos))
            healer.heal(target);
        else if (healer.pos.inRangeTo(target.pos, 3))
            healer.rangedHeal(target);
        else
            healer.heal(healer);
    }
}

class OperationHarass extends BaseHarassOperation {
    // ---------------------------------------------------------------------
    constructor(empire, id) {
        super(empire, id);
        this.targetCreepCount = 1;
    }
    // ---------------------------------------------------------------------
    get memory() {
        return super.memory;
    }
    get roomName() {
        return this.memory.roomName;
    }
    // ---------------------------------------------------------------------
    init(roomName) {
        super.init(roomName);
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            closing: false,
            roomName: roomName,
            wasSpawned: false,
            reported: false,
            status: 1 /* HarassOperationStatus.Rallying */,
            expensesCaused: 0,
            boredomCounter: 0
        };
        Memory.operations[this.id] = memory;
    }
    // ---------------------------------------------------------------------
    updateCreepComposition() {
        const maxParts = Math.min(12, Math.floor(this.spawnRoom.energyCapacityAvailable / (BODYPART_COST[HEAL] + BODYPART_COST[RANGED_ATTACK] + 2 * BODYPART_COST[MOVE])));
        this.creepComposition = {
            body: new CreepBody(`${maxParts}R${2 * maxParts}M${maxParts}H`),
            energyCapacityAvailable: this.spawnRoom.energyCapacityAvailable
        };
        this.shouldUpdateEstimatedStats = true;
    }
    updateEstimatedStats() {
        if (!this.spawnRoom) {
            this.estimatedStats.energyPerTick = 0;
            this.estimatedStats.spawnTime = 0;
            this.estimatedStats.baseCpu = 0.4;
        }
        else {
            this.estimatedStats.energyPerTick = -this.creepComposition.body.cost / CREEP_LIFE_TIME;
            this.estimatedStats.spawnTime = this.creepComposition.body.spawnTime;
            this.estimatedStats.baseCpu = 0.4;
        }
    }
    close() {
        if (this.memory.reported)
            super.close();
    }
    isValidSpawnRoom(myRoom) {
        if (myRoom.room.energyCapacityAvailable < 500)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME / 2)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        return true;
    }
    onAssignSpawnRoom() {
        this.updateCreepComposition();
    }
    // ---------------------------------------------------------------------
    getSpawnRequestsInternal() {
        if (!this.spawnRoom)
            return [];
        if (this.creeps.length > 0)
            return [];
        let result = [];
        const creepMemory = {};
        result.push({
            id: generateRandomKey(5),
            nameBase: Config.CreepNames.Harasser,
            priority: FlagSpawnPriority,
            minEnergy: this.creepComposition.body.cost,
            parts: this.creepComposition.body,
            memory: creepMemory,
            boostOptions: [null],
            noRepurpose: false,
            operation: this
        });
        return result;
    }
    // ---------------------------------------------------------------------
    harasserFunc(creep) {
        // constants
        let creepMemory = creep.memory;
        let healer = Game.getObjectById(creepMemory.healerId);
        const hostiles = this.getHostiles(creep.pos.roomName);
        const structures = this.getStructures(creep.pos.roomName);
        // moving constants
        const shouldFlee = this.shouldFlee(creep, hostiles);
        let target = Game.getObjectById(creepMemory.targetId);
        let targetPos = creepMemory.targetPos && RoomPosition.deserialize(creepMemory.targetPos);
        if (!targetPos
            || GIntel.rooms[targetPos.roomName].safeMode
            || target && target.hits >= 10000
            || target && !target.pos.isEqualTo(targetPos)
            || targetPos.roomName !== this.memory.currentRemote
            || !target && creep.pos.roomName === targetPos.roomName
            || shouldFlee) {
            const newTarget = this.findNewTarget(creep, hostiles, structures);
            creepMemory.targetId = newTarget.targetId;
            creepMemory.targetPos = newTarget.targetPos;
            target = Game.getObjectById(creepMemory.targetId);
            targetPos = creepMemory.targetPos && RoomPosition.deserialize(creepMemory.targetPos);
        }
        const healingPower = _.sum(creep.pos.lookInRange(LOOK_CREEPS, 1), c => c.my ? HEAL_POWER * getBodypartPower(HEAL, c) : 0);
        const ourPower = _.sum(creep.pos.lookInRange(LOOK_CREEPS, 1), c => c.my ? RANGED_ATTACK_POWER * getBodypartPower(RANGED_ATTACK, c) + ATTACK_POWER * getBodypartPower(ATTACK, c) : 0);
        const opts = {
            dontIgnoreCreeps: true,
            avoidDamage: (healingPower + ourPower) || 1,
            avoidDamageMargin: 2
        };
        let distanceToTarget = target ? creep.pos.getRangeTo(target.pos) : undefined;
        let targetRange = creep.body.find(bp => bp.type === RANGED_ATTACK)
            ? (target && target instanceof Structure)
                ? 3
                : 2
            : 1;
        // moving
        if (healer && !healer.pos.isNearTo(creep) && !healer.pos.isExit() && !creep.pos.isExit())
            CombatPather.goTo(creep, healer.pos, 0);
        else if (this.memory.currentRemote && creep.pos.roomName !== this.memory.currentRemote)
            this.moveToCurrentRemote(creep);
        else if (shouldFlee)
            this.flee(creep);
        else if (target && distanceToTarget > targetRange)
            creep.goTo(target.pos, targetRange, opts);
        else if (target)
            creep.giveWay({ pos: target.pos, range: targetRange });
        else
            creep.smokeBreak();
        // visualize
        this.visualize(creep, targetPos);
        // shooting
        if (hostiles.find(h => h.pos.inRangeTo(creep.pos, 3)))
            creep.shootAtWill(hostiles);
        else if (structures.length > 0)
            creep.shootAtWill(structures);
        // healing
        if (creep.hits < creep.hitsMax)
            creep.heal(creep);
    }
    // ---------------------------------------------------------------------
    onRun() {
        if (this.creeps.length > 0 && this.creeps.some(c => !c.spawning)) {
            this.memory.wasSpawned = true;
            if (this.creeps.some(c => c.pos.roomName === this.memory.currentRemote)) {
                const hostiles = this.getHostiles(this.memory.currentRemote);
                if (hostiles.find(c => !c.pos.isExit()))
                    this.memory.boredomCounter = 0;
                else
                    ++this.memory.boredomCounter;
            }
            const currentRemoteIntel = GIntel.rooms[this.memory.currentRemote];
            if (!this.memory.currentRemote || (currentRemoteIntel && currentRemoteIntel.safeMode) || this.memory.boredomCounter > 100) {
                this.changeCurrentRemote();
            }
            if (this.memory.status === 1 /* HarassOperationStatus.Rallying */) {
                this.rally();
            }
            else if (this.memory.status === 2 /* HarassOperationStatus.Traveling */) {
                this.travel();
            }
            else {
                for (let creep of this.creeps)
                    this.harasserFunc(creep);
            }
            this.updateExpensesCaused();
        }
        if (!this.memory.reported && this.memory.wasSpawned && this.creeps.length === 0) {
            OperationHarassResults.registerResult(this.roomName, {
                harasserCost: this.creepComposition.body.cost,
                tick: Game.time,
                type: 0 /* EHarassType.Ranger */,
                travelTime: this.memory.travelTime,
                expensesCaused: this.memory.expensesCaused
            });
            this.memory.reported = true;
            this.close();
        }
    }
}
OperationHarass.OperationType = 'Harass';
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationHarass.prototype, "getSpawnRequestsInternal", null);
__decorate([
    profile()
], OperationHarass.prototype, "onRun", null);

class OperationRaid extends BaseHarassOperation {
    // ---------------------------------------------------------------------
    constructor(empire, id) {
        super(empire, id);
        this.targetCreepCount = 5;
        if (this.spawnRoom)
            this.onAssignSpawnRoom();
        if (this.memory)
            this.remoteList = this.makeRemoteList(this.memory.roomName);
    }
    // ---------------------------------------------------------------------
    get memory() {
        return super.memory;
    }
    get roomName() {
        return this.memory.roomName;
    }
    // ---------------------------------------------------------------------
    init(roomName) {
        super.init(roomName);
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            closing: false,
            roomName: roomName,
            wasSpawned: false,
            reported: false,
            status: 1 /* HarassOperationStatus.Rallying */,
            expensesCaused: 0,
            boredomCounter: 0
        };
        Memory.operations[this.id] = memory;
    }
    // ---------------------------------------------------------------------
    updateCreepComposition() {
        const healerPartsCount = Math.min(25, Math.floor(this.spawnRoom.energyCapacityAvailable / (BODYPART_COST[HEAL] + BODYPART_COST[MOVE])));
        const meleePartsCount = Math.min(25, Math.floor(this.spawnRoom.energyCapacityAvailable / (BODYPART_COST[ATTACK] + BODYPART_COST[MOVE])));
        const rangedPartsCount = Math.min(25, Math.floor(this.spawnRoom.energyCapacityAvailable / (BODYPART_COST[RANGED_ATTACK] + BODYPART_COST[MOVE])));
        const dismantlerPartsCount = Math.min(25, Math.floor(this.spawnRoom.energyCapacityAvailable / (BODYPART_COST[WORK] + BODYPART_COST[MOVE])));
        this.creepComposition = {
            healerBody: new CreepBody(`${healerPartsCount}M${healerPartsCount}H`),
            attackerBody: new CreepBody(`${meleePartsCount}A${meleePartsCount}M`),
            rangerBody: new CreepBody(`${rangedPartsCount}R${rangedPartsCount}M`),
            dismantlerBody: new CreepBody(`${dismantlerPartsCount}W${dismantlerPartsCount}M`),
            energyCapacityAvailable: this.spawnRoom.energyCapacityAvailable
        };
        this.shouldUpdateEstimatedStats = true;
    }
    updateEstimatedStats() {
        if (!this.creepComposition) {
            this.estimatedStats.energyPerTick = 0;
            this.estimatedStats.spawnTime = 0;
            this.estimatedStats.baseCpu = 1.0;
        }
        else {
            let creepsCost = this.creepComposition.attackerBody.cost
                + this.creepComposition.rangerBody.cost
                + 2 * this.creepComposition.healerBody.cost
                + this.creepComposition.dismantlerBody.cost;
            let spawnTime = this.creepComposition.attackerBody.spawnTime
                + this.creepComposition.rangerBody.spawnTime
                + 2 * this.creepComposition.healerBody.spawnTime
                + this.creepComposition.dismantlerBody.spawnTime;
            this.estimatedStats.energyPerTick = -creepsCost / CREEP_LIFE_TIME;
            this.estimatedStats.spawnTime = spawnTime;
            this.estimatedStats.baseCpu = 1.0;
        }
    }
    onInitForTick() {
        super.onInitForTick();
        this.healers = this.creeps.filter(c => !!c.body.find(b => b.type === HEAL));
        this.attacker = this.creeps.find(c => !!c.body.find(b => b.type === ATTACK));
        this.ranger = this.creeps.find(c => !!c.body.find(b => b.type === RANGED_ATTACK));
        this.dismantler = this.creeps.find(c => !!c.body.find(b => b.type === WORK));
    }
    isValidSpawnRoom(myRoom) {
        if (myRoom.room.energyCapacityAvailable < 300)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME / 2)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        return true;
    }
    onAssignSpawnRoom() {
        this.updateCreepComposition();
    }
    // ---------------------------------------------------------------------
    getSpawnRequestsInternal() {
        if (!this.spawnRoom)
            return [];
        if (this.memory.wasSpawned)
            return [];
        let result = [];
        if (!this.attacker) {
            result.push({
                id: generateRandomKey(5),
                priority: FlagSpawnPriority,
                nameBase: 'Raider',
                minEnergy: 300,
                parts: this.creepComposition.attackerBody,
                memory: {},
                boostOptions: [null],
                noRepurpose: false,
                operation: this
            });
        }
        if (!this.ranger) {
            result.push({
                id: generateRandomKey(5),
                nameBase: 'Raider',
                priority: FlagSpawnPriority,
                minEnergy: 300,
                parts: this.creepComposition.rangerBody,
                memory: {},
                boostOptions: [null],
                noRepurpose: false,
                operation: this
            });
        }
        const healersNeeded = 2 - this.healers.length;
        for (let i = 0; i < healersNeeded; ++i) {
            result.push({
                id: generateRandomKey(5),
                nameBase: 'Raider',
                priority: FlagSpawnPriority,
                minEnergy: 300,
                parts: this.creepComposition.healerBody,
                memory: {
                    role: 3 /* CreepRole.Healer */
                },
                boostOptions: [null],
                noRepurpose: false,
                operation: this
            });
        }
        if (!this.dismantler) {
            result.push({
                id: generateRandomKey(5),
                nameBase: 'Raider',
                priority: FlagSpawnPriority,
                minEnergy: 300,
                parts: this.creepComposition.dismantlerBody,
                memory: {},
                boostOptions: [null],
                noRepurpose: false,
                operation: this
            });
        }
        return result;
    }
    // ---------------------------------------------------------------------
    shootAtWill(raider, target) {
        if (raider.getActiveBodyparts(WORK)) {
            if (target instanceof Structure && raider.pos.isNearTo(target))
                raider.dismantle(target);
            else {
                let structure = raider.pos.lookInRange(LOOK_STRUCTURES, 1).find(s => s.isBuildable());
                if (structure)
                    raider.dismantle(structure);
            }
        }
        else {
            let targets = [
                ...raider.pos.lookInRange(LOOK_CREEPS, 3).filter(c => !c.my && !Config.WHITELIST.has(c.owner.username)),
                ...raider.pos.lookInRange(LOOK_STRUCTURES, 3).filter(s => s.isBuildable())
            ];
            raider.shootAtWill(targets, target);
        }
    }
    raiderFunc(creep) {
        // constants
        let creepMemory = creep.memory;
        let healer = Game.getObjectById(creepMemory.healerId);
        const hostiles = this.getHostiles(creep.pos.roomName);
        const structures = this.getStructures(creep.pos.roomName);
        // moving constants
        const shouldFlee = this.shouldFlee(creep, hostiles);
        let target = Game.getObjectById(creepMemory.targetId);
        let targetPos = creepMemory.targetPos && RoomPosition.deserialize(creepMemory.targetPos);
        if (!targetPos
            || target && !target.pos.isEqualTo(targetPos)
            || targetPos.roomName !== this.memory.currentRemote
            || !target && creep.pos.roomName === targetPos.roomName
            || shouldFlee) {
            const newTarget = this.findNewTarget(creep, hostiles, structures);
            creepMemory.targetId = newTarget.targetId;
            creepMemory.targetPos = newTarget.targetPos;
            target = Game.getObjectById(creepMemory.targetId);
            targetPos = creepMemory.targetPos && RoomPosition.deserialize(creepMemory.targetPos);
        }
        const healingPower = _.sum(creep.pos.lookInRange(LOOK_CREEPS, 1), c => c.my ? HEAL_POWER * getBodypartPower(HEAL, c) : 0);
        const ourPower = _.sum(creep.pos.lookInRange(LOOK_CREEPS, 1), c => c.my ? RANGED_ATTACK_POWER * getBodypartPower(RANGED_ATTACK, c) + ATTACK_POWER * getBodypartPower(ATTACK, c) : 0);
        const opts = {
            dontIgnoreCreeps: true,
            avoidDamage: (healingPower + ourPower) || 1,
            avoidDamageMargin: 2
        };
        let distanceToTarget = target ? creep.pos.getRangeTo(target.pos) : undefined;
        let targetRange = creep.body.find(bp => bp.type === RANGED_ATTACK)
            ? (target && target instanceof Structure)
                ? 3
                : 2
            : 1;
        // moving
        if (healer && !healer.pos.isNearTo(creep) && !healer.pos.isExit() && !creep.pos.isExit())
            CombatPather.goTo(creep, healer.pos, 0);
        else if (creep.pos.roomName !== this.memory.currentRemote)
            this.moveToCurrentRemote(creep);
        else if (shouldFlee)
            this.flee(creep);
        else if (target && distanceToTarget > targetRange)
            creep.goTo(target.pos, targetRange, opts);
        else if (target)
            creep.giveWay({ pos: target.pos, range: targetRange });
        else
            creep.smokeBreak();
        // visualize
        this.visualize(creep, targetPos);
        // shooting
        this.shootAtWill(creep, target);
    }
    // ---------------------------------------------------------------------
    onRun() {
        if (this.creeps.length > 0 && this.creeps.some(c => !c.spawning)) {
            if (!this.memory.currentRemote)
                this.changeCurrentRemote();
            else if (this.creeps.some(c => c.pos.roomName === this.memory.currentRemote)) {
                const hostiles = this.getHostiles(this.memory.currentRemote);
                const structures = this.getStructures(this.memory.currentRemote);
                if (structures.length === 0 && hostiles.length === 0) {
                    this.changeCurrentRemote();
                }
            }
            if (this.memory.status === 1 /* HarassOperationStatus.Rallying */) {
                this.rally();
            }
            else if (this.memory.status === 2 /* HarassOperationStatus.Traveling */) {
                this.memory.wasSpawned = true;
                this.travel();
            }
            else {
                for (let healer of this.healers) {
                    this.healerFunc(healer);
                }
                let raiders = [this.attacker, this.ranger, this.dismantler];
                for (let raider of raiders) {
                    if (raider) {
                        this.raiderFunc(raider);
                    }
                }
            }
        }
        if (!this.memory.reported && this.memory.wasSpawned && this.creeps.length === 0) {
            const operationCost = 2 * this.creepComposition.healerBody.cost
                + this.creepComposition.attackerBody.cost
                + this.creepComposition.rangerBody.cost
                + this.creepComposition.dismantlerBody.cost;
            OperationHarassResults.registerResult(this.roomName, {
                harasserCost: operationCost,
                tick: Game.time,
                type: 1 /* EHarassType.Raid */,
                travelTime: this.memory.travelTime,
                expensesCaused: this.memory.expensesCaused
            });
            this.memory.reported = true;
            this.close();
        }
    }
}
OperationRaid.OperationType = 'Raid';
OperationRaid.travelOpts = {};
__decorate([
    profile()
], OperationRaid.prototype, "onInitForTick", null);
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationRaid.prototype, "getSpawnRequestsInternal", null);
__decorate([
    profile()
], OperationRaid.prototype, "onRun", null);

class StrategyHarass extends BaseStrategy {
    constructor(empire) {
        super(empire);
        if (!this.memory) {
            let strategyMemory = {
                raidCounter: 0
            };
            Memory.strategies['Harass'] = strategyMemory;
        }
        if (this.memory.raidCounter === undefined)
            this.memory.raidCounter = 0;
    }
    get memory() {
        return Memory.strategies['Harass'];
    }
    createGlobalOperations(activeOperations) {
        if (!Memory.toggles || !Memory.toggles.autoharass)
            return null;
        let harassOperations = _.filter(activeOperations, go => go instanceof OperationHarass || go instanceof OperationRaid);
        if (harassOperations.length >= Math.min(this.empire.myRooms.length, 6))
            return null;
        const shouldRaid = (this.memory.raidCounter === 19);
        let potentialTargets = [];
        for (let roomName in GIntel.rooms) {
            const roomIntel = GIntel.rooms[roomName];
            if (!roomIntel.owner)
                continue;
            if (roomIntel.isFriendly || roomIntel.isMy)
                continue;
            if (harassOperations.some(o => o.roomName === roomName))
                continue;
            if (!Treaties.canBeAttacked(roomName))
                continue;
            const hasRemotes = _.some(Game.map.describeExits(roomName), neighbour => {
                const neighbourIntel = GIntel.rooms[neighbour];
                if (!neighbourIntel)
                    return false;
                if (neighbourIntel.towers > 0)
                    return false;
                if (!neighbourIntel.usedByHostile || neighbourIntel.usedByHostile.username !== roomIntel.owner)
                    return false;
                return true;
            });
            if (!hasRemotes)
                continue;
            if (!shouldRaid) {
                const harassResults = OperationHarassResults.getResults(roomName);
                if (harassResults.length > 0) {
                    const lastResult = _.last(harassResults);
                    const sumResult = _.sum(harassResults, hr => hr.expensesCaused - hr.harasserCost);
                    if (sumResult < 0 && Game.time - lastResult.tick < 9000) {
                        continue;
                    }
                }
            }
            potentialTargets.push(roomName);
        }
        if (potentialTargets.length === 0)
            return null;
        this.memory.raidCounter = (this.memory.raidCounter + 1) % 20;
        let targetRoomName = _.sample(potentialTargets);
        if (shouldRaid) {
            let operation = new OperationRaid(this.empire, 'Raid_' + targetRoomName + '_' + Game.time);
            operation.init(targetRoomName);
            return [operation];
        }
        else {
            let operation = new OperationHarass(this.empire, 'Harass_' + targetRoomName + '_' + Game.time);
            operation.init(targetRoomName);
            return [operation];
        }
    }
}
__decorate([
    check
], StrategyHarass.prototype, "createGlobalOperations", null);

class OperationHitSquad extends BaseGlobalOperation {
    constructor(empire, id) {
        super(empire, id);
        this._assemblePos = undefined;
        this._assembleRoom = undefined;
        this._rallyPos = undefined;
        this.creepBody = undefined;
    }
    init(roomName) {
        if (Memory.operations[this.id])
            return;
        let boostTier = 0;
        let attackRoomRcl = 0;
        let roomIntel = GIntel.rooms[roomName];
        if (roomIntel) {
            if (roomIntel.towers <= 1) {
                boostTier = 0;
                attackRoomRcl = 7;
            }
            else if (roomIntel.towers <= 2) {
                boostTier = 1;
                attackRoomRcl = 7;
            }
            else if (roomIntel.towers <= 3) {
                boostTier = 2;
                attackRoomRcl = 8;
            }
            else {
                boostTier = 3;
                attackRoomRcl = 8;
            }
        }
        let operationMemory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            //
            closing: false,
            //
            roomName: roomName,
            boostTier: boostTier,
            attackRoomRcl: attackRoomRcl,
            status: 1 /* Status.Rallying */,
            timeout: Game.time + OperationHitSquad.TicksUntilTimeout
        };
        Memory.operations[this.id] = operationMemory;
    }
    close() {
        if (this.status && (this.status !== 1 /* Status.Rallying */ || this.memory.creeps.length === 0))
            super.close();
    }
    get memory() {
        return super.memory;
    }
    get roomName() {
        return this.memory.roomName;
    }
    get rallyRoom() {
        return this.spawnRoomName || this.creeps.length > 0 && this.creeps[0].pos.roomName;
    }
    get status() {
        return this.memory.status;
    }
    get rallyPos() {
        if (!this._rallyPos || _.some([0, 1, 2, 3], i => Common.getRallyCreepPosition(this._rallyPos, 2, i).lookFor(LOOK_CREEPS).find(c => !this.creeps.includes(c))))
            this._rallyPos = Common.findRally(Game.rooms[this.rallyRoom], 4, new RoomPosition(25, 25, this.rallyRoom), this.creeps);
        return this._rallyPos;
    }
    get assembleRoom() {
        if (!this._assembleRoom) {
            let exitDir = Common.getExitDir(this.creeps[0].pos.roomName, this.roomName);
            if (exitDir !== undefined) {
                this._assembleRoom = this.creeps[0].pos.roomName;
                if (!this.assemblePos)
                    this._assembleRoom = undefined;
            }
        }
        return this._assembleRoom;
    }
    get assemblePos() {
        if (!this._assemblePos && this.assembleRoom && Game.rooms[this.assembleRoom]) {
            let assembleRoom = Game.rooms[this.assembleRoom];
            let distances = Common.getDirectionalDistanceCM(assembleRoom, this.creeps);
            let exits = Common.getExitTiles(this.assembleRoom, assembleRoom.getExitTo(this.roomName));
            let goals = _(exits)
                .map(e => ({
                pos: new RoomPosition(e.x === 49 ? 47 : e.x === 0 ? 1 : e.x, e.y === 49 ? 47 : e.y === 0 ? 1 : e.y, e.roomName),
                range: 0
            }))
                .filter(g => distances[g.pos.y * 50 + g.pos.x] >= 2)
                .value();
            if (goals.length > 0) {
                let pathToClosest = Pather.findPathToClosest(this.creeps[0].pos, goals);
                if (!pathToClosest.incomplete)
                    this._assemblePos = _.last(pathToClosest.path) || this.creeps[0].pos;
            }
        }
        return this._assemblePos;
    }
    onInitForTick() {
        super.onInitForTick();
        if (!this.creepBody) {
            let bodyType = this.memory.attackRoomRcl * 10 + this.memory.boostTier;
            switch (bodyType) {
                case 70:
                    this.creepBody = new CreepBody('11R12M10H10M1H');
                    break;
                case 71:
                    this.creepBody = new CreepBody('10R7M13H5M1H');
                    break;
                case 72:
                    this.creepBody = new CreepBody('10R8M14H');
                    break;
                case 73:
                    this.creepBody = new CreepBody('15R7M12H');
                    break;
                case 80:
                    this.creepBody = new CreepBody('12R15M12H10M1H');
                    break;
                case 81:
                    this.creepBody = new CreepBody('17R10M14H6M1H');
                    break;
                case 82:
                    this.creepBody = new CreepBody('22R12M14H');
                    break;
                case 83:
                    this.creepBody = new CreepBody('1T15R4T5M19H5M1H');
                    break;
            }
            this.shouldUpdateEstimatedStats = true;
        }
        if (this.memory.targetPos)
            CombatData.attackPointReservations[this.memory.targetPos] = this.id;
    }
    updateEstimatedStats() {
        if (GIntel.rooms[this.roomName] && GIntel.rooms[this.roomName].safeMode) {
            this.estimatedStats.energyPerTick = 0;
            this.estimatedStats.spawnTime = 0;
            this.estimatedStats.baseCpu = 0;
        }
        else {
            this.estimatedStats.energyPerTick = -this.creepBody.cost * 4 / CREEP_LIFE_TIME;
            this.estimatedStats.spawnTime = this.creepBody.spawnTime * 4;
            this.estimatedStats.baseCpu = 1.6;
        }
    }
    isValidSpawnRoom(myRoom) {
        const creepCost = this.creepBody.cost;
        if (myRoom.room.energyCapacityAvailable < creepCost)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME / 3 * 2)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        const creepCost = this.creepBody.cost;
        const creepsToSpawn = 4 - this.creeps.length;
        if (myRoom.getStoredResource(RES_ENERGY) < creepsToSpawn * creepCost)
            return false;
        let boosts;
        switch (this.memory.boostTier) {
            case 1:
                boosts = [RES_KO, RES_LO, RES_ZO];
                break;
            case 2:
                boosts = [RES_KHO2, RES_LHO2, RES_ZHO2];
                break;
            case 3:
                boosts = [RES_XKHO2, RES_XLHO2, RES_XZHO2];
                if (this.memory.attackRoomRcl === 8)
                    boosts.push(RES_XGHO2);
                break;
            default:
                boosts = [];
                break;
        }
        for (let boost of boosts) {
            if (GEmpire.getStoredResource(boost) < (this.creepBody[BOOST_TO_BODYPART[boost]] || 0) * creepsToSpawn * LAB_BOOST_MINERAL)
                return false;
        }
        return true;
    }
    getSpawnRequestsInternal() {
        if (this.memory.closing)
            return [];
        if (this.memory.status !== 1 /* Status.Rallying */)
            return [];
        if (GIntel.rooms[this.roomName] && GIntel.rooms[this.roomName].safeMode)
            return [];
        let boosts;
        switch (this.memory.boostTier) {
            case 1:
                boosts = [RES_KO, RES_LO, RES_ZO];
                break;
            case 2:
                boosts = [RES_KHO2, RES_LHO2, RES_ZHO2];
                break;
            case 3:
                boosts = [RES_XKHO2, RES_XLHO2, RES_XZHO2];
                if (this.memory.attackRoomRcl === 8)
                    boosts.push(RES_XGHO2);
                break;
            default:
                boosts = null;
                break;
        }
        let result = [];
        for (let i = this.creeps.length; i < 4; ++i) {
            result.push({
                id: generateRandomKey(5),
                nameBase: Config.CreepNames.Hitter,
                // using this.memory.creeps so squad that has already started spawning is prioritized (BaseOperation.hire updates memoery.creeps)
                priority: (this.memory.creeps.length === 0 ? FlagSpawnPriority : StartedSquadPriority) + 0.1 * this.memory.creeps.length,
                minEnergy: this.creepBody.cost,
                parts: this.creepBody,
                memory: {},
                boostOptions: [boosts ? [...boosts] : null],
                noRepurpose: false,
                operation: this
            });
        }
        return result;
    }
    rally() {
        let rallied = 0;
        for (let i = 0; i < this.creeps.length; ++i) {
            let creep = this.creeps[i];
            if (creep.memory.boosts) {
                this.boostCreep(creep);
                continue;
            }
            let rallyPos = Common.getRallyCreepPosition(this.rallyPos, 2, i);
            if (!creep.pos.isEqualTo(rallyPos)) {
                creep.goTo(rallyPos, 0);
                continue;
            }
            creep.giveWay();
            ++rallied;
        }
        if (this.rallyRoom)
            Game.rooms[this.rallyRoom].visual.rect(this.rallyPos.x - 0.5, this.rallyPos.y - 0.5, 2, 2, { fill: null, stroke: '#ff00ff', strokeWidth: 0.05 });
        if (rallied === 4)
            this.memory.status = 4 /* Status.Moving */;
    }
    move() {
        const travelOpts = {
            avoidSourceKeepers: false,
            ignoreRoads: true,
            ensurePath: true,
            avoidUnsafeRooms: false
        };
        if (this.assemblePos)
            Pather.sneakGoTo(this.creeps, this.assemblePos, 0, travelOpts);
        else if (this.assembleRoom)
            Pather.sneakGoTo(this.creeps, new RoomPosition(25, 25, this.assembleRoom), 23, travelOpts);
        else
            Pather.sneakGoTo(this.creeps, new RoomPosition(25, 25, this.roomName), 23, travelOpts);
        for (let creep of this.creeps)
            creep.shootAtWill(creep.room.findHostileCreeps());
        if (this.assemblePos && this.creeps[0].pos.isEqualTo(this.assemblePos))
            this.memory.status = 5 /* Status.Assembling */;
        if (this.creeps[0].pos.roomName === this.roomName && !this.creeps[0].pos.isExit()) {
            this._assembleRoom = this.roomName;
            this._assemblePos = this.creeps[0].pos;
            this.memory.status = 5 /* Status.Assembling */;
        }
    }
    assemble() {
        let rallied = 0;
        for (let i = 0; i < this.creeps.length; ++i) {
            let creep = this.creeps[i];
            let rallyPos = Common.getRallyCreepPosition(this.assemblePos, 2, i);
            if (!creep.pos.isEqualTo(rallyPos)) {
                creep.goTo(rallyPos, 0);
                continue;
            }
            creep.giveWay();
            ++rallied;
        }
        for (let creep of this.creeps)
            creep.shootAtWill(creep.room.findHostileCreeps());
        if (rallied === this.creeps.length) {
            // reset targetPos from last attack
            this.memory.targetPos = undefined;
            this.memory.status = 2 /* Status.Attacking */;
        }
    }
    findNewTarget(squadPos) {
        let visual = new RoomVisual(this.roomName);
        visual.text('\u{1F50D}', this.creeps[0].pos.x + 0.5, this.creeps[0].pos.y + 0.5, { align: 'center', opacity: 0.5 });
        let attackPoints = CombatData.getAttackPoints(this.roomName, false, false);
        if (!attackPoints)
            return undefined;
        let towerDamage = CombatData.getTowerPower(this.roomName);
        let creepDamage = CombatData.getHostileCreepInfluence(this.roomName);
        let squadHeal = _.sum(this.creeps, c => getBodypartPower(HEAL, c) * HEAL_POWER);
        const check2x2 = this.creeps.length > 2;
        let terrain = Game.map.getRoomTerrain(this.roomName);
        const CHECKED_TILE = 1;
        const APPROVED_TILE = 2;
        let checked = new Uint8Array(2500);
        let nodes = [squadPos.y * 50 + squadPos.x];
        while (nodes.length > 0) {
            let node = nodes.shift();
            let nodeX = node % 50;
            let nodeY = Math.floor(node / 50);
            for (let dir in Common.offset) {
                const o = Common.offset[dir];
                let newX = nodeX + o.x;
                let newY = nodeY + o.y;
                let index = newY * 50 + newX;
                if (newX < 0 || newX > 49 || newY < 0 || newY > 49)
                    continue;
                if (checked[index])
                    continue;
                checked[index] = CHECKED_TILE;
                if (this.room.lookForAt(LOOK_STRUCTURES, newX, newY).find(s => s.isBuildable() && (s.isObstacle() || s.structureType === STRUCTURE_RAMPART)))
                    continue;
                if ((creepDamage && creepDamage[index] || 0) + (towerDamage && towerDamage[index] || 0) >= squadHeal)
                    continue;
                if ((terrain.get(newX, newY) & TERRAIN_MASK_WALL) > 0)
                    continue;
                if (check2x2) {
                    if (newX < 49 && (creepDamage && creepDamage[index + 1] || 0) + (towerDamage && towerDamage[index + 1] || 0) >= squadHeal
                        || newY < 49 && (creepDamage && creepDamage[index + 50] || 0) + (towerDamage && towerDamage[index + 50] || 0) >= squadHeal
                        || newX < 49 && newY < 49 && (creepDamage && creepDamage[index + 51] || 0) + (towerDamage && towerDamage[index + 51] || 0) >= squadHeal) {
                        continue;
                    }
                    if (newX < 49 && this.room.lookForAt(LOOK_STRUCTURES, newX + 1, newY).find(s => s.isBuildable() && (s.isObstacle() || s.structureType === STRUCTURE_RAMPART))
                        || newY < 49 && this.room.lookForAt(LOOK_STRUCTURES, newX, newY + 1).find(s => s.isBuildable() && (s.isObstacle() || s.structureType === STRUCTURE_RAMPART))
                        || newX < 49 && newY < 49 && this.room.lookForAt(LOOK_STRUCTURES, newX + 1, newY + 1).find(s => s.isBuildable() && (s.isObstacle() || s.structureType === STRUCTURE_RAMPART))) {
                        continue;
                    }
                    if (newX < 49 && (terrain.get(newX + 1, newY) & TERRAIN_MASK_WALL) > 0
                        || newY < 49 && (terrain.get(newX, newY + 1) & TERRAIN_MASK_WALL) > 0
                        || newX < 49 && newY < 49 && (terrain.get(newX + 1, newY + 1) & TERRAIN_MASK_WALL) > 0) {
                        continue;
                    }
                }
                checked[index] = APPROVED_TILE;
                nodes.push(newY * 50 + newX);
            }
        }
        let filteredAttackPoints = attackPoints.filter(ap => {
            if (this.creeps.length > 2 && !ap.canFitQuad)
                return false;
            if (checked[ap.pos.y * 50 + ap.pos.x] !== APPROVED_TILE)
                return false;
            if (_.some(CombatData.attackPointReservations, (value, key) => value !== this.id && RoomPosition.deserialize(key).inRangeTo(ap.pos, 2)))
                return false;
            return true;
        });
        let result = undefined;
        if (filteredAttackPoints.length > 0) {
            // go for closest to kill
            filteredAttackPoints.sort((a, b) => b.ranged - a.ranged);
            let topAttackPoints = filteredAttackPoints.slice(0, 5);
            // we don't care about 3 steps difference
            let closest = _.min(topAttackPoints, ap => {
                let searchResult = Pather.findPath(squadPos, { pos: ap.pos, range: 0 });
                if (searchResult.incomplete)
                    return Infinity;
                else
                    return Math.floor(searchResult.path.length / 3);
            });
            //let searchResult = Pather.findPathToClosest(squadPos, top10.map(ap => ({ pos: ap.pos, range: 0 })).value());
            //let closest = top10.find(ap => ap.pos.isEqualTo(searchResult.path.length > 0 ? _.last(searchResult.path) : squadPos));
            let highestValue = _.max(topAttackPoints, ap => ap.ranged);
            if (highestValue.ranged > closest.ranged * 3)
                result = highestValue.pos;
            else
                result = closest.pos;
        }
        if (result)
            CombatData.attackPointReservations[result.serialize()] = this.id;
        return result;
    }
    attack() {
        let leader = this.creeps[0];
        // changing target if needed
        let attackPoints = CombatData.getAttackPoints(this.roomName, false, false);
        let towerDamageMatrix = CombatData.getTowerPower(this.roomName);
        let towerDamage = towerDamageMatrix ? _.max(this.creeps.map(c => towerDamageMatrix[c.pos.y * 50 + c.pos.x])) : 0;
        let creepDamageMatrix = CombatData.getHostileCreepInfluence(this.roomName);
        let creepDamage = this.room ? _.sum(this.creeps, c => creepDamageMatrix[c.pos.y * 50 + c.pos.x]) : 0;
        let squadHeal = _.sum(this.creeps, c => getBodypartPower(HEAL, c) * HEAL_POWER);
        let shouldReposition = (towerDamage + creepDamage > squadHeal);
        let shouldChangeTarget;
        let targetPos = this.memory.targetPos && RoomPosition.deserialize(this.memory.targetPos);
        if (targetPos) {
            let targetPosIndex = targetPos.y * 50 + targetPos.x;
            shouldChangeTarget = (towerDamageMatrix && towerDamageMatrix[targetPosIndex] || 0) + (creepDamageMatrix && creepDamageMatrix[targetPosIndex] || 0) > squadHeal;
        }
        else {
            shouldChangeTarget = true;
        }
        let noAttackPointsTargetChange = targetPos && attackPoints && !attackPoints.some(ap => ap.pos.isEqualTo(targetPos));
        let randomTargetChange = targetPos && targetPos.isEqualTo(this.creeps[0].pos) && _.random(0, 19) === 0;
        if (shouldChangeTarget || shouldReposition || noAttackPointsTargetChange) {
            let creepInRoom = this.creeps.find(c => c.pos.roomName === this.roomName);
            if (creepInRoom) {
                targetPos = this.findNewTarget(creepInRoom.pos);
                if (targetPos)
                    this.memory.targetPos = targetPos.serialize();
            }
        }
        else if (randomTargetChange) {
            let creepInRoom = this.creeps.find(c => c.pos.roomName === this.roomName);
            if (creepInRoom) {
                targetPos = this.findNewTarget(creepInRoom.pos);
                if (targetPos) // && targetPos.inRangeTo(leader.pos, 4))
                    this.memory.targetPos = targetPos.serialize();
            }
        }
        // focusing overextended creeps
        let squadDamage = _.sum(this.creeps, c => getBodypartPower(RANGED_ATTACK, c) * RANGED_ATTACK_POWER);
        let hostilesInRange = leader.pos.lookInRange(LOOK_CREEPS, 5).filter(c => !c.my && !Config.WHITELIST.has(c.owner.username));
        let overextendedHostile = hostilesInRange.find(h => {
            if (Config.WHITELIST.has(h.owner.username))
                return false;
            if (h.hits === h.hitsMax)
                return false;
            if (h.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_RAMPART))
                return false;
            if (h.body.find(bp => bp.type === TOUGH && bp.boost && bp.hits > 0))
                return false;
            if (getBodypartPower(HEAL, h) * HEAL_POWER >= squadDamage)
                return false;
            if (Pather.findPath(leader.pos, { pos: h.pos, range: 1 }, { maxCost: 6 }).incomplete)
                return false;
            return true;
        });
        //
        if (targetPos === undefined) {
            let goToRoomOpts = {
                squadMembers: this.creeps.slice(1),
                avoidNarrowPaths: this.creeps.length > 2,
                avoidDamage: squadHeal
            };
            if (leader.pos.roomName === this.roomName)
                this.retreat();
            else
                CombatPather.goTo(leader, new RoomPosition(25, 25, this.roomName), 22, goToRoomOpts);
        }
        else {
            let opts = {
                dontIgnoreCreeps: true,
                squadMembers: this.creeps.slice(1),
                avoidNarrowPaths: this.creeps.length > 2,
                maxRooms: 6,
                avoidDamage: squadHeal,
                avoidDamageMargin: 1,
                debug: true
            };
            let hits = _.sum(this.creeps, c => c.hits);
            let lastHits = this.memory.lastHits || 0;
            if (this.creeps.some(c => c.pos.isExit()) || hits >= lastHits) {
                if (overextendedHostile)
                    CombatPather.goTo(leader, overextendedHostile.pos, 0, opts);
                else
                    CombatPather.goTo(leader, targetPos, 0, opts);
            }
            if (targetPos) {
                let visual = Common.getRoomVisual(targetPos.roomName);
                visual.multiRoomLine(leader.pos, targetPos, { color: '#ff0000', lineStyle: 'dotted', opacity: 0.75, width: 0.1 });
                visual.text('❌', targetPos, {});
            }
            this.memory.lastHits = hits;
        }
        //
        let targets = {};
        for (let creep of this.creeps) {
            if (!targets[creep.pos.roomName]) {
                const roomIntel = GIntel.rooms[creep.pos.roomName];
                let hostiles = creep.room.findHostileCreeps().filter(h => !h.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_RAMPART)) || [];
                let structures = !roomIntel.isFriendly && creep.room.find(FIND_STRUCTURES, { filter: s => s.isBuildable() }) || [];
                targets[creep.pos.roomName] = [...hostiles, ...structures];
            }
            let exposedHostilesInRange = creep.room.findHostileCreeps().filter(h => h.pos.inRangeTo(creep, 3) && !h.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_RAMPART));
            if (exposedHostilesInRange.length > 0)
                creep.shootAtWill(targets[creep.pos.roomName], _.min(exposedHostilesInRange, h => h.hits));
            else
                creep.shootAtWill(targets[creep.pos.roomName]);
        }
    }
    retreat() {
        let leader = this.creeps[0];
        let squadHeal = _.sum(this.creeps, c => getBodypartPower(HEAL, c) * HEAL_POWER);
        let retreatOpts = {
            dontIgnoreCreeps: true,
            squadMembers: this.creeps.slice(1),
            avoidNarrowPaths: this.creeps.length > 2,
            avoidDamage: squadHeal,
            avoidDamageMargin: 1,
            debug: true
        };
        let fleeRoom;
        if (leader.pos.roomName === this.roomName) {
            let closestExit;
            if (leader.pos.isExit())
                closestExit = leader.pos;
            else {
                let pathToClosestExit = Pather.findPathToClosest(leader.pos, Common.getExitTiles(leader.pos.roomName).map(e => ({ pos: e, range: 0 })), {
                    dontIgnoreCreeps: false
                });
                closestExit = _.last(pathToClosestExit.path);
            }
            let exitDir;
            if (closestExit.x === 0)
                exitDir = LEFT;
            else if (closestExit.x === 49)
                exitDir = RIGHT;
            else if (closestExit.y === 0)
                exitDir = TOP;
            else
                exitDir = BOTTOM;
            fleeRoom = Common.getNextRoom(this.roomName, exitDir);
        }
        else
            fleeRoom = leader.pos.roomName;
        let hits = _.sum(this.creeps, c => c.hits);
        let lastHits = this.memory.lastHits || 0;
        if (hits <= lastHits || leader.pos.lookInRange(LOOK_CREEPS, 5).find(h => !h.my))
            CombatPather.goTo(leader, new RoomPosition(25, 25, fleeRoom), 22, retreatOpts);
        this.memory.lastHits = hits;
        let hostiles = leader.room.findHostileCreeps().filter(h => !h.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_RAMPART));
        let structures = leader.room.intel.isFriendly
            ? []
            : leader.room.find(FIND_STRUCTURES, { filter: s => s.isBuildable() });
        let allTargets = [...hostiles, ...structures];
        for (let creep of this.creeps) {
            let unsafeHostileInRange = hostiles.find(h => h.pos.inRangeTo(creep, 3) && !h.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_RAMPART));
            creep.shootAtWill(allTargets, unsafeHostileInRange);
        }
    }
    heal() {
        if (this.creeps.length === 0)
            return;
        if (this.creeps.every(c => c.hits === c.hitsMax && GIntel.rooms[c.pos.roomName].isSafe))
            return;
        let potentialDamage = this.creeps.map(c => {
            const roomIntel = GIntel.rooms[c.pos.roomName];
            const damageWeight = 2;
            const potentialDamageWeight = 1;
            let towerDamageMatrix = !roomIntel.isFriendly && CombatData.getTowerPower(c.pos.roomName);
            let creepDamageMatrix = CombatData.getHostileCreepDamage(c.pos.roomName);
            let hitsMax = c.hitsMax + _.sum(c.body, bp => bp.type === TOUGH ? 100 / getBodypartBoostMod(bp) - 100 : 0);
            let hits = c.hits + _.sum(c.body, bp => bp.type === TOUGH ? bp.hits / getBodypartBoostMod(bp) - bp.hits : 0);
            let result = damageWeight * (hitsMax - hits);
            result += potentialDamageWeight * (towerDamageMatrix && towerDamageMatrix[c.pos.y * 50 + c.pos.x] || 0);
            result += potentialDamageWeight * (creepDamageMatrix && creepDamageMatrix[c.pos.y * 50 + c.pos.x] || 0);
            return {
                creep: c,
                damage: result
            };
        });
        for (let creep of this.creeps) {
            let mostDamaged = _(potentialDamage)
                .filter(v => v.creep.pos.isNearTo(creep.pos))
                .max(v => v.damage);
            creep.heal(mostDamaged.creep);
            mostDamaged.damage -= getBodypartPower(HEAL, creep) * HEAL_POWER;
        }
    }
    onRun() {
        if (Game.time > this.memory.timeout && this.creeps.length === 0) {
            this.abort();
            return;
        }
        if (this.creeps.length === 0)
            this.memory.status = 1 /* Status.Rallying */;
        //
        if (this.memory.lastCreepCount && this.memory.lastCreepCount > this.creeps.length)
            this.memory.closing = true;
        this.memory.lastCreepCount = this.creeps.length;
        // safety measure
        if (this.memory.forceRetreat)
            this.memory.status = 3 /* Status.Retreating */;
        //
        if (this.memory.status === 2 /* Status.Attacking */ && this.creeps.some(c => !c.pos.isExit() && c.hits < c.hitsMax - 600 || c.hits < c.hitsMax - 1200))
            this.memory.status = 3 /* Status.Retreating */;
        if (this.memory.status === 2 /* Status.Attacking */ && GIntel.rooms[this.roomName] && GIntel.rooms[this.roomName].safeMode)
            this.memory.status = 3 /* Status.Retreating */;
        if (this.memory.status === 3 /* Status.Retreating */ && this.creeps.every(c => c.hits === c.hitsMax))
            this.memory.status = 2 /* Status.Attacking */;
        if (this.memory.status === 3 /* Status.Retreating */)
            this.retreat();
        else if (this.memory.status === 1 /* Status.Rallying */)
            this.rally();
        else if (this.memory.status === 4 /* Status.Moving */)
            this.move();
        else if (this.memory.status === 5 /* Status.Assembling */)
            this.assemble();
        else if (this.memory.status === 2 /* Status.Attacking */)
            this.attack();
        this.heal();
    }
}
OperationHitSquad.OperationType = 'HitSquad';
OperationHitSquad.TicksUntilTimeout = 1500;
__decorate([
    profile()
], OperationHitSquad.prototype, "onInitForTick", null);
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationHitSquad.prototype, "getSpawnRequestsInternal", null);
__decorate([
    profile()
], OperationHitSquad.prototype, "findNewTarget", null);
__decorate([
    profile()
], OperationHitSquad.prototype, "attack", null);
__decorate([
    profile()
], OperationHitSquad.prototype, "retreat", null);
__decorate([
    profile()
], OperationHitSquad.prototype, "onRun", null);
class FlagOperationHitSquad extends OperationHitSquad {
    constructor(empire, id) {
        super(empire, id);
    }
    init(roomName) {
        if (Memory.flags[this.id])
            return;
        let operationMemory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            //
            closing: false,
            //
            roomName: roomName,
            boostTier: Math.floor((this.flag.color - 1) / 2) % 4,
            attackRoomRcl: ((this.flag.color - 1) % 2 === 0) ? 7 : 8,
            status: 1 /* Status.Rallying */,
            timeout: Game.time + OperationHitSquad.TicksUntilTimeout
        };
        Memory.flags[this.id] = operationMemory;
    }
    get memory() {
        return Memory.flags[this.id];
    }
    get roomName() {
        return this.flag.pos.roomName;
    }
    get readyToDelete() {
        return !this.flag || super.readyToDelete;
    }
    get flag() {
        return Game.flags[this.id];
    }
    deleteMemory() {
        delete Memory.flags[this.id];
    }
    onInitForTick() {
        super.onInitForTick();
        this.memory.roomName = this.flag.pos.roomName;
    }
}

class StrategySiege extends BaseStrategy {
    constructor(empire) {
        super(empire);
        if (!this.memory) {
            let strategyMemory = {
                lastAttackEnd: -1500
            };
            Memory.strategies['Siege'] = strategyMemory;
        }
        this.closestAttackRoom = {};
    }
    get memory() {
        return Memory.strategies['Siege'];
    }
    isSiegable(roomName, attackRooms) {
        const roomIntel = GIntel.rooms[roomName];
        if (roomIntel.safeMode && roomIntel.safeMode > Game.time)
            return false;
        if (!roomIntel.owner)
            return false;
        if (roomIntel.isMy)
            return false;
        if (roomIntel.isFriendly)
            return false;
        if (roomIntel.spawns === 0 && roomIntel.towers === 0)
            return false;
        if (!Memory.toggles.autoBoostedAttack && roomIntel.towers > 1)
            return false;
        if (!Treaties.canBeAttacked(roomName))
            return false;
        if (!Common.findRoomsInRange(roomName, 9).find(r => !!attackRooms.find(ar => ar.roomName === r)))
            return false;
        return true;
    }
    findRandomTarget(attackRooms) {
        let potentialTargets = [];
        for (let roomName in GIntel.rooms) {
            if (this.isSiegable(roomName, attackRooms))
                potentialTargets.push(roomName);
        }
        // nothing to attack
        if (potentialTargets.length === 0)
            return undefined;
        // 50% that weakest room will be picked
        else if (_.random(0, 1) === 0) {
            return _.min(potentialTargets, pt => GIntel.rooms[pt].towers * 100000 + GIntel.rooms[pt].energyCapacityAvailable);
        }
        // 50% that complete random room will be picked
        else {
            return potentialTargets[_.random(0, potentialTargets.length - 1)];
        }
    }
    createGlobalOperations(activeOperations) {
        if (Game.cpu.bucket < 5000)
            return null;
        for (let attackedRoomName in this.closestAttackRoom) {
            if (this.closestAttackRoom[attackedRoomName].timeout < Game.time)
                delete this.closestAttackRoom[attackedRoomName];
        }
        let siegeFlags = [];
        for (let flagName in Game.flags) {
            let flag = Game.flags[flagName];
            if (flag.secondaryColor === COLOR_RED)
                continue;
            if (!flag.name.startsWith('Siege'))
                continue;
            siegeFlags.push(flag);
        }
        if (siegeFlags.length === 0 && (!Memory.toggles || !Memory.toggles.autoattack))
            return null;
        let quadCount = 2;
        if (siegeFlags.length > 0)
            quadCount = siegeFlags[0].color;
        let hitsquadOperations = _.filter(activeOperations, go => go instanceof OperationHitSquad);
        if (hitsquadOperations.length >= quadCount) {
            if (hitsquadOperations.some(hs => hs.status === 2 /* Status.Attacking */))
                this.memory.lastAttackEnd = Game.time;
            return null;
        }
        // break between attacks to reset defenders
        if (Game.time - this.memory.lastAttackEnd < 2000)
            return null;
        let myRooms = this.empire.myRooms;
        let attackRooms = myRooms.filter(mr => mr.room.find(FIND_MY_SPAWNS).length > 0 && mr.room.energyCapacityAvailable >= 5600 && mr.room.storage && mr.room.storage.store[RESOURCE_ENERGY] > 4 * 5600);
        if (attackRooms.length === 0)
            return null;
        let targetRoomName = undefined;
        // pick siege flag room
        if (!targetRoomName) {
            for (let siegeFlag of siegeFlags)
                if (this.isSiegable(siegeFlag.pos.roomName, attackRooms)) {
                    targetRoomName = siegeFlag.pos.roomName;
                    break;
                }
        }
        // pick room already being attacked
        if (!targetRoomName && hitsquadOperations.length > 0 && this.isSiegable(hitsquadOperations[0].roomName, attackRooms))
            targetRoomName = hitsquadOperations[0].roomName;
        // pick random room
        if (!targetRoomName && Memory.toggles.autoattack)
            targetRoomName = this.findRandomTarget(attackRooms);
        // no rooms to attack
        if (!targetRoomName)
            return null;
        let closestAttackRoom = this.closestAttackRoom[targetRoomName] && this.closestAttackRoom[targetRoomName].myRoom;
        if (!closestAttackRoom) {
            closestAttackRoom = _.min(attackRooms, ar => Game.map.getRoomLinearDistance(ar.roomName, targetRoomName));
            let searchResult = Pather.findPath(closestAttackRoom.layout.roomPlan.pos, { pos: new RoomPosition(25, 25, targetRoomName), range: 23 }, { ensurePath: true, ignoreRoads: true });
            if (searchResult.incomplete)
                return null;
            let rallyPos = undefined;
            let path = searchResult.path;
            for (let i = path.length - 1; i > 0; --i) {
                if (path[i].roomName === targetRoomName)
                    continue;
                if (path[i].x >= 48 || path[i].y >= 48)
                    continue;
                let terrain = Game.map.getRoomTerrain(path[i].roomName);
                if (terrain.get(path[i].x, path[i].y) & TERRAIN_MASK_WALL)
                    continue;
                if (terrain.get(path[i].x + 1, path[i].y) & TERRAIN_MASK_WALL)
                    continue;
                if (terrain.get(path[i].x, path[i].y + 1) & TERRAIN_MASK_WALL)
                    continue;
                if (terrain.get(path[i].x + 1, path[i].y + 1) & TERRAIN_MASK_WALL)
                    continue;
                rallyPos = path[i];
                break;
            }
            if (!rallyPos)
                return null;
            this.closestAttackRoom[targetRoomName] = {
                myRoom: closestAttackRoom,
                timeout: Game.time + 100
            };
        }
        let hitSquad = new OperationHitSquad(this.empire, 'HitSquad_Siege_' + targetRoomName + '_' + Game.time);
        hitSquad.init(targetRoomName);
        return [hitSquad];
    }
}
__decorate([
    check
], StrategySiege.prototype, "createGlobalOperations", null);

class OperationDeposit extends BaseGlobalOperation {
    constructor(empire, id) {
        super(empire, id);
    }
    init(roomName) {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            closing: false,
            roomName: roomName
        };
        Memory.operations[this.id] = memory;
    }
    close() {
        if (this.creeps.length > 0)
            super.close();
    }
    get memory() {
        return super.memory;
    }
    get roomName() {
        return this.memory.roomName;
    }
    updateEstimatedStats() {
        this.estimatedStats.energyPerTick = -OperationDeposit.harvesterBody.cost / CREEP_LIFE_TIME;
        this.estimatedStats.spawnTime = OperationDeposit.harvesterBody.spawnTime;
        this.estimatedStats.baseCpu = 0.2;
    }
    getGeneratedValue() {
        let estimatedStats = this.getEstimatedStats();
        let deposit = GIntel.rooms[this.roomName].deposits[0];
        let generatedResourcePerTick = OperationDeposit.harvesterBody[CARRY] * CARRY_CAPACITY / CREEP_LIFE_TIME;
        return generatedResourcePerTick * (this.empire.resourceValue[deposit && deposit.type] || 0) + estimatedStats.energyPerTick * (this.empire.resourceValue[RESOURCE_ENERGY] || 0);
    }
    isValidSpawnRoom(myRoom) {
        if (myRoom.room.energyCapacityAvailable < OperationDeposit.harvesterBody.cost)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME / 4)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        return true;
    }
    getSpawnRequestsInternal() {
        if (this.memory.closing)
            return [];
        if (this.creeps.length > 0)
            return [];
        let result = [];
        let nameBase = Config.CreepNames.DepositMiner;
        result.push({
            id: generateRandomKey(5),
            nameBase: nameBase,
            priority: FlagSpawnPriority,
            minEnergy: 200,
            parts: OperationDeposit.harvesterBody,
            memory: {
                state: 0 /* DepositHarvesterState.MOVING */
            },
            boostOptions: [null],
            noRepurpose: false,
            operation: this
        });
        return result;
    }
    HarvesterFunc(creep) {
        let creepMemory = creep.memory;
        if (creepMemory.state === 0 /* DepositHarvesterState.MOVING */) {
            if (creep.pos.roomName !== this.roomName) {
                creep.goToRoom(this.roomName);
                return;
            }
            let deposit = creep.room.find(FIND_DEPOSITS)[0];
            if (!deposit) {
                creepMemory.state = 2 /* DepositHarvesterState.RETURNING */;
                return;
            }
            if (!creep.pos.isNearTo(deposit.pos)) {
                creep.goTo(deposit.pos, 1, { dontIgnoreCreeps: true });
                return;
            }
            creepMemory.state = 1 /* DepositHarvesterState.MINING */;
        }
        if (creepMemory.state === 1 /* DepositHarvesterState.MINING */) {
            let deposit = creep.room.find(FIND_DEPOSITS)[0];
            if (creep.store.getFreeCapacity() === 0) {
                creepMemory.state = 2 /* DepositHarvesterState.RETURNING */;
            }
            else if (!deposit.cooldown) {
                creep.harvest(deposit);
            }
        }
        if (creepMemory.state === 2 /* DepositHarvesterState.RETURNING */) {
            if (creep.store.getUsedCapacity() > 0) {
                if (!creep.pos.isNearTo(this.spawnRoom.storage.pos))
                    creep.goTo(this.spawnRoom.storage.pos, 1);
                else {
                    const resourceType = _.findKey(creep.store);
                    creep.transfer(this.spawnRoom.storage, resourceType);
                }
            }
            else {
                this.dismissCreep(creep, true, true);
            }
        }
    }
    onRun() {
        if (this.creeps.length > 0)
            this.close();
        for (let creep of this.creeps)
            this.HarvesterFunc(creep);
    }
}
OperationDeposit.OperationType = 'Deposit';
OperationDeposit.harvesterBody = new CreepBody('15W10[CM]15M');
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationDeposit.prototype, "getSpawnRequestsInternal", null);
__decorate([
    check,
    profile()
], OperationDeposit.prototype, "onRun", null);

//import { Pather } from '../pather';
var PowerHarvestStatus;
(function (PowerHarvestStatus) {
    PowerHarvestStatus[PowerHarvestStatus["DRILLING"] = 0] = "DRILLING";
    PowerHarvestStatus[PowerHarvestStatus["SPAWNING_HAULERS"] = 1] = "SPAWNING_HAULERS";
    PowerHarvestStatus[PowerHarvestStatus["WAITING_FOR_HAULERS"] = 2] = "WAITING_FOR_HAULERS";
    PowerHarvestStatus[PowerHarvestStatus["TRANSPORTING"] = 3] = "TRANSPORTING";
})(PowerHarvestStatus || (PowerHarvestStatus = {}));
class OperationPowerHarvest extends BaseGlobalOperation {
    constructor(empire, id) {
        super(empire, id);
        if (this.memory) {
            this.powerBankPos = RoomPosition.deserialize(this.memory.powerBankPos);
        }
    }
    init(roomName) {
        const powerBankInfo = GIntel.rooms[roomName].powerBank;
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            closing: false,
            roomName: roomName,
            status: PowerHarvestStatus.DRILLING,
            haulersNeeded: Math.ceil(powerBankInfo.power / CARRY_CAPACITY / OperationPowerHarvest.haulerBody[CARRY]),
            powerBankPos: powerBankInfo.pos.serialize(),
            distanceToPowerBank: null,
            drills: [],
            drillHeads: [],
            drillTails: []
        };
        this.powerBankPos = powerBankInfo.pos;
        this.drillingSpots = 0;
        const terrain = Game.map.getRoomTerrain(roomName);
        for (let dir = TOP; dir <= TOP_LEFT; ++dir) {
            if ((terrain.get(this.powerBankPos.x + Common.offsetX[dir], this.powerBankPos.y + Common.offsetY[dir]) & TERRAIN_MASK_WALL) === 0)
                ++this.drillingSpots;
        }
        Memory.operations[this.id] = memory;
    }
    close() {
        if (this.memory && (this.memory.status === PowerHarvestStatus.TRANSPORTING || !GIntel.rooms[this.roomName].powerBank))
            super.close();
    }
    get memory() {
        return super.memory;
    }
    onInitForTick() {
        super.onInitForTick();
        this.memory.drillHeads = this.memory.drillHeads.filter(creepName => this.memory.creeps.includes(creepName));
        this.memory.drillTails = this.memory.drillTails.filter(creepName => this.memory.creeps.includes(creepName));
        for (let drill of this.memory.drills) {
            if (!this.memory.creeps.includes(drill.head))
                drill.head = null;
            if (!this.memory.creeps.includes(drill.tail))
                drill.tail = null;
        }
        this.memory.drills = this.memory.drills.filter(d => d.head || d.tail);
    }
    get roomName() {
        return this.memory.roomName;
    }
    onAssignSpawnRoom() {
        // TODO - temp
        if (!this.memory.distanceToPowerBank && !this.powerBankPos) {
            this.memory.distanceToPowerBank = 1;
            return;
        }
        if (!this.memory.distanceToPowerBank) {
            const startPos = this.spawnRoom.storage.pos;
            const pathToPowerBank = Pather.findPath(startPos, { pos: this.powerBankPos, range: 1 }, { ensurePath: true });
            this.memory.distanceToPowerBank = pathToPowerBank.path.length;
        }
    }
    onSpawn(requestId, creepName) {
        super.onSpawn(requestId, creepName);
        if (this.drillHeadRequestIds.includes(requestId)) {
            _.pull(this.drillHeadRequestIds, requestId);
            this.memory.drillHeads.push(creepName);
        }
        else if (this.drillTailRequestIds.includes(requestId)) {
            _.pull(this.drillTailRequestIds, requestId);
            this.memory.drillTails.push(creepName);
        }
        if (this.memory.drillHeads.length > 0 && this.memory.drillTails.length > 0) {
            this.memory.drills.push({
                head: this.memory.drillHeads.pop(),
                tail: this.memory.drillTails.pop()
            });
        }
    }
    onCreepDeath(creepName) {
        for (let drill of this.memory.drills) {
            if (drill.head === creepName) {
                if (Game.creeps[drill.tail])
                    Game.creeps[drill.tail].suicide();
                _.pull(this.memory.drills, drill);
                return;
            }
            if (drill.tail === creepName) {
                if (Game.creeps[drill.head])
                    Game.creeps[drill.head].suicide();
                _.pull(this.memory.drills, drill);
                return;
            }
        }
    }
    get powerBank() {
        const powerBankInfo = GIntel.rooms[this.roomName].powerBank;
        if (powerBankInfo)
            return Game.getObjectById(powerBankInfo.id);
        else
            return undefined;
    }
    updateEstimatedStats() {
        this.estimatedStats.energyPerTick = -(OperationPowerHarvest.drillHeadBody.cost + OperationPowerHarvest.drillTailBody.cost) / CREEP_LIFE_TIME;
        this.estimatedStats.spawnTime = OperationPowerHarvest.drillHeadBody.spawnTime + OperationPowerHarvest.drillTailBody.spawnTime;
        this.estimatedStats.baseCpu = 0.4;
    }
    getGeneratedValue() {
        let estimatedStats = this.getEstimatedStats();
        let powerBankInfo = GIntel.rooms[this.roomName].powerBank;
        let generatedResourcePerTick = powerBankInfo.power / CREEP_LIFE_TIME;
        return generatedResourcePerTick * (this.empire.resourceValue[RESOURCE_POWER] || 0) + estimatedStats.energyPerTick * (this.empire.resourceValue[RESOURCE_ENERGY] || 0);
    }
    isValidSpawnRoom(myRoom) {
        if (myRoom.room.energyCapacityAvailable < OperationPowerHarvest.drillHeadBody.cost)
            return false;
        if (myRoom.room.energyCapacityAvailable < OperationPowerHarvest.drillTailBody.cost)
            return false;
        if (!myRoom.layout.terminal)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME / 4)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        return myRoom.getEnergyAmount() >= 50000;
    }
    getDrillSpawnRequests() {
        let requests = [];
        //const ticksToDecay = GIntel.rooms[this.roomName].powerBank.decay - Game.time;
        const attacksToOpen = GIntel.rooms[this.roomName].powerBank.hits / OperationPowerHarvest.drillHeadBody.attackPower;
        const drillsNeeded = Math.min(this.drillingSpots, Math.ceil(attacksToOpen / Math.min(CREEP_LIFE_TIME - this.memory.distanceToPowerBank))) - this.memory.drills.length;
        this.drillHeadRequestIds = [];
        this.drillTailRequestIds = [];
        let drillHeadsNeeded = drillsNeeded - this.memory.drillHeads.length;
        let drillTailsNeeded = drillsNeeded - this.memory.drillTails.length;
        while (drillHeadsNeeded > 0 || drillTailsNeeded > 0) {
            if (drillHeadsNeeded >= drillTailsNeeded) {
                const requestId = generateRandomKey(5);
                this.drillHeadRequestIds.push(requestId);
                requests.push({
                    id: requestId,
                    nameBase: Config.CreepNames.DrillHead,
                    priority: FlagSpawnPriority,
                    minEnergy: OperationPowerHarvest.drillHeadBody.cost,
                    parts: OperationPowerHarvest.drillHeadBody,
                    memory: {
                        role: 2 /* CreepRole.Drill */
                    },
                    boostOptions: [null],
                    noRepurpose: true,
                    operation: this
                });
                --drillHeadsNeeded;
            }
            else {
                const requestId = generateRandomKey(5);
                this.drillTailRequestIds.push(requestId);
                requests.push({
                    id: requestId,
                    nameBase: Config.CreepNames.DrillTail,
                    priority: FlagSpawnPriority,
                    minEnergy: OperationPowerHarvest.drillTailBody.cost,
                    parts: OperationPowerHarvest.drillTailBody,
                    memory: {
                        role: 3 /* CreepRole.Healer */
                    },
                    boostOptions: [null],
                    noRepurpose: true,
                    operation: this
                });
                --drillTailsNeeded;
            }
        }
        return requests;
    }
    getSpawnRequestsInternal() {
        if (this.memory.closing)
            return [];
        let result = [];
        result.push(...this.getDrillSpawnRequests());
        if (this.memory.status === PowerHarvestStatus.SPAWNING_HAULERS) {
            const haulerCount = _.sum(this.creeps, c => c.memory.role === 1 /* CreepRole.Hauler */ ? 1 : 0);
            const haulersNeeded = this.memory.haulersNeeded - haulerCount;
            for (let i = 0; i < haulersNeeded; ++i) {
                result.push({
                    id: generateRandomKey(5),
                    nameBase: Config.CreepNames.Hauler,
                    priority: FlagSpawnPriority,
                    minEnergy: OperationPowerHarvest.haulerBody.cost,
                    parts: OperationPowerHarvest.haulerBody,
                    memory: {
                        role: 1 /* CreepRole.Hauler */,
                        state: 0 /* HaulerState.Collecting */
                    },
                    boostOptions: [null],
                    noRepurpose: true,
                    operation: this
                });
            }
        }
        return result;
    }
    DrillHeadFunc(creep, drillTail) {
        const powerBankInfo = GIntel.rooms[this.roomName].powerBank;
        if (this.memory.closing && !powerBankInfo) {
            this.dismissCreep(creep, true, false);
            return;
        }
        if (!creep.pos.isExit() && (!drillTail || !creep.pos.isNearTo(drillTail))) {
            creep.giveWay(true);
            return;
        }
        const opts = {
            ensurePath: true
        };
        if (!creep.pos.isNearTo(powerBankInfo.pos)) {
            creep.goTo(powerBankInfo.pos, 1, opts);
            return;
        }
        let powerBank = this.powerBank;
        if (!this.powerBank) {
            this.dismissCreep(creep, true, false);
            return;
        }
        const canBeBrokenInOneTick = (powerBank.hits <= creep.getActiveBodyparts(ATTACK) * ATTACK_POWER);
        if (!canBeBrokenInOneTick || this.memory.status === PowerHarvestStatus.TRANSPORTING || powerBank.ticksToDecay < 3 || creep.ticksToLive < 3) {
            creep.attack(powerBank);
            creep.giveWay({ pos: powerBank.pos, range: 1 });
        }
    }
    DrillTailFunc(creep, drillHead) {
        const powerBankInfo = GIntel.rooms[this.roomName].powerBank;
        if (this.memory.closing && !powerBankInfo) {
            this.dismissCreep(creep, true, false);
        }
        else if (!drillHead) {
            creep.suicide();
        }
        else if (!creep.pos.isNearTo(drillHead.pos)) {
            if (drillHead.spawning)
                creep.giveWay(true);
            else
                creep.goTo(drillHead.pos, 0);
        }
        else {
            if (!this.powerBank || !drillHead.pos.isNearTo(this.powerBank))
                creep.move(creep.pos.getDirectionTo(drillHead.pos));
            else {
                creep.giveWay({ pos: drillHead.pos, range: 1 });
            }
            if (drillHead.hits < drillHead.hitsMax)
                creep.heal(drillHead);
        }
    }
    HaulerFunc(creep) {
        if (this.memory.status !== PowerHarvestStatus.TRANSPORTING || this.room && this.powerBank) {
            if (creep.pos.inRangeTo(this.powerBankPos, OperationPowerHarvest.haulerWaitingRange))
                creep.giveWay({ pos: this.powerBankPos, range: OperationPowerHarvest.haulerWaitingRange });
            else
                creep.goTo(this.powerBankPos, OperationPowerHarvest.haulerWaitingRange, { offroad: true, ensurePath: true });
        }
        else {
            const creepMemory = creep.memory;
            if (creepMemory.state === 0 /* HaulerState.Collecting */ && (creep.store.getCapacity() === 0 || creep.store.getUsedCapacity() > 0))
                creepMemory.state = 1 /* HaulerState.Returning */;
            if (creepMemory.state === 0 /* HaulerState.Collecting */) {
                if (creep.pos.isNearTo(this.powerBankPos)) {
                    const ruin = this.powerBankPos.lookFor(LOOK_RUINS).find(r => r.store.getUsedCapacity() > 0);
                    const resource = this.powerBankPos.lookFor(LOOK_RESOURCES).find(r => r.amount > 0);
                    if (this.powerBank)
                        creep.giveWay(true);
                    else if (ruin)
                        creep.withdraw(ruin, _.findKey(ruin.store));
                    else if (resource)
                        creep.pickup(resource);
                    else
                        creepMemory.state = 1 /* HaulerState.Returning */;
                }
                else {
                    creep.goTo(this.powerBankPos, 1, { offroad: true, ensurePath: true });
                }
            }
            else {
                if (creep.store.getUsedCapacity() > 0) {
                    const dropOff = this.spawnRoom.storage || this.spawnRoom.terminal;
                    if (!dropOff)
                        creep.drop(_.findKey(creep.store));
                    else if (creep.pos.isNearTo(dropOff))
                        creep.transfer(dropOff, _.findKey(creep.store));
                    else
                        creep.goTo(dropOff.pos, 1, { ensurePath: true });
                }
                else {
                    this.dismissCreep(creep, true, true);
                }
            }
        }
    }
    updateStatus() {
        if (this.memory.status === PowerHarvestStatus.DRILLING) {
            if (!this.powerBank)
                return;
            let estimatedDrillAmount = 0;
            for (let c of this.creeps) {
                if (c.memory.role !== 2 /* CreepRole.Drill */)
                    continue;
                if (!c.pos.isNearTo(this.powerBankPos))
                    continue;
                estimatedDrillAmount += c.getActiveBodyparts(ATTACK) * ATTACK_POWER * Math.min(CREEP_LIFE_TIME / 2, c.ticksToLive);
            }
            if (estimatedDrillAmount > this.powerBank.hits)
                this.memory.status = PowerHarvestStatus.SPAWNING_HAULERS;
        }
        else if (this.memory.status === PowerHarvestStatus.SPAWNING_HAULERS) {
            const haulerCount = _.sum(this.creeps, c => c.memory.role === 1 /* CreepRole.Hauler */ ? 1 : 0);
            if (haulerCount === this.memory.haulersNeeded)
                this.memory.status = PowerHarvestStatus.WAITING_FOR_HAULERS;
        }
        else if (this.memory.status === PowerHarvestStatus.WAITING_FOR_HAULERS) {
            let allHaulersInRange = true;
            for (let c of this.creeps) {
                if (c.memory.role !== 1 /* CreepRole.Hauler */)
                    continue;
                if (c.pos.inRangeTo(this.powerBankPos, OperationPowerHarvest.haulerWaitingRange))
                    continue;
                allHaulersInRange = false;
                break;
            }
            if (this.room && !this.powerBank || allHaulersInRange)
                this.memory.status = PowerHarvestStatus.TRANSPORTING;
        }
    }
    onRun() {
        if (!GIntel.rooms[this.roomName].powerBank) {
            this.close();
        }
        if (this.room && this.room.getEventLog().find(e => e.event === EVENT_ATTACK && !!this.creeps.find(c => c.id === e.data.targetId))) {
            this.close();
        }
        this.updateStatus();
        for (let drill of this.memory.drills) {
            if (Game.creeps[drill.head])
                this.DrillHeadFunc(Game.creeps[drill.head], Game.creeps[drill.tail]);
            if (Game.creeps[drill.tail])
                this.DrillTailFunc(Game.creeps[drill.tail], Game.creeps[drill.head]);
        }
        for (let creepName of this.memory.drillHeads)
            Game.creeps[creepName].giveWay();
        for (let creepName of this.memory.drillTails)
            Game.creeps[creepName].giveWay();
        for (let creep of this.creeps) {
            if (creep.spawning)
                continue;
            switch (creep.memory.role) {
                case 1 /* CreepRole.Hauler */:
                    this.HaulerFunc(creep);
                    break;
            }
        }
    }
}
OperationPowerHarvest.OperationType = 'PowerHarvest';
OperationPowerHarvest.drillHeadBody = new CreepBody('10M20A10M');
OperationPowerHarvest.drillTailBody = new CreepBody('25M25H');
OperationPowerHarvest.haulerBody = new CreepBody('25[CM]');
OperationPowerHarvest.haulerWaitingRange = 5;
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationPowerHarvest.prototype, "getSpawnRequestsInternal", null);
__decorate([
    check,
    profile()
], OperationPowerHarvest.prototype, "onRun", null);

class StrategyHighwayHarvesting extends BaseStrategy {
    constructor(empire) {
        super(empire);
        if (!this.memory) {
            let strategyMemory = {};
            Memory.strategies['HighwayHarvesting'] = strategyMemory;
        }
        this.lastUpdate = 0;
    }
    get memory() {
        return Memory.strategies['HighwayHarvesting'];
    }
    createGlobalOperations(activeOperations) {
        if (Game.time - this.lastUpdate < 10)
            return null;
        let result = [];
        let myRooms = this.empire.myRooms;
        for (let roomName in GIntel.rooms) {
            let roomIntel = GIntel.rooms[roomName];
            if (roomIntel.usedByAlly)
                continue;
            if (!roomIntel.isSafe)
                continue;
            if (roomIntel.deposits.length > 0) {
                const deposit = roomIntel.deposits[0];
                if (deposit.cooldown > 30)
                    continue;
                if (deposit.decay < 1000)
                    continue;
                if (_.some(activeOperations, go => go instanceof OperationDeposit && go.roomName === roomName))
                    continue;
                // TODO - better distance measurement
                if (myRooms.every(mr => Game.map.getRoomLinearDistance(mr.roomName, roomName) > 4))
                    continue;
                let operation = new OperationDeposit(this.empire, 'Deposit_' + roomName + '_' + Game.time);
                operation.init(roomName);
                result.push(operation);
            }
            if (Memory.toggles.harvestPower) {
                const powerBank = roomIntel.powerBank;
                if (powerBank) {
                    if (powerBank.decay < 3500)
                        continue;
                    if (_.some(activeOperations, go => go instanceof OperationPowerHarvest && go.roomName === roomName))
                        continue;
                    // TODO - better distance measurement
                    if (myRooms.every(mr => Game.map.getRoomLinearDistance(mr.roomName, roomName) > 4))
                        continue;
                    let operation = new OperationPowerHarvest(this.empire, 'PowerHarvest_' + roomName + '_' + Game.time);
                    operation.init(roomName);
                    result.push(operation);
                }
            }
        }
        return result;
    }
}
__decorate([
    check
], StrategyHighwayHarvesting.prototype, "createGlobalOperations", null);

var Status$1;
(function (Status) {
    Status[Status["Working"] = 1] = "Working";
    Status[Status["Closing"] = 2] = "Closing";
})(Status$1 || (Status$1 = {}));
class OperationDemolish extends BaseGlobalOperation {
    constructor(empire, id) {
        super(empire, id);
    }
    init(roomName) {
        if (Memory.operations[this.id])
            return;
        let operationMemory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            //
            closing: false,
            //
            roomName: roomName,
            dismantlerType: WORK,
            status: Status$1.Working
        };
        Memory.operations[this.id] = operationMemory;
    }
    get memory() {
        return super.memory;
    }
    get roomName() {
        return this.memory.roomName;
    }
    onAssignSpawnRoom() {
        const partsCount = Math.min(25, Math.floor(this.spawnRoom.energyCapacityAvailable / (BODYPART_COST[this.memory.dismantlerType] + BODYPART_COST[MOVE])));
        this.creepComposition = {
            body: new CreepBody(`${partsCount}${this.memory.dismantlerType === ATTACK ? 'A' : 'W'}${partsCount}M`),
            energyCapacityAvailable: this.spawnRoom.energyCapacityAvailable,
            lastDismantlerType: this.memory.dismantlerType
        };
        this.shouldUpdateEstimatedStats = true;
    }
    updateEstimatedStats() {
        if (!this.spawnRoom) {
            this.estimatedStats.energyPerTick = 0;
            this.estimatedStats.spawnTime = 0;
            this.estimatedStats.baseCpu = 0.2;
        }
        else {
            this.estimatedStats.energyPerTick = -this.creepComposition.body.cost / CREEP_LIFE_TIME;
            this.estimatedStats.spawnTime = this.creepComposition.body.spawnTime;
            this.estimatedStats.baseCpu = 0.2;
        }
    }
    updateCurrentTask() {
        let unplannedStructureFilter = (s) => {
            if (!s.isBuildable() && (this.memory.dismantlerType !== ATTACK || s.structureType !== STRUCTURE_INVADER_CORE))
                return false;
            if (s.structureType === STRUCTURE_CONTAINER)
                return false;
            if (this.memory.structureFilter && !this.memory.structureFilter.includes(s.structureType))
                return false;
            return true;
        };
        const focusPos = this.memory.focusPos && RoomPosition.deserialize(this.memory.focusPos);
        if (this.memory.onlyDestroyFocus && focusPos && Game.rooms[focusPos.roomName]) {
            let structureUnderFlag = focusPos.lookFor(LOOK_STRUCTURES).find(s => unplannedStructureFilter(s));
            if (structureUnderFlag) {
                this.memory.currentTask = {
                    pos: structureUnderFlag.pos.serialize(),
                    id: structureUnderFlag.id
                };
            }
            else {
                this.memory.status = Status$1.Closing;
            }
            return;
        }
        let demolisher = this.creeps.find(c => c.pos.roomName === this.roomName);
        if (demolisher
            && demolisher.pos.roomName === this.roomName
            && (!this.memory.currentTask
                || !Game.getObjectById(this.memory.currentTask.id)
                || Pather.findPath(demolisher.pos, { pos: Game.getObjectById(this.memory.currentTask.id).pos, range: 1 }, { dontIgnoreCreeps: true }).incomplete)) {
            let structureUnderFlag = focusPos && focusPos.lookFor(LOOK_STRUCTURES).find(s => unplannedStructureFilter(s) && !Pather.findPath(demolisher.pos, { pos: s.pos, range: 1 }).incomplete);
            let currentTask = structureUnderFlag || demolisher.pos.findClosestByPath(this.room.find(FIND_STRUCTURES).filter(unplannedStructureFilter), { range: 1 });
            if (currentTask) {
                this.memory.currentTask = {
                    pos: currentTask.pos.serialize(),
                    id: currentTask.id
                };
            }
            else
                this.memory.status = Status$1.Closing;
        }
    }
    isValidSpawnRoom(myRoom) {
        if (myRoom.room.energyCapacityAvailable < 150)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME / 2)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        return true;
    }
    getSpawnRequestsInternal() {
        if (this.memory.closing)
            return [];
        if (this.memory.status !== Status$1.Working)
            return [];
        const roomIntel = GIntel.rooms[this.roomName];
        if (roomIntel && !roomIntel.isMy && roomIntel.safeMode)
            return [];
        let youngest = ((this.creeps.length > 0) ? _.max(this.creeps, creep => creep.ticksToLive || CREEP_LIFE_TIME) : null);
        if (youngest && (!youngest.ticksToLive || youngest.ticksToLive > Game.map.getRoomLinearDistance(this.roomName, this.spawnRoomName) * 50 + this.creepComposition.body.spawnTime))
            return [];
        if (!this.spawnRoom)
            return [];
        let result = [];
        result.push({
            id: generateRandomKey(5),
            nameBase: 'Demolisher',
            priority: FlagSpawnPriority,
            minEnergy: this.creepComposition.body.cost,
            parts: this.creepComposition.body,
            memory: {},
            boostOptions: [null],
            noRepurpose: false,
            operation: this
        });
        return result;
    }
    DemolisherFunc(creep) {
        if (this.memory.status === Status$1.Closing) {
            this.dismissCreep(creep, true, true);
            return;
        }
        let opts = {
            ignoreRoads: true,
            ensurePath: true,
            maxOps: 20000
        };
        const currentTask = this.memory.currentTask;
        if (!currentTask) {
            if (creep.pos.roomName !== this.roomName)
                creep.goToRoom(this.roomName, opts);
            else
                creep.smokeBreak();
            return;
        }
        let currentTaskPos = RoomPosition.deserialize(this.memory.currentTask.pos);
        let currentTaskObject = Game.getObjectById(this.memory.currentTask.id);
        if (creep.pos.isNearTo(currentTaskPos)) {
            if (creep.getActiveBodyparts(WORK) > 0)
                creep.dismantle(currentTaskObject);
            else
                creep.attack(currentTaskObject);
            creep.giveWay({ pos: currentTaskPos, range: 1 });
        }
        else {
            creep.goTo(currentTaskPos, 1, opts);
        }
        Common.getRoomVisual(currentTaskPos.roomName).text('❌', currentTaskPos.x, currentTaskPos.y + 0.25, {});
    }
    onRun() {
        if (!GIntel.rooms[this.roomName].isSafe)
            this.close();
        if (this.memory.status === Status$1.Working)
            this.updateCurrentTask();
        else
            this.close();
        for (let creep of this.creeps)
            if (!creep.spawning)
                this.DemolisherFunc(creep);
    }
}
OperationDemolish.OperationType = 'Demolish';
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationDemolish.prototype, "getSpawnRequestsInternal", null);
__decorate([
    profile()
], OperationDemolish.prototype, "onRun", null);
class FlagOperationDemolisher extends OperationDemolish {
    init(roomName) {
        if (Memory.flags[this.id])
            return;
        let operationMemory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            closing: false,
            roomName: roomName,
            dismantlerType: Game.flags[this.id].color === COLOR_RED ? ATTACK : WORK,
            status: Status$1.Working
        };
        Memory.flags[this.id] = operationMemory;
    }
    get memory() {
        return Memory.flags[this.id];
    }
    get roomName() {
        return this.memory.roomName;
    }
    get readyToDelete() {
        return !this.flag || super.readyToDelete;
    }
    get flag() {
        return Game.flags[this.id];
    }
    deleteMemory() {
        if (Game.flags[this.id])
            Game.flags[this.id].remove();
        delete Memory.flags[this.id];
    }
    onInitForTick() {
        super.onInitForTick();
        this.memory.roomName = this.flag.pos.roomName;
        this.memory.dismantlerType = Game.flags[this.id].color === COLOR_RED ? ATTACK : WORK;
        this.memory.onlyDestroyFocus = this.flag.color === COLOR_YELLOW;
        this.memory.focusPos = this.flag.pos.serialize();
    }
}

class OperationDeclaim extends BaseGlobalOperation {
    constructor(empire, id) {
        super(empire, id);
        if (this.spawnRoom)
            this.onAssignSpawnRoom();
    }
    init(roomName) {
        const roomIntel = GIntel.rooms[roomName];
        const targetCreepCount = roomIntel
            ? roomIntel.controllerSlots - (roomIntel.blockedControllerSlots || 0)
            : 1;
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            closing: false,
            roomName: roomName,
            targetCreepCount: targetCreepCount,
            spawnedCreeps: 0
        };
        Memory.operations[this.id] = memory;
    }
    get memory() {
        return super.memory;
    }
    get roomName() {
        return this.memory.roomName;
    }
    get room() {
        return Game.rooms[this.roomName];
    }
    close() {
        if (this.creeps.length > 0)
            super.close();
    }
    updateEstimatedStats() {
        if (!this.spawnRoom) {
            this.estimatedStats.energyPerTick = 0;
            this.estimatedStats.spawnTime = 0;
            this.estimatedStats.baseCpu = 0.2 * CREEP_CLAIM_LIFE_TIME / CONTROLLER_ATTACK_BLOCKED_UPGRADE;
        }
        else {
            this.estimatedStats.energyPerTick = -this.creepBody.cost / CONTROLLER_ATTACK_BLOCKED_UPGRADE;
            this.estimatedStats.spawnTime = this.creepBody.spawnTime;
            this.estimatedStats.baseCpu = 0.2 * CREEP_CLAIM_LIFE_TIME / CONTROLLER_ATTACK_BLOCKED_UPGRADE;
        }
    }
    isValidSpawnRoom(myRoom) {
        const minimumCreepCost = BODYPART_COST[CLAIM] + BODYPART_COST[MOVE];
        if (myRoom.room.energyCapacityAvailable < minimumCreepCost)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_CLAIM_LIFE_TIME)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        return true;
    }
    onAssignSpawnRoom() {
        const partCount = Math.floor(this.spawnRoom.energyCapacityAvailable / (BODYPART_COST[MOVE] + BODYPART_COST[CLAIM]));
        this.creepBody = new CreepBody(`${partCount}X${partCount}M`);
        this.shouldUpdateEstimatedStats = true;
    }
    onSpawn(requestId, creepName) {
        super.onSpawn(requestId, creepName);
        ++this.memory.spawnedCreeps;
        if (this.memory.spawnedCreeps >= this.memory.targetCreepCount)
            this.close();
    }
    getSpawnRequestsInternal() {
        if (this.memory.closing)
            return [];
        const roomIntel = GIntel.rooms[this.roomName];
        if (roomIntel && roomIntel.towers > 0)
            return [];
        if (roomIntel && roomIntel.safeMode)
            return [];
        if (roomIntel && roomIntel.upgradeBlocked && roomIntel.upgradeBlocked - Game.time > CREEP_CLAIM_LIFE_TIME)
            return [];
        if (!this.spawnRoom)
            return [];
        let result = [];
        let creepsNeeded = roomIntel
            ? roomIntel.controllerSlots - (roomIntel.blockedControllerSlots || 0)
            : 1;
        for (let i = 0; i < creepsNeeded - this.creeps.length; ++i) {
            result.push({
                id: generateRandomKey(5),
                nameBase: Config.CreepNames.Declaimer,
                priority: FlagSpawnPriority,
                minEnergy: 650,
                parts: this.creepBody,
                memory: {},
                boostOptions: [null],
                noRepurpose: false,
                operation: this
            });
        }
        return result;
    }
    DeclaimerFunc(creep) {
        let GoToOpts = {
            ignoreRoads: true,
            ensurePath: true,
            avoidUnsafeRooms: false
        };
        if (creep.getActiveBodyparts(CLAIM) === 0)
            creep.suicide();
        else if (creep.pos.roomName === this.roomName) {
            let room = Game.rooms[this.roomName];
            let controller = room.controller;
            if (creep.pos.isNearTo(room.controller.pos)) {
                const roomIntel = GIntel.rooms[this.roomName];
                if (roomIntel.reservation && roomIntel.reservation.isHostile) {
                    creep.attackController(room.controller);
                }
                else if (roomIntel.isHostile) {
                    let allCreepsOnSpot = this.creeps.every(c => c.pos.isNearTo(controller.pos));
                    let canSafemode = this.room.controller.safeModeAvailable > 0
                        && !controller.safeModeCooldown
                        && controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[controller.level] / 2 - CONTROLLER_DOWNGRADE_SAFEMODE_THRESHOLD;
                    let areAttacked = this.room.findHostileCreeps().some(h => this.creeps.some(c => c.pos.inRangeTo(h.pos, 3)));
                    let areCreepsDying = this.creeps.some(c => c.ticksToLive < 5);
                    let areOtherDeclaimersThere = !!controller.pos.lookInRange(LOOK_CREEPS, 1).find(c => !c.my && c.getActiveBodyparts(CLAIM) > 0);
                    if (allCreepsOnSpot || canSafemode || areAttacked || areCreepsDying || areOtherDeclaimersThere)
                        creep.attackController(room.controller);
                }
                else if (room.find(FIND_FLAGS).find(f => f.name.startsWith('Claim')))
                    creep.claimController(room.controller);
                else
                    creep.reserveController(room.controller);
                if (!room.controller.sign || room.controller.sign.username !== Common.USERNAME)
                    creep.signController(room.controller, '\u{1F359}');
                creep.giveWay({ pos: room.controller.pos, range: 1 });
            }
            else
                creep.goTo(room.controller.pos, 1, GoToOpts);
        }
        else {
            const roomIntel = GIntel.rooms[this.roomName];
            let controllerPos = roomIntel && roomIntel.controllerPos;
            if (controllerPos)
                creep.goTo(controllerPos, 1, GoToOpts);
            else
                creep.goToRoom(this.roomName);
        }
    }
    onRun() {
        if (this.room && this.room.intel.isFriendly)
            this.abort();
        if (this.room && this.room.intel.towers > 0)
            this.abort();
        for (let creep of this.creeps)
            if (!creep.spawning)
                this.DeclaimerFunc(creep);
    }
}
OperationDeclaim.OperationType = 'Declaim';
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationDeclaim.prototype, "getSpawnRequestsInternal", null);
__decorate([
    profile()
], OperationDeclaim.prototype, "onRun", null);

class StrategyStomp extends BaseStrategy {
    constructor(empire) {
        super(empire);
        if (!this.memory) {
            let strategyMemory = {
                declaimOperations: [],
                demolishOperations: []
            };
            Memory.strategies['Stomp'] = strategyMemory;
        }
    }
    get memory() {
        return Memory.strategies['Stomp'];
    }
    isStompable(roomName, attackRooms) {
        const roomIntel = GIntel.rooms[roomName];
        const myRoomsStatus = Game.map.getRoomStatus(attackRooms[0].roomName);
        if (Game.map.getRoomStatus(roomName).status !== myRoomsStatus.status)
            return false;
        if (roomIntel.safeMode && roomIntel.safeMode > Game.time)
            return false;
        if (!roomIntel.owner)
            return false;
        if (roomIntel.isMy || roomIntel.isFriendly)
            return false;
        if (roomIntel.towers > 0)
            return false;
        if (!roomIntel.isSafe)
            return false;
        if (!Treaties.canBeAttacked(roomName))
            return false;
        if (!Common.findRoomsInRange(roomName, 9).find(r => !!attackRooms.find(ar => ar.roomName === r)))
            return false;
        return true;
    }
    createGlobalOperations(activeOperations) {
        this.memory.declaimOperations = this.memory.declaimOperations.filter(d => !!activeOperations[d]);
        this.memory.demolishOperations = this.memory.demolishOperations.filter(d => !!activeOperations[d]);
        if (Game.cpu.bucket < 5000)
            return null;
        // check if there is any room that can attack
        let myRooms = GEmpire.myRooms;
        let attackRooms = myRooms.filter(mr => mr.room.find(FIND_MY_SPAWNS).length > 0 && mr.room.energyCapacityAvailable >= 650);
        if (attackRooms.length === 0)
            return null;
        // check if there is any room to attack
        let potentialTargets = [];
        for (let roomName in GIntel.rooms) {
            if (this.isStompable(roomName, attackRooms))
                potentialTargets.push(roomName);
        }
        if (potentialTargets.length === 0)
            return null;
        let demolishRooms = [];
        let declaimRooms = [];
        for (let pt of potentialTargets) {
            if (GIntel.rooms[pt].spawns || (GIntel.rooms[pt].blockedControllerSlots || 0) > 0)
                demolishRooms.push(pt);
            declaimRooms.push(pt);
        }
        let result = [];
        // pick up to 3 declaim rooms and 1 demolish room
        let demolishRoom = undefined;
        if (this.memory.demolishOperations.length < StrategyStomp.MaxDemolishCount && demolishRooms.length > 0)
            demolishRoom = _.min(demolishRooms, pt => _.min(attackRooms.map(ar => Game.map.getRoomLinearDistance(ar.roomName, pt))));
        if (this.memory.declaimOperations.length < StrategyStomp.MaxDeclaimCount) {
            declaimRooms = declaimRooms.filter(roomName => {
                const roomIntel = GIntel.rooms[roomName];
                if (roomIntel.controllerSlots - roomIntel.blockedControllerSlots === 0)
                    return false;
                if (this.memory.declaimOperations.some(d => activeOperations[d].roomName === roomName))
                    return false;
                return true;
            });
            declaimRooms.sort((a, b) => _.min(attackRooms.map(ar => Game.map.getRoomLinearDistance(ar.roomName, a))) - _.min(attackRooms.map(ar => Game.map.getRoomLinearDistance(ar.roomName, b))));
            declaimRooms = declaimRooms.slice(0, 3 - this.memory.declaimOperations.length);
        }
        else {
            declaimRooms = [];
        }
        if (demolishRoom) {
            let operationId = 'Demolish_Stomp_' + demolishRoom + '_' + Game.time;
            let demolish = new OperationDemolish(this.empire, operationId);
            demolish.init(demolishRoom);
            this.memory.demolishOperations.push(demolish.id);
            result.push(demolish);
        }
        for (let roomName of declaimRooms) {
            const roomIntel = GIntel.rooms[roomName];
            const isOffDeclaimCooldown = !roomIntel.upgradeBlocked || (roomIntel.upgradeBlocked - Game.time <= CREEP_CLAIM_LIFE_TIME);
            const hasSlotsAvailable = (roomIntel.blockedControllerSlots < roomIntel.controllerSlots);
            if (isOffDeclaimCooldown && hasSlotsAvailable) {
                let operationId = 'Declaim_Stomp_' + roomName + '_' + Game.time;
                let declaim = new OperationDeclaim(this.empire, operationId);
                declaim.init(roomName);
                this.memory.declaimOperations.push(declaim.id);
                result.push(declaim);
            }
        }
        return result;
    }
}
StrategyStomp.MaxDemolishCount = 1;
StrategyStomp.MaxDeclaimCount = 3;
__decorate([
    check
], StrategyStomp.prototype, "createGlobalOperations", null);

class FlagOperationDrain extends BaseFlagOperation {
    constructor(empire, flagName) {
        super(empire, flagName);
        this.updateCreepComposition();
    }
    get memory() {
        return super.memory;
    }
    get roomName() {
        return this.flag.pos.roomName;
    }
    get squadSize() {
        return this.creepComposition.creepCount;
    }
    onInitForTick() {
        super.onInitForTick();
        this.rallyFlag = Game.flags['Rally' + this.flag.name];
        this._closestTarget = undefined;
        if (this.flag.room) {
            this.structures = this.flag.room.find(FIND_STRUCTURES, {
                filter: s => {
                    if (!s.isBuildable())
                        return false;
                    if (s.structureType === STRUCTURE_CONTAINER)
                        return false;
                    return true;
                }
            });
        }
        else {
            this.structures = [];
        }
        if (this.flag.color !== this.creepComposition.flagColor)
            this.updateCreepComposition();
    }
    updateCreepComposition() {
        const squadSize = (this.flag.color === COLOR_PURPLE || this.flag.color === COLOR_CYAN || this.flag.color === COLOR_YELLOW) ? 4 : 2;
        let body;
        if (this.flag.color === COLOR_GREEN || this.flag.color === COLOR_YELLOW) {
            body = new CreepBody('2A5M5H2M');
        }
        else if (this.flag.color === COLOR_RED || this.flag.color === COLOR_PURPLE) {
            body = new CreepBody('2TAR8M6H2M');
        }
        else {
            body = new CreepBody('4T2A2R18M12H2M');
        }
        this.creepComposition = {
            body: body,
            creepCount: squadSize,
            flagColor: this.flag.color
        };
        this.shouldUpdateEstimatedStats = true;
    }
    updateEstimatedStats() {
        this.estimatedStats.energyPerTick = -this.creepComposition.body.cost * this.creepComposition.creepCount / CREEP_LIFE_TIME;
        this.estimatedStats.spawnTime = this.creepComposition.body.spawnTime * this.creepComposition.creepCount;
        this.estimatedStats.baseCpu = 0.2 * this.creepComposition.creepCount;
    }
    isValidSpawnRoom(myRoom) {
        const composition = this.creepComposition;
        const creepCost = composition.body.cost;
        if (myRoom.room.energyCapacityAvailable < creepCost)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME / 2)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        return true;
    }
    onAssignSpawnRoom() {
        this.updateCreepComposition();
    }
    getSpawnRequestsInternal() {
        if (!this.spawnRoom)
            return [];
        if (this.memory.closing)
            return [];
        if (this.memory.attacking === true)
            return [];
        const roomIntel = GIntel.rooms[this.roomName];
        if (roomIntel && roomIntel.safeMode)
            return [];
        let result = [];
        let neededCount = this.squadSize - this.creeps.length;
        for (let i = 0; i < neededCount; ++i) {
            result.push({
                id: generateRandomKey(5),
                nameBase: 'Drainer',
                priority: (this.memory.creeps.length === 0 ? FlagSpawnPriority : StartedSquadPriority) + 0.1 * this.memory.creeps.length,
                minEnergy: this.creepComposition.body.cost,
                parts: this.creepComposition.body,
                memory: {},
                boostOptions: [null],
                noRepurpose: false,
                operation: this
            });
        }
        return result;
    }
    goToRoom() {
        const opts = {
            squadMembers: this.creeps.slice(1),
            avoidNarrowPaths: this.creeps.length > 2
        };
        CombatPather.goTo(this.creeps[0], new RoomPosition(25, 25, this.flag.pos.roomName), 22, opts);
    }
    fleeFromRoom() {
        const opts = {
            squadMembers: this.creeps.slice(1)
        };
        CombatPather.goTo(this.creeps[0], new RoomPosition(25, 25, this.rallyFlag.pos.roomName), 22, opts);
    }
    goToRally() {
        const rallyOpts = {
            ignoreRoads: true,
            avoidSourceKeepers: true,
            avoidHostileRooms: true,
            ensurePath: true
        };
        for (let i = 0; i < this.creeps.length; ++i) {
            let creep = this.creeps[i];
            if (creep.pos.roomName === this.flag.pos.roomName)
                creep.fleeFromRoom(creep.pos.roomName);
            else {
                let creepRally = new RoomPosition(this.rallyFlag.pos.x + i % 2, this.rallyFlag.pos.y + Math.floor(i / 2), this.rallyFlag.pos.roomName);
                if (creep.pos.isEqualTo(creepRally))
                    creep.giveWay(true);
                else
                    creep.goTo(creepRally, 0, rallyOpts);
            }
        }
    }
    get closestTarget() {
        if (this._closestTarget !== undefined)
            return this._closestTarget;
        if (this.creeps.some(c => c.pos.roomName === this.roomName)) {
            let closestBuilding = this.creeps[0].pos.findClosestByPath(this.structures);
            let closestCreep = this.creeps[0].pos.findClosestByPath(FIND_HOSTILE_CREEPS, { filter: (c) => !Config.NEUTRAL.has(c.owner.username) && !Config.ALLIES.has(c.owner.username) });
            this._closestTarget = _.min([closestCreep, closestBuilding], target => target ? _.sum(this.creeps, c => c.pos.roomName === this.roomName ? c.pos.getRangeTo(target) : 0) : Infinity);
        }
        else
            this._closestTarget = null;
        return this._closestTarget;
    }
    roam() {
        const opts = {
            squadMembers: this.creeps.slice(1),
            avoidNarrowPaths: this.creeps.length > 2
        };
        let towers = this.structures.filter(s => s.structureType === STRUCTURE_TOWER);
        let towersEnergy = _.sum(towers, t => t.energy);
        if (this.creeps.every(c => c.hitsMax - c.hits < 50)) {
            let closest = this.closestTarget;
            if (this._lastTowerEnergy === towersEnergy)
                CombatPather.goTo(this.creeps[0], closest.pos, 1, opts);
        }
        else {
            // flee from room
            CombatPather.goTo(this.creeps[0], new RoomPosition(25, 25, this.rallyFlag.pos.roomName), 22, opts);
        }
        this._lastTowerEnergy = towersEnergy;
    }
    heal() {
        if (this.creeps.length === 0)
            return;
        if (this.creeps.every(c => c.hits === c.hitsMax && GIntel.rooms[c.pos.roomName].isSafe))
            return;
        let potentialDamage = this.creeps.map(c => {
            const roomIntel = GIntel.rooms[c.pos.roomName];
            const damageWeight = 2;
            const potentialDamageWeight = 1;
            let towerDamageMatrix = !roomIntel.isFriendly && CombatData.getTowerPower(c.pos.roomName);
            let creepDamageMatrix = CombatData.getHostileCreepDamage(c.pos.roomName);
            let hitsMax = c.hitsMax + _.sum(c.body, bp => bp.type === TOUGH ? 100 / getBodypartBoostMod(bp) - 100 : 0);
            let hits = c.hits + _.sum(c.body, bp => bp.type === TOUGH ? bp.hits / getBodypartBoostMod(bp) - bp.hits : 0);
            let result = damageWeight * (hitsMax - hits);
            result += potentialDamageWeight * (towerDamageMatrix && towerDamageMatrix[c.pos.y * 50 + c.pos.x] || 0);
            result += potentialDamageWeight * (creepDamageMatrix && creepDamageMatrix[c.pos.y * 50 + c.pos.x] || 0);
            return {
                creep: c,
                damage: result
            };
        });
        for (let creep of this.creeps) {
            let mostDamaged = _(potentialDamage)
                .filter(v => v.creep.pos.isNearTo(creep.pos))
                .max(v => v.damage);
            if (mostDamaged.damage > 0 || mostDamaged.creep.hits < mostDamaged.creep.hitsMax)
                creep.heal(mostDamaged.creep);
            mostDamaged.damage -= getBodypartPower(HEAL, creep) * HEAL_POWER;
        }
    }
    onRun() {
        this.heal();
        if (this.creeps.length > 0) {
            for (let c of this.creeps)
                if (c.getActiveBodyparts(RANGED_ATTACK) > 0)
                    c.shootAtWill([...this.structures, ...c.room.findHostileCreeps()]);
            let disengageThreshold = this.creepComposition.body.tough > 0 ? this.creepComposition.body.tough * 100 : this.creepComposition.body.attack * 100;
            if (!this.memory.recovering && this.creeps.some(c => c.hits < c.hitsMax - disengageThreshold))
                this.memory.recovering = true;
            else if (this.memory.recovering && this.creeps.every(c => c.hits === c.hitsMax))
                this.memory.recovering = false;
            if (this.creeps.length === this.squadSize && this.creeps.every(c => c.pos.isNearTo(this.creeps[0].pos)) && this.creeps.every(c => c.pos.roomName === this.rallyFlag.pos.roomName))
                this.memory.attacking = true;
            else if (this.creeps.length === 0)
                this.memory.attacking = false;
            if (this.flag.secondaryColor === COLOR_WHITE)
                this.memory.attacking = false;
            if (this.memory.attacking) {
                if (this.memory.recovering) {
                    const currentHits = _.sum(this.creeps, creep => creep.hits);
                    const areGettingShot = currentHits < this._lastHits;
                    this._lastHits = currentHits;
                    if (areGettingShot)
                        this.fleeFromRoom();
                }
                else if (this.creeps.some(c => c.pos.roomName !== this.flag.pos.roomName || c.pos.isExit()))
                    this.goToRoom();
                else
                    this.roam();
                let closestTarget = this.closestTarget;
                if (closestTarget) {
                    for (let creep of this.creeps)
                        if (creep.pos.isNearTo(closestTarget.pos))
                            creep.attack(closestTarget);
                        else {
                            let structureInRange = creep.pos.lookInRange(LOOK_STRUCTURES, 1)[0];
                            let creepInRange = creep.pos.lookInRange(LOOK_CREEPS, 1).find(c => !c.my && !Config.NEUTRAL.has(c.owner.username) && !Config.ALLIES.has(c.owner.username));
                            if (creepInRange)
                                creep.attack(creepInRange);
                            else if (structureInRange)
                                creep.attack(structureInRange);
                        }
                }
            }
            else {
                this.goToRally();
            }
        }
        else {
            this.memory.attacking = false;
            this.memory.recovering = false;
        }
    }
}
__decorate([
    Profiler.profile()
], FlagOperationDrain.prototype, "onInitForTick", null);
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], FlagOperationDrain.prototype, "getSpawnRequestsInternal", null);
__decorate([
    check,
    profile()
], FlagOperationDrain.prototype, "onRun", null);

var Status$2;
(function (Status) {
    Status[Status["Working"] = 1] = "Working";
    Status[Status["Closing"] = 2] = "Closing";
})(Status$2 || (Status$2 = {}));
class FlagOperationSalvageTeam extends BaseFlagOperation {
    constructor(empire, flagName) {
        super(empire, flagName);
    }
    get memory() { return super.memory; }
    init(roomName) {
        super.init(roomName);
        this.memory.status = Status$2.Working;
    }
    updateEstimatedStats() {
    }
    isValidSpawnRoom(myRoom) {
        if (myRoom.room.energyCapacityAvailable < 100)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME / 3)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        return true;
    }
    getSpawnRequestsInternal() {
        if (this.memory.status !== Status$2.Working)
            return [];
        if (this.memory.closing)
            return [];
        if (!GIntel.rooms[this.roomName].isSafe)
            return [];
        if (!this.spawnRoom)
            return [];
        if (GIntel.rooms[this.roomName].safeMode)
            return [];
        let distance = 50 * Game.map.getRoomLinearDistance(this.spawnRoomName, this.roomName);
        let result = [];
        let neededCount = this.flag.color - this.creeps.length;
        for (let i = 0; i < neededCount; ++i) {
            result.push({
                id: generateRandomKey(5),
                nameBase: Config.CreepNames.Salvager,
                priority: FlagSpawnPriority,
                minEnergy: 100,
                parts: (distance > CREEP_LIFE_TIME / 4 || this.flag.secondaryColor === COLOR_YELLOW)
                    ? new CreepBody(`${Math.min(25, Math.floor(this.spawnRoom.energyCapacityAvailable / (BODYPART_COST[CARRY] + BODYPART_COST[MOVE])))}[CM]`)
                    : new CreepBody(`${Math.min(16, Math.floor(this.spawnRoom.energyCapacityAvailable / (2 * BODYPART_COST[CARRY] + BODYPART_COST[MOVE])))}[CCM]`),
                memory: {
                    state: 0
                },
                boostOptions: [null],
                noRepurpose: false,
                operation: this
            });
        }
        return result;
    }
    findNewTarget(creepPos) {
        if (!this.flag.room)
            return undefined;
        let toEmpty = this.flag.room.find(FIND_STRUCTURES, {
            filter: s => {
                if (s.pos.lookFor(LOOK_STRUCTURES).find(s2 => s2.structureType === STRUCTURE_RAMPART))
                    return false;
                if (!s.hasStore() || s.store.getUsedCapacity() === 0)
                    return false;
                // so they aren't stuck on mining creep
                if (s.pos.lookFor(LOOK_CREEPS).length > 0 && s.store.getUsedCapacity(RESOURCE_ENERGY) === s.store.getUsedCapacity())
                    return false;
                if (s.structureType === STRUCTURE_NUKER)
                    return false;
                if (s.structureType === STRUCTURE_SPAWN && s.store.energy < 100)
                    return false;
                return true;
            }
        });
        toEmpty.push(...this.flag.room.find(FIND_TOMBSTONES, { filter: t => t.store.getUsedCapacity() > 0 }));
        toEmpty.push(...this.flag.room.find(FIND_RUINS, { filter: r => r.store.getUsedCapacity() > 0 }));
        let resources = this.flag.room.find(FIND_DROPPED_RESOURCES).filter(r => !r.pos.lookFor(LOOK_CREEPS).find(c => c.my));
        if (this.memory.resourceFilter) {
            toEmpty = toEmpty.filter(te => this.memory.resourceFilter.find(resource => te.store.getUsedCapacity(resource) > 0));
            resources = resources.filter(r => this.memory.resourceFilter.includes(r.resourceType));
        }
        let nonEnergyResources = resources.filter(r => r.resourceType !== RES_ENERGY);
        let nonEnergyStores = toEmpty.filter(s => s.store.getUsedCapacity() - s.store.getUsedCapacity(RES_ENERGY) > 0);
        if (nonEnergyResources.length > 0) {
            const closest = creepPos.findClosestByPath(nonEnergyResources);
            return closest;
        }
        if (nonEnergyStores.length > 0) {
            const closest = creepPos.findClosestByPath(nonEnergyStores);
            return closest;
        }
        const ignoreEnergy = this.flag.secondaryColor === COLOR_GREY;
        if (!ignoreEnergy && resources.length > 0) {
            const closest = creepPos.findClosestByPath(resources);
            return closest;
        }
        if (!ignoreEnergy && toEmpty.length > 0) {
            const closest = creepPos.findClosestByPath(toEmpty);
            return closest;
        }
        this.memory.status = Status$2.Closing;
        return null;
    }
    SalvageTeamFunc(creep) {
        let creepMemory = creep.memory;
        if (!creepMemory.homeRoom) {
            // TODO - temp
            let rallyFlag = Game.flags['Rally' + this.flag.name];
            if (rallyFlag)
                creepMemory.homeRoom = rallyFlag.pos.roomName;
            else
                //
                creepMemory.homeRoom = creep.pos.roomName;
        }
        if (this.memory.status === Status$2.Closing) {
            if (creep.pos.roomName !== creepMemory.homeRoom)
                creep.goToRoom(creepMemory.homeRoom, { ensurePath: true });
            else {
                let spawnsInRange = creep.pos.findInRange(FIND_MY_SPAWNS, 1);
                if (creep.pos.inRangeTo(creep.room.storage, 2) && spawnsInRange.length > 0) {
                    spawnsInRange[0].recycleCreep(creep);
                }
                else if (creep.pos.inRangeTo(creep.room.storage, 2)) {
                    let closestSpawn = creep.pos.findClosestByRange(FIND_MY_SPAWNS);
                    if (closestSpawn)
                        creep.goTo(closestSpawn.pos, 1);
                }
                else {
                    creep.goTo(creep.room.storage.pos, 2);
                }
            }
            return;
        }
        if (creepMemory.state === 0 && creep.store.getFreeCapacity() === 0)
            creepMemory.state = 1;
        if (creepMemory.state === 1 && creep.store.getUsedCapacity() === 0) {
            creepMemory.state = 0;
            if (creep.ticksToLive < Game.map.getRoomLinearDistance(creepMemory.homeRoom, this.roomName) * 50 * 2) {
                this.dismissCreep(creep, true, false);
                return;
            }
        }
        if (creepMemory.state === 0) {
            if (!creepMemory.targetPos && creep.pos.roomName !== this.flag.pos.roomName)
                creep.goToRoom(this.flag.pos.roomName, { ensurePath: true, avoidUnsafeRooms: true });
            else {
                if (!creepMemory.targetPos) {
                    let newTarget = this.findNewTarget(creep.pos);
                    if (newTarget) {
                        creepMemory.targetId = newTarget.id;
                        creepMemory.targetPos = newTarget.pos.serialize();
                    }
                }
                if (creepMemory.targetPos) {
                    let targetPos = RoomPosition.deserialize(creepMemory.targetPos);
                    if (!creep.pos.isNearTo(targetPos)) {
                        creep.goTo(targetPos, 1);
                        Common.getRoomVisual(targetPos.roomName).text('\uD83D\uDCB0', targetPos.x, targetPos.y);
                    }
                    else {
                        const target = Game.getObjectById(creepMemory.targetId);
                        if (target instanceof Resource) {
                            creep.pickup(target);
                        }
                        else if (target) {
                            let resourceType = _.sample(Object.keys(target.store).filter(r => r !== RES_ENERGY));
                            if (!resourceType)
                                resourceType = _.findKey(target.store);
                            creep.withdraw(target, resourceType);
                        }
                        creepMemory.targetPos = undefined;
                        creepMemory.targetId = undefined;
                    }
                }
                else {
                    creep.giveWay(true);
                    creep.say('\u00AF\\_(\u30C4)_\/\u00AF');
                }
            }
        }
        else {
            if (creep.pos.roomName !== creepMemory.homeRoom)
                creep.goToRoom(creepMemory.homeRoom, { ensurePath: true, avoidUnsafeRooms: true });
            else {
                const resourceType = _.findKey(creep.carry);
                if (creep.transfer(creep.room.storage, resourceType) === ERR_NOT_IN_RANGE)
                    creep.goTo(creep.room.storage.pos, 1);
            }
        }
    }
    onRun() {
        if (this.flag.room && this.memory.status === Status$2.Closing && this.creeps.length === 0) {
            this.flag.remove();
            return;
        }
        for (let creep of this.creeps)
            if (!creep.spawning)
                this.SalvageTeamFunc(creep);
    }
}
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], FlagOperationSalvageTeam.prototype, "getSpawnRequestsInternal", null);
__decorate([
    profile()
], FlagOperationSalvageTeam.prototype, "onRun", null);

class FlagOperationSwarm extends BaseFlagOperation {
    constructor(empire, id) {
        super(empire, id);
    }
    get memory() {
        return super.memory;
    }
    get swarmSize() {
        return this.flag.color * 5 + Math.max(0, this.flag.color - 5) * 5;
    }
    updateEstimatedStats() {
        const creepCost = BODYPART_COST[ATTACK] + BODYPART_COST[MOVE];
        const swarmSize = this.swarmSize;
        this.estimatedStats.energyPerTick = -swarmSize * creepCost / CREEP_LIFE_TIME;
        this.estimatedStats.spawnTime = swarmSize * 2 * CREEP_SPAWN_TIME;
        this.estimatedStats.baseCpu = 0.2 * swarmSize;
    }
    onInitForTick() {
        super.onInitForTick();
        if (this.flag.room) {
            this.hostiles = this.flag.room.findHostileCreeps().filter(h => h.owner.username !== 'Source Keeper');
            this.structures = this.flag.room.find(FIND_STRUCTURES, { filter: s => s.structureType !== STRUCTURE_CONTROLLER && s.structureType !== STRUCTURE_RAMPART && s.structureType !== STRUCTURE_ROAD && s.structureType !== STRUCTURE_CONTAINER && s.structureType !== STRUCTURE_KEEPER_LAIR });
            this.towers = this.structures.filter(s => s.structureType === STRUCTURE_TOWER);
            this.allTargets = [...this.hostiles, ...this.structures];
            this.nonMeleeTargets = [...this.hostiles.filter(c => c.getActiveBodyparts(ATTACK) === 0), ...this.structures];
            this.allShootables = [...this.hostiles, ...this.flag.room.find(FIND_HOSTILE_STRUCTURES, { filter: s => s.structureType !== STRUCTURE_CONTROLLER && s.structureType !== STRUCTURE_KEEPER_LAIR })];
        }
        else {
            this.structures = [];
            this.hostiles = [];
            this.towers = [];
            this.allTargets = [];
            this.allShootables = [];
        }
        this.obstacles = this.hostiles.map(h => h.pos);
        for (let creep of this.creeps)
            if (creep.fatigue > 0)
                this.obstacles.push(creep.pos);
        if (this.flag.color !== this.lastFlagColor) {
            this.lastFlagColor = this.flag.color;
            this.shouldUpdateEstimatedStats = true;
        }
    }
    isValidSpawnRoom(myRoom) {
        if (myRoom.room.energyCapacityAvailable < 300)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME / 2)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        return true;
    }
    getSpawnRequestsInternal() {
        let roomIntel = GIntel.rooms[this.roomName];
        if (roomIntel && roomIntel.safeMode)
            return [];
        if (this.memory.closing)
            return [];
        let result = [];
        let swarmSize = this.swarmSize;
        for (let i = 0; i < swarmSize - this.creeps.length; ++i) {
            result.push({
                id: generateRandomKey(5),
                nameBase: Config.CreepNames.Swarmling,
                priority: FlagSpawnPriority,
                minEnergy: 300,
                parts: new CreepBody(`${_.sample(['A', 'R', 'H'])}M`),
                memory: {},
                boostOptions: [null],
                noRepurpose: false,
                operation: this
            });
        }
        return result;
    }
    swarmlingFunc(creep) {
        let rallyOpts = {
            ensurePath: true,
            ignoreRoads: true
        };
        let opts = {
            // TODO
            //obstacles: this.obstacles,
            maxOps: 400
        };
        let attacked = false;
        let rattacked = false;
        if (creep.pos.roomName !== this.flag.pos.roomName || this.allTargets.length === 0 || GIntel.rooms[creep.pos.roomName].isFriendly || this.flag.secondaryColor === COLOR_WHITE) {
            if (creep.pos.roomName === this.flag.pos.roomName && creep.pos.inRangeTo(this.flag.pos, 3))
                creep.giveWay({ pos: this.flag.pos, range: 3 });
            else
                creep.goTo(this.flag.pos, 3, rallyOpts);
            if (creep.getActiveBodyparts(RANGED_ATTACK) > 0 && this.allTargets.some(t => t.pos.inRangeTo(creep, 3))) {
                creep.shootAtWill(creep.room.findHostileCreeps());
                rattacked = true;
            }
        }
        else {
            let value = (t) => {
                let distance = creep.pos.getRangeTo(t);
                let rampart = t.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_RAMPART);
                let hits = t.hits + (rampart ? rampart.hits : 0);
                return hits * distance * distance;
            };
            let range = creep.getActiveBodyparts(ATTACK) ? 1 : 3;
            let target = _.min(creep.getActiveBodyparts(ATTACK) > 0 ? this.nonMeleeTargets : this.allTargets, value);
            if (target) {
                if (creep.pos.inRangeTo(target, range))
                    creep.giveWay({ pos: target.pos, range: range });
                else
                    CombatPather.goTo(creep, target.pos, range, opts);
            }
            if (creep.getActiveBodyparts(ATTACK)) {
                if (target && target.pos.isNearTo(creep)) {
                    creep.attack(target);
                    if (target instanceof Creep)
                        creep.move(creep.pos.getDirectionTo(target));
                    attacked = true;
                }
                else {
                    let targetInRange = this.allTargets.find(t => creep.pos.isNearTo(t.pos));
                    if (targetInRange) {
                        creep.attack(targetInRange);
                        attacked = true;
                    }
                }
            }
            if (creep.getActiveBodyparts(RANGED_ATTACK) > 0 && this.allTargets.some(t => t.pos.inRangeTo(creep, 3))) {
                creep.shootAtWill(this.allShootables, target);
                rattacked = true;
            }
        }
        if (creep.getActiveBodyparts(HEAL) > 0) {
            let lowest = _.max(this.creeps, c => c.pos.inRangeTo(creep, rattacked ? 1 : 3) ? c.hitsMax - c.hits : -Infinity);
            if (lowest.hits === lowest.hitsMax && this.towers.length > 0)
                lowest = _.min(this.creeps, c => c.pos.roomName === this.flag.pos.roomName ? c.pos.findClosestByRange(this.towers).pos.getRangeTo(c) : Infinity);
            if (creep.pos.isNearTo(lowest) && !attacked)
                creep.heal(lowest);
            else if (!rattacked)
                creep.rangedHeal(lowest);
        }
    }
    onRun() {
        for (let creep of this.creeps)
            if (!creep.spawning)
                this.swarmlingFunc(creep);
    }
}
__decorate([
    Profiler.profile()
], FlagOperationSwarm.prototype, "onInitForTick", null);
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], FlagOperationSwarm.prototype, "getSpawnRequestsInternal", null);
__decorate([
    profile()
], FlagOperationSwarm.prototype, "onRun", null);

class OperationBuildSupport extends BaseGlobalOperation {
    constructor(empire, id) {
        super(empire, id);
        this.storeResources = (creep, opts) => {
            const structures = this.room.find(FIND_STRUCTURES);
            const spawnsAndExtensions = structures.filter(s => { return (s.structureType === STRUCTURE_SPAWN || s.structureType === STRUCTURE_EXTENSION) && s.energy < s.energyCapacity; });
            const towers = structures.filter(s => { return s.structureType === STRUCTURE_TOWER && s.energy < s.energyCapacity * 0.5; });
            const storages = structures.filter(s => s.structureType === STRUCTURE_STORAGE);
            if (spawnsAndExtensions.length > 0) {
                let closest = creep.pos.findClosestByRange(spawnsAndExtensions);
                if (creep.pos.isNearTo(closest))
                    creep.transfer(closest, RESOURCE_ENERGY);
                else
                    creep.goTo(closest.pos, 1, opts);
            }
            else if (towers.length > 0) {
                let closest = creep.pos.findClosestByRange(towers);
                if (!creep.pos.isNearTo(closest))
                    creep.goTo(closest.pos, 1, opts);
                else {
                    creep.transfer(closest, RESOURCE_ENERGY);
                    creep.giveWay(true);
                }
            }
            else if (storages.length > 0) {
                let closest = creep.pos.findClosestByRange(storages);
                if (!creep.pos.isNearTo(closest))
                    creep.goTo(closest.pos, 1, opts);
                else {
                    creep.transfer(closest, RESOURCE_ENERGY);
                    creep.giveWay(true);
                }
            }
        };
    }
    init(roomName, targetCreepCount) {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            closing: false,
            upgradeOnly: false,
            raiseRamparts: false,
            roomName: roomName,
            targetCreepCount: targetCreepCount
        };
        Memory.operations[this.id] = memory;
    }
    get memory() {
        return super.memory;
    }
    get roomName() {
        return this.memory.roomName;
    }
    get targetCreepCount() {
        return this.memory.targetCreepCount;
    }
    updateEstimatedStats() {
        if (!this.spawnRoomName)
            return;
        this.estimatedStats.energyPerTick = -this.creepBody.cost * this.creeps.length / CREEP_LIFE_TIME;
        this.estimatedStats.spawnTime = this.creepBody.spawnTime * this.creeps.length;
        this.estimatedStats.baseCpu = 0.2 * this.creeps.length;
    }
    onSpawn(requestId, creepName) {
        super.onSpawn(requestId, creepName);
        this.shouldUpdateEstimatedStats = true;
    }
    onCreepDeath(creepName) {
        this.shouldUpdateEstimatedStats = true;
    }
    onAssignSpawnRoom() {
        const workCount = Math.min(16, Math.floor(this.spawnRoom.energyCapacityAvailable / (BODYPART_COST[WORK] + BODYPART_COST[CARRY] + BODYPART_COST[MOVE])));
        this.creepBody = new CreepBody(`${workCount}[WC]${workCount}M`);
    }
    isValidSpawnRoom(myRoom) {
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME / 2)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        return true;
    }
    getSpawnRequestsInternal() {
        if (this.memory.closing)
            return [];
        if (!GIntel.rooms[this.roomName].isSafe)
            return [];
        if (!this.spawnRoom)
            return [];
        if (this.cooldown) {
            --this.cooldown;
            return [];
        }
        let result = [];
        const upgradeOnly = this.memory.upgradeOnly && this.room && this.room.controller.level < 6 && this.room.memory.spawns > 0;
        const boostOptions = upgradeOnly
            ? [[RES_XGH2O], [RES_GH2O], [RES_GH], null]
            : [null];
        let neededCount = this.targetCreepCount - this.creeps.length;
        for (let i = 0; i < neededCount; ++i) {
            result.push({
                id: generateRandomKey(5),
                nameBase: Config.CreepNames.Builder,
                priority: FlagSpawnPriority,
                minEnergy: 200,
                parts: this.creepBody,
                memory: {
                    state: 0
                },
                boostOptions: boostOptions,
                noRepurpose: false,
                operation: this
            });
        }
        if (neededCount === 0 && Common.isHighway(this.roomName))
            this.cooldown = 1000;
        return result;
    }
    builderFunc(creep) {
        // intershard
        //if (Common.isHighway(this.roomName))
        //  {
        //  creep.goTo(this.flag.pos, 0, { allowPortals: true, ensurePath: true, maxOps: 20000 });
        //  return;
        //  }
        let creepMemory = creep.memory;
        if (creepMemory.boosts) {
            this.boostCreep(creep);
            return;
        }
        let goToRoomOpts = {
            maxOps: 20000,
            ensurePath: true,
            avoidUnsafeRooms: true,
            dontIgnoreCreeps: false
        };
        // flee from invasion
        let inRoom = (creep.pos.roomName === this.roomName);
        let nextToRoom = !!Common.getExitDir(creep.pos.roomName, this.roomName);
        let roomIntel = GIntel.rooms[this.roomName];
        let isSafe = this.room && this.room.controller.safeMode;
        let notBreached = this.room && this.room.myRoom && this.room.storage;
        let isInvaded = roomIntel.invasion && (roomIntel.invasion.meleeAttack || roomIntel.invasion.rangedAttack) && this.room.findHostileCreeps().some(h => !h.pos.isExit() && !!h.body.find(bp => bp.type === RANGED_ATTACK || bp.type === ATTACK));
        if ((inRoom || nextToRoom) && !isSafe && !notBreached && isInvaded) {
            creep.fleeFromRoom(this.roomName);
            return;
        }
        // suicide useless workers
        if (creep.pos.roomName === this.roomName && creep.getActiveBodyparts(WORK) === 0) {
            creep.suicide();
            return;
        }
        // check if task is done
        let currentTask = creepMemory.currentTask && Game.getObjectById(creepMemory.currentTask);
        let currentTaskPos = creepMemory.currentTaskPos ? RoomPosition.deserialize(creepMemory.currentTaskPos) : undefined;
        let currentTaskRoom = currentTaskPos && Game.rooms[currentTaskPos.roomName];
        if (currentTask && currentTaskRoom) {
            if (currentTask instanceof ConstructionSite || currentTask instanceof StructureController) {
                if (creep.store.energy === 0)
                    currentTask = undefined;
            }
            else if (currentTask instanceof StructureRampart) {
                if (creep.store.energy === 0 || currentTask.hits === currentTask.hitsMax)
                    currentTask = undefined;
            }
            else if (currentTask instanceof Source) {
                if (creep.carry.energy === creep.carryCapacity || currentTask.energy === 0)
                    currentTask = undefined;
            }
            else if (currentTask instanceof Resource || currentTask instanceof Structure && !('store' in currentTask)) {
                if (creep.carry.energy === creep.carryCapacity)
                    currentTask = undefined;
            }
            else {
                if (creep.carry.energy === creep.carryCapacity || !currentTask.store.energy)
                    currentTask = undefined;
            }
        }
        // find new task
        if (creep.pos.roomName === this.roomName && this.room && !currentTask) {
            let constructionSites = this.room.find(FIND_CONSTRUCTION_SITES);
            let expectedBarrierHits = this.room.myRoom && this.room.myRoom.getTargetBarrier() || 0;
            let barriers = this.room.myRoom
                ? this.room.myRoom.layout.ramparts.filter(r => {
                    if (r.hits > expectedBarrierHits)
                        return false;
                    if (r.hits === r.hitsMax)
                        return false;
                    if (this.room.memory.lastSafe !== this.room.memory.lastScout && r.pos.isNearTo(this.room.controller))
                        return false;
                    return true;
                })
                : this.memory.raiseRamparts
                    ? this.room.find(FIND_STRUCTURES).filter(s => s.structureType === STRUCTURE_RAMPART || s.structureType === STRUCTURE_WALL)
                    : [];
            let hasHostileSafeMode = !this.room.controller.my && !!this.room.controller.safeMode;
            let controller = this.room.controller.my ? this.room.controller : undefined;
            let resources = creep.store.getFreeCapacity() === 0 ? [] : this.room.find(FIND_DROPPED_RESOURCES)
                .filter(r => r.resourceType === RESOURCE_ENERGY && r.amount > 20)
                .sort((a, b) => b.amount / (creep.pos.getRangeTo(b.pos) || 1) - a.amount / (creep.pos.getRangeTo(a.pos) || 1))
                .slice(0, 5);
            let tombstones = hasHostileSafeMode ? [] : this.room.find(FIND_TOMBSTONES).filter(t => t.store.energy);
            let ruins = hasHostileSafeMode ? [] : this.room.find(FIND_RUINS).filter(t => t.store.energy);
            let containers = hasHostileSafeMode ? [] : this.room.find(FIND_STRUCTURES).filter(s => s.structureType === STRUCTURE_CONTAINER && (s.store.energy || 0) > Math.min(creep.store.getFreeCapacity(), 100));
            let storages = hasHostileSafeMode ? [] : [this.room.storage, this.room.terminal].filter(s => !!s && s.store.energy);
            let upgradeOnly = this.memory.upgradeOnly && this.room.controller.level < 6 && this.room.memory.spawns > 0;
            let shouldUpgrade = controller && !controller.upgradeBlocked && (controller.level === 1 || (controller.ticksToDowngrade || Infinity) < CONTROLLER_DOWNGRADE[controller.level] / 2 + 1000);
            let potentialTasks;
            if (creep.carry.energy === 0)
                potentialTasks = [...resources, ...ruins, ...tombstones, ...containers, ...storages];
            else if (upgradeOnly && creep.carry.energy === creep.carryCapacity && controller && !controller.upgradeBlocked)
                potentialTasks = [controller];
            else if (upgradeOnly && controller && !controller.upgradeBlocked)
                potentialTasks = [...resources, ...ruins, ...tombstones, ...containers, ...storages, controller];
            else if (creep.carry.energy === creep.carryCapacity && constructionSites.length > 0 && !shouldUpgrade)
                potentialTasks = [...constructionSites];
            else if (creep.carry.energy === creep.carryCapacity && barriers.length > 0 && !shouldUpgrade)
                potentialTasks = [_.min(barriers, b => b.hits)];
            else if (creep.carry.energy === creep.carryCapacity && controller)
                potentialTasks = [controller];
            else
                potentialTasks = [...(constructionSites.length > 0 ? constructionSites : barriers), ...ruins, ...resources, ...tombstones, ...containers, ...storages];
            let pathToClosest = Pather.findPathToClosest(creep.pos, potentialTasks.map(pt => ({ pos: pt.pos, range: 1 })));
            let lastPathStep = pathToClosest.path.length > 0 ? _.last(pathToClosest.path) : creep.pos;
            let closest = potentialTasks.find(t => t.pos.isNearTo(lastPathStep));
            if (closest) {
                creepMemory.currentTask = closest.id;
                creepMemory.currentTaskPos = closest.pos.serialize();
            }
            else if (creep.carry.energy === creep.carryCapacity && controller) {
                creepMemory.currentTask = controller.id;
                creepMemory.currentTaskPos = controller.pos.serialize();
            }
            else {
                const canBeMined = (!roomIntel.reservation || roomIntel.reservation.isMy) && (!roomIntel.owner || roomIntel.isMy);
                let activeSources = this.room.find(FIND_SOURCES_ACTIVE);
                if (canBeMined && activeSources.length > 0) {
                    let pathToClosestSource = Pather.findPathToClosest(creep.pos, activeSources.map(s => ({ pos: s.pos, range: 1 })), { dontIgnoreCreeps: true });
                    let lastPathToSourceStep = pathToClosestSource.path.length > 0 ? _.last(pathToClosestSource.path) : creep.pos;
                    let closestSource = activeSources.find(as => as.pos.isNearTo(lastPathToSourceStep));
                    if (closestSource) {
                        creepMemory.currentTask = closestSource.id;
                        creepMemory.currentTaskPos = closestSource.pos.serialize();
                    }
                }
            }
        }
        currentTask = creepMemory.currentTask && Game.getObjectById(creepMemory.currentTask);
        currentTaskPos = creepMemory.currentTaskPos ? RoomPosition.deserialize(creepMemory.currentTaskPos) : undefined;
        currentTaskRoom = currentTaskPos && Game.rooms[currentTaskPos.roomName];
        // no purpose
        if ((!currentTaskPos || creep.pos.roomName === currentTaskPos.roomName) && !currentTask) {
            if (creep.pos.roomName !== this.roomName)
                creep.goToRoom(this.roomName, goToRoomOpts);
            else
                creep.smokeBreak();
            return;
        }
        //
        let lowRampart = creep.pos.lookInRange(LOOK_STRUCTURES, 3).find(s => s.structureType === STRUCTURE_RAMPART && s.hits < 10000);
        if (creep.pos.roomName !== currentTaskPos.roomName) {
            creep.goTo(currentTaskPos, 1);
        }
        else if (lowRampart && creep.store.energy > 0) {
            creep.repair(lowRampart);
            creep.giveWay({ pos: lowRampart.pos, range: 3 });
        }
        else if (currentTask instanceof ConstructionSite) {
            if (creep.pos.inRangeTo(currentTaskPos, 3)) {
                creep.build(currentTask);
                creep.giveWay({ pos: currentTaskPos, range: 3 });
            }
            else
                creep.goTo(currentTaskPos, 3);
        }
        else if (currentTask instanceof Source) {
            if (creep.pos.inRangeTo(currentTaskPos, 1)) {
                creep.harvest(currentTask);
                creep.giveWay({ pos: currentTaskPos, range: 1 });
            }
            else
                creep.goTo(currentTaskPos, 1);
        }
        else if (currentTask instanceof StructureController) {
            if (currentTask.upgradeBlocked)
                creepMemory.currentTask = undefined;
            if (creep.pos.inRangeTo(currentTaskPos, 3)) {
                creep.upgradeController(currentTask);
                creep.giveWay({ pos: currentTaskPos, range: 3 });
            }
            else
                creep.goTo(currentTaskPos, 3);
        }
        else if (currentTask instanceof Resource) {
            if (creep.pos.inRangeTo(currentTaskPos, 1)) {
                creep.pickup(currentTask);
                creepMemory.currentTask = undefined;
            }
            else
                creep.goTo(currentTaskPos, 1);
        }
        else if ('store' in currentTask) {
            if (creep.pos.inRangeTo(currentTaskPos, 1)) {
                creep.withdraw(currentTask, RESOURCE_ENERGY, Math.min(creep.store.getFreeCapacity(), currentTask.store.energy));
                // avoid being stuck next to mining container
                creepMemory.currentTask = undefined;
                creepMemory.currentTaskPos = undefined;
            }
            else
                creep.goTo(currentTaskPos, 1);
        }
        else if (currentTask instanceof StructureRampart) {
            if (creep.pos.inRangeTo(currentTaskPos, 3)) {
                creep.repair(currentTask);
                creep.giveWay({ pos: currentTaskPos, range: 3 });
            }
            else
                creep.goTo(currentTaskPos, 1);
        }
        else {
            creep.say('???', false);
        }
    }
    onRun() {
        if (_.size(Game.spawns) === 0 && !this.memory.closing) {
            let builder = _.find(Game.creeps, c => c.name.startsWith('Builder') && !this.memory.creeps.includes(c.name));
            if (builder)
                this.memory.creeps.push(builder.name);
        }
        for (let creep of this.creeps)
            if (!creep.spawning)
                this.builderFunc(creep);
    }
}
OperationBuildSupport.OperationType = 'Build';
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationBuildSupport.prototype, "getSpawnRequestsInternal", null);
__decorate([
    profile()
], OperationBuildSupport.prototype, "onRun", null);
class FlagOperationBuildSupport extends OperationBuildSupport {
    constructor(empire, id) {
        super(empire, id);
    }
    init(roomName) {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            closing: false,
            upgradeOnly: false,
            raiseRamparts: false,
            roomName: roomName,
            targetCreepCount: 0
        };
        Memory.flags[this.id] = memory;
    }
    get readyToDelete() {
        return !this.flag || super.readyToDelete;
    }
    deleteMemory() {
        delete Memory.flags[this.id];
    }
    get memory() {
        return Memory.flags[this.id];
    }
    get flag() {
        return Game.flags[this.id];
    }
    get roomName() {
        return this.flag.pos.roomName;
    }
    onInitForTick() {
        super.onInitForTick();
        this.memory.roomName = this.flag.pos.roomName;
        this.memory.targetCreepCount = this.flag.color;
        this.memory.upgradeOnly = this.flag.secondaryColor === COLOR_ORANGE;
        this.memory.raiseRamparts = this.flag.secondaryColor === COLOR_GREY;
    }
}

class OperationHitDuo extends BaseGlobalOperation {
    constructor(empire, id) {
        super(empire, id);
        this.attackerBody = undefined;
        this.healerBody = undefined;
    }
    init(roomName) {
        if (Memory.operations[this.id])
            return;
        let boostTier = 0;
        let attackRoomRcl = 0;
        let roomIntel = GIntel.rooms[roomName];
        if (roomIntel) {
            if (roomIntel.towers <= 1) {
                boostTier = 0;
                attackRoomRcl = 7;
            }
            else if (roomIntel.towers <= 2) {
                boostTier = 1;
                attackRoomRcl = 7;
            }
            else if (roomIntel.towers <= 3) {
                boostTier = 2;
                attackRoomRcl = 8;
            }
            else {
                boostTier = 3;
                attackRoomRcl = 8;
            }
        }
        let operationMemory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            //
            closing: false,
            //
            roomName: roomName,
            boostTier: boostTier,
            attackRoomRcl: attackRoomRcl,
            useTough: false,
            keepStorage: false,
            keepTerminal: false,
            status: 1 /* Status.Rallying */,
            timeout: Game.time + OperationHitDuo.TicksUntilTimeout
        };
        Memory.operations[this.id] = operationMemory;
    }
    close() {
        if (this.status && (this.status !== 1 /* Status.Rallying */ || this.memory.creeps.length === 0))
            super.close();
    }
    get memory() {
        return super.memory;
    }
    get roomName() {
        return this.memory.roomName;
    }
    get status() {
        return this.memory.status;
    }
    onInitForTick() {
        super.onInitForTick();
        this.attacker = this.creeps.find(c => c.memory.role !== 3 /* CreepRole.Healer */);
        this.healer = this.creeps.find(c => c.memory.role === 3 /* CreepRole.Healer */);
        if (!this.attackerBody || this.healerBody) {
            let bodyType = this.memory.attackRoomRcl * 10 + this.memory.boostTier;
            switch (bodyType) {
                case 70:
                    this.attackerBody = new CreepBody('25W25M');
                    this.healerBody = new CreepBody('18M18H');
                    break;
                case 71:
                    this.attackerBody = new CreepBody('32W16M');
                    this.healerBody = new CreepBody('10M20H');
                    break;
                case 72:
                    this.attackerBody = new CreepBody('36W12M');
                    this.healerBody = new CreepBody('7M21H');
                    break;
                case 73:
                    this.attackerBody = new CreepBody('40W10M');
                    this.healerBody = new CreepBody('3T6M21H');
                    break;
                case 80:
                    this.attackerBody = new CreepBody('25W25M');
                    this.healerBody = new CreepBody('25M25H');
                    break;
                case 81:
                    this.attackerBody = new CreepBody('32W16M');
                    this.healerBody = new CreepBody('16M32H');
                    break;
                case 82:
                    this.attackerBody = new CreepBody('36W12M');
                    this.healerBody = new CreepBody('12M36H');
                    break;
                case 83:
                    if (this.memory.useTough) {
                        this.attackerBody = new CreepBody('5T35W10M');
                        this.healerBody = new CreepBody('5T10M35H');
                    }
                    else {
                        this.attackerBody = new CreepBody('40W10M');
                        this.healerBody = new CreepBody('10M40H');
                    }
                    break;
            }
            this.shouldUpdateEstimatedStats = true;
        }
        if (this.memory.targetPos)
            CombatData.attackPointReservations[this.memory.targetPos] = this.id;
    }
    updateEstimatedStats() {
        if (GIntel.rooms[this.roomName] && GIntel.rooms[this.roomName].safeMode) {
            this.estimatedStats.energyPerTick = 0;
            this.estimatedStats.spawnTime = 0;
            this.estimatedStats.baseCpu = 0;
        }
        else {
            this.estimatedStats.energyPerTick = -(this.attackerBody.cost + this.healerBody.cost) / CREEP_LIFE_TIME;
            this.estimatedStats.spawnTime = this.attackerBody.spawnTime + this.healerBody.spawnTime;
            this.estimatedStats.baseCpu = 0.8;
        }
    }
    isValidSpawnRoom(myRoom) {
        const maxCreepCost = Math.max(this.attackerBody.cost, this.healerBody.cost);
        if (myRoom.room.energyCapacityAvailable < maxCreepCost)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME / 3 * 2)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        if (!this.attacker && myRoom.getStoredResource(RES_ENERGY) < this.attackerBody.cost + this.healerBody.cost)
            return false;
        let healBoost = [undefined, RES_LO, RES_LHO2, RES_XLHO2][this.memory.boostTier];
        let dismantleBoost = [undefined, RES_ZH, RES_ZH2O, RES_XZH2O][this.memory.boostTier];
        let moveBoost = [undefined, RES_ZO, RES_ZHO2, RES_XZHO2][this.memory.boostTier];
        if (!this.healer && healBoost && myRoom.getStoredResource(healBoost) < (this.healerBody[BOOST_TO_BODYPART[healBoost]] || 0))
            return false;
        if (!this.attacker && dismantleBoost && myRoom.getStoredResource(dismantleBoost) < (this.healerBody[BOOST_TO_BODYPART[dismantleBoost]] || 0))
            return false;
        const neededMoveBoost = (this.healer ? 0 : this.healerBody[BOOST_TO_BODYPART[moveBoost]] || 0) + (this.attacker ? 0 : this.attackerBody[BOOST_TO_BODYPART[moveBoost]] || 0);
        if (moveBoost && myRoom.getStoredResource(moveBoost) < neededMoveBoost)
            return false;
        return true;
    }
    getSpawnRequestsInternal() {
        if (this.memory.closing)
            return [];
        if (this.memory.status !== 1 /* Status.Rallying */)
            return [];
        if (GIntel.rooms[this.roomName] && GIntel.rooms[this.roomName].safeMode)
            return [];
        let result = [];
        if (!this.attacker) {
            result.push({
                id: generateRandomKey(5),
                nameBase: Config.CreepNames.DuoHead,
                priority: (this.memory.creeps.length === 0 ? FlagSpawnPriority : StartedSquadPriority) + 0.1 * this.memory.creeps.length,
                minEnergy: this.attackerBody.cost,
                parts: this.attackerBody,
                memory: {},
                boostOptions: [[null, [RES_ZH, RES_ZO], [RES_ZH2O, RES_ZHO2], this.memory.useTough ? [RES_XZH2O, RES_XZHO2, RES_XGHO2] : [RES_XZH2O, RES_XZHO2]][this.memory.boostTier]],
                noRepurpose: false,
                operation: this
            });
        }
        if (!this.healer) {
            result.push({
                id: generateRandomKey(5),
                nameBase: Config.CreepNames.DuoTail,
                priority: (this.memory.creeps.length === 0 ? FlagSpawnPriority : StartedSquadPriority) + 0.1 * this.memory.creeps.length,
                minEnergy: this.healerBody.cost,
                parts: this.healerBody,
                memory: {
                    role: 3 /* CreepRole.Healer */
                },
                boostOptions: [[null, [RES_LO, RES_ZO], [RES_LHO2, RES_ZHO2], this.memory.useTough ? [RES_XLHO2, RES_XZHO2, RES_XGHO2] : [RES_XLHO2, RES_XZHO2]][this.memory.boostTier]],
                noRepurpose: false,
                operation: this
            });
        }
        return result;
    }
    rally() {
        if (this.attacker) {
            if (this.attacker.memory.boosts) {
                this.boostCreep(this.attacker);
            }
            else if (this.attacker.pos.x !== 1 && this.attacker.pos.x !== 48 && this.attacker.pos.y !== 1 && this.attacker.pos.y !== 48) {
                const travelOpts = {
                    avoidSourceKeepers: false,
                    ignoreRoads: true,
                    ensurePath: true,
                    avoidUnsafeRooms: false
                };
                this.attacker.goTo(new RoomPosition(25, 25, this.roomName), 23, travelOpts);
            }
            else {
                this.attacker.giveWay();
            }
        }
        if (this.healer) {
            if (this.healer.memory.boosts)
                this.boostCreep(this.healer);
            else if (this.attacker && !this.attacker.pos.isNearTo(this.healer.pos))
                this.healer.goTo(this.attacker.pos, 1);
            else
                this.healer.giveWay();
        }
        if (this.attacker && !this.attacker.memory.boosts && this.healer && !this.healer.memory.boosts && this.attacker.pos.isNearTo(this.healer.pos)) {
            this.memory.status = 2 /* Status.Moving */;
        }
    }
    move() {
        const travelOpts = {
            avoidSourceKeepers: false,
            ignoreRoads: true,
            ensurePath: true,
            avoidUnsafeRooms: false
        };
        Pather.sneakGoTo(this.creeps, new RoomPosition(25, 25, this.roomName), 23, travelOpts);
        for (let creep of this.creeps)
            creep.shootAtWill(creep.room.findHostileCreeps());
        if (this.creeps[0].pos.roomName === this.roomName && !this.creeps[0].pos.isExit())
            this.memory.status = 3 /* Status.Attacking */;
    }
    findNewTarget(squadPos) {
        let visual = new RoomVisual(this.roomName);
        visual.text('\u{1F50D}', this.creeps[0].pos.x + 0.5, this.creeps[0].pos.y + 0.5, { align: 'center', opacity: 0.5 });
        let attackPoints = CombatData.getAttackPoints(this.roomName, this.memory.keepStorage, this.memory.keepTerminal);
        if (!attackPoints)
            return undefined;
        let towerDamage = CombatData.getTowerPower(this.roomName);
        let creepDamage = CombatData.getHostileCreepInfluence(this.roomName);
        let squadHeal = _.sum(this.creeps, c => getBodypartPower(HEAL, c) * HEAL_POWER);
        const check2x2 = this.creeps.length > 2;
        let terrain = Game.map.getRoomTerrain(this.roomName);
        const CHECKED_TILE = 1;
        const APPROVED_TILE = 2;
        let checked = new Uint8Array(2500);
        let nodes = [squadPos.y * 50 + squadPos.x];
        while (nodes.length > 0) {
            let node = nodes.shift();
            let nodeX = node % 50;
            let nodeY = Math.floor(node / 50);
            for (let dir in Common.offset) {
                const o = Common.offset[dir];
                let newX = nodeX + o.x;
                let newY = nodeY + o.y;
                let index = newY * 50 + newX;
                if (newX < 0 || newX > 49 || newY < 0 || newY > 49)
                    continue;
                if (checked[index])
                    continue;
                checked[index] = CHECKED_TILE;
                if (this.room.lookForAt(LOOK_STRUCTURES, newX, newY).find(s => s.isBuildable() && (s.isObstacle() || s.structureType === STRUCTURE_RAMPART)))
                    continue;
                if ((creepDamage && creepDamage[index] || 0) + (towerDamage && towerDamage[index] || 0) >= squadHeal)
                    continue;
                if ((terrain.get(newX, newY) & TERRAIN_MASK_WALL) > 0)
                    continue;
                if (check2x2) {
                    if (newX < 49 && (creepDamage && creepDamage[index + 1] || 0) + (towerDamage && towerDamage[index + 1] || 0) >= squadHeal
                        || newY < 49 && (creepDamage && creepDamage[index + 50] || 0) + (towerDamage && towerDamage[index + 50] || 0) >= squadHeal
                        || newX < 49 && newY < 49 && (creepDamage && creepDamage[index + 51] || 0) + (towerDamage && towerDamage[index + 51] || 0) >= squadHeal) {
                        continue;
                    }
                    if (newX < 49 && this.room.lookForAt(LOOK_STRUCTURES, newX + 1, newY).find(s => s.isBuildable() && (s.isObstacle() || s.structureType === STRUCTURE_RAMPART))
                        || newY < 49 && this.room.lookForAt(LOOK_STRUCTURES, newX, newY + 1).find(s => s.isBuildable() && (s.isObstacle() || s.structureType === STRUCTURE_RAMPART))
                        || newX < 49 && newY < 49 && this.room.lookForAt(LOOK_STRUCTURES, newX + 1, newY + 1).find(s => s.isBuildable() && (s.isObstacle() || s.structureType === STRUCTURE_RAMPART))) {
                        continue;
                    }
                    if (newX < 49 && (terrain.get(newX + 1, newY) & TERRAIN_MASK_WALL) > 0
                        || newY < 49 && (terrain.get(newX, newY + 1) & TERRAIN_MASK_WALL) > 0
                        || newX < 49 && newY < 49 && (terrain.get(newX + 1, newY + 1) & TERRAIN_MASK_WALL) > 0) {
                        continue;
                    }
                }
                checked[index] = APPROVED_TILE;
                nodes.push(newY * 50 + newX);
            }
        }
        let filteredAttackPoints = attackPoints.filter(ap => {
            if (!ap.melee)
                return false;
            if (this.creeps.length > 2 && !ap.canFitQuad)
                return false;
            if (checked[ap.pos.y * 50 + ap.pos.x] !== APPROVED_TILE)
                return false;
            if (_.some(CombatData.attackPointReservations, (value, key) => value !== this.id && RoomPosition.deserialize(key).inRangeTo(ap.pos, 2)))
                return false;
            return true;
        });
        let result = undefined;
        if (filteredAttackPoints.length > 0) {
            // go for closest
            if (_.random(0, 1) === 0) {
                filteredAttackPoints.sort((a, b) => a.pos.getRangeTo(squadPos) - b.pos.getRangeTo(squadPos));
            }
            // go for highest dps
            else {
                filteredAttackPoints.sort((a, b) => b.melee - a.melee);
            }
            let top10 = filteredAttackPoints.slice(0, 10);
            // we don't care about 3 steps difference
            let closest = _.min(top10, ap => {
                let searchResult = Pather.findPath(squadPos, { pos: ap.pos, range: 0 });
                if (searchResult.incomplete)
                    return Infinity;
                else
                    return Math.floor(searchResult.path.length / 3);
            });
            //let searchResult = Pather.findPathToClosest(squadPos, top10.map(ap => ({ pos: ap.pos, range: 0 })).value());
            //let closest = top10.find(ap => ap.pos.isEqualTo(searchResult.path.length > 0 ? _.last(searchResult.path) : squadPos));
            let highestValue = _.max(top10, ap => ap.melee);
            if (highestValue.melee > closest.melee * 3)
                result = highestValue.pos;
            else
                result = closest.pos;
        }
        if (result)
            CombatData.attackPointReservations[result.serialize()] = this.id;
        return result;
    }
    attack() {
        if (!this.attacker) {
            this.abort();
            return;
        }
        // changing target if needed
        let attackPoints = CombatData.getAttackPoints(this.roomName, this.memory.keepStorage, this.memory.keepTerminal);
        let towerDamageMatrix = CombatData.getTowerPower(this.roomName);
        let towerDamage = _(this.creeps).map(c => towerDamageMatrix[c.pos.y * 50 + c.pos.x]).max();
        let creepDamageMatrix = CombatData.getHostileCreepInfluence(this.roomName);
        let creepDamage = this.room ? _.sum(this.creeps, c => creepDamageMatrix[c.pos.y * 50 + c.pos.x]) : 0;
        let squadHeal = _.sum(this.creeps, c => getBodypartPower(HEAL, c) * HEAL_POWER);
        let shouldReposition = (towerDamage + creepDamage > squadHeal);
        let shouldChangeTarget;
        let targetPos = this.memory.targetPos && RoomPosition.deserialize(this.memory.targetPos);
        if (targetPos) {
            let targetPosIndex = targetPos.y * 50 + targetPos.x;
            shouldChangeTarget = (towerDamageMatrix && towerDamageMatrix[targetPosIndex] || 0) + (creepDamageMatrix && creepDamageMatrix[targetPosIndex] || 0) > squadHeal;
        }
        else {
            shouldChangeTarget = true;
        }
        let noAttackPointsTargetChange = targetPos && attackPoints && !attackPoints.some(ap => ap.melee && ap.pos.isEqualTo(targetPos));
        let randomTargetChange = targetPos && targetPos.isEqualTo(this.creeps[0].pos) && _.random(0, 19) === 0;
        let destroyedSomething = targetPos && Game.rooms[targetPos.roomName] && targetPos.lookInRange(LOOK_RUINS, 1).find(r => r.ticksToDecay === RUIN_DECAY - 5);
        if (shouldChangeTarget || shouldReposition || noAttackPointsTargetChange || destroyedSomething) {
            let creepInRoom = this.creeps.find(c => c.pos.roomName === this.roomName);
            if (creepInRoom) {
                targetPos = this.findNewTarget(creepInRoom.pos);
                if (targetPos)
                    this.memory.targetPos = targetPos.serialize();
            }
        }
        else if (randomTargetChange) {
            let creepInRoom = this.creeps.find(c => c.pos.roomName === this.roomName);
            if (creepInRoom) {
                targetPos = this.findNewTarget(creepInRoom.pos);
                if (targetPos) // && targetPos.inRangeTo(this.attacker.pos, 4))
                    this.memory.targetPos = targetPos.serialize();
            }
        }
        //
        if (targetPos === undefined) {
            let goToRoomOpts = {
                squadMembers: this.creeps.slice(1),
                avoidNarrowPaths: this.creeps.length > 2,
                avoidDamage: squadHeal
            };
            if (this.attacker.pos.roomName === this.roomName)
                this.retreat();
            else
                CombatPather.goTo(this.attacker, new RoomPosition(25, 25, this.roomName), 22, goToRoomOpts);
        }
        else {
            let opts = {
                dontIgnoreCreeps: true,
                squadMembers: this.healer ? [this.healer] : [],
                avoidNarrowPaths: this.creeps.length > 2,
                //maxRooms: 6,
                avoidDamage: squadHeal,
                avoidDamageMargin: 1,
                debug: true
            };
            let hits = _.sum(this.creeps, c => c.hits);
            let lastHits = this.memory.lastHits || 0;
            if (this.creeps.some(c => c.pos.isExit()) || hits >= lastHits) {
                CombatPather.goTo(this.attacker, targetPos, 0, opts);
            }
            if (targetPos) {
                let visual = Common.getRoomVisual(targetPos.roomName);
                visual.multiRoomLine(this.attacker.pos, targetPos, { color: '#ff0000', lineStyle: 'dotted', opacity: 0.75, width: 0.1 });
                visual.text('❌', targetPos, {});
            }
            this.memory.lastHits = hits;
        }
        //
        let targets = {};
        for (let creep of this.creeps) {
            if (!targets[creep.pos.roomName]) {
                const roomIntel = GIntel.rooms[creep.pos.roomName];
                targets[creep.pos.roomName] = (roomIntel && roomIntel.isFriendly)
                    ? []
                    : creep.room.find(FIND_STRUCTURES, {
                        filter: s => {
                            if (!s.isBuildable())
                                return false;
                            if (this.memory.keepStorage && s.structureType === STRUCTURE_STORAGE)
                                return false;
                            if (this.memory.keepTerminal && s.structureType === STRUCTURE_TERMINAL)
                                return false;
                            return true;
                        }
                    });
            }
            let closestTarget = _.min(targets[creep.pos.roomName], t => t.pos.isNearTo(creep.pos) ? t.hits : Infinity);
            creep.dismantle(closestTarget);
        }
    }
    retreat() {
        let leader = this.creeps[0];
        let squadHeal = _.sum(this.creeps, c => getBodypartPower(HEAL, c) * HEAL_POWER);
        let retreatOpts = {
            dontIgnoreCreeps: true,
            squadMembers: this.creeps.slice(1),
            avoidNarrowPaths: this.creeps.length > 2,
            avoidDamage: squadHeal,
            avoidDamageMargin: 1,
            debug: true
        };
        let fleeRoom;
        if (leader.pos.roomName === this.roomName) {
            let closestExit;
            if (leader.pos.isExit())
                closestExit = leader.pos;
            else {
                let pathToClosestExit = Pather.findPathToClosest(leader.pos, Common.getExitTiles(leader.pos.roomName).map(e => ({ pos: e, range: 0 })), {
                    dontIgnoreCreeps: false
                });
                closestExit = _.last(pathToClosestExit.path);
            }
            let exitDir;
            if (closestExit.x === 0)
                exitDir = LEFT;
            else if (closestExit.x === 49)
                exitDir = RIGHT;
            else if (closestExit.y === 0)
                exitDir = TOP;
            else
                exitDir = BOTTOM;
            fleeRoom = Common.getNextRoom(this.roomName, exitDir);
        }
        else
            fleeRoom = leader.pos.roomName;
        let hits = _.sum(this.creeps, c => c.hits);
        let lastHits = this.memory.lastHits || 0;
        if (hits <= lastHits || leader.pos.lookInRange(LOOK_CREEPS, 5).find(h => !h.my))
            CombatPather.goTo(leader, new RoomPosition(25, 25, fleeRoom), 22, retreatOpts);
        this.memory.lastHits = hits;
        let hostiles = leader.room.findHostileCreeps().filter(h => !h.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_RAMPART));
        let structures = leader.room.intel.isFriendly
            ? []
            : leader.room.find(FIND_STRUCTURES, { filter: s => s.isBuildable() });
        let allTargets = [...hostiles, ...structures];
        for (let creep of this.creeps) {
            let unsafeHostileInRange = hostiles.find(h => h.pos.inRangeTo(creep, 3) && !h.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_RAMPART));
            creep.shootAtWill(allTargets, unsafeHostileInRange);
        }
    }
    heal() {
        if (this.creeps.length === 0)
            return;
        let potentialDamage = this.creeps.map(c => {
            const roomIntel = GIntel.rooms[c.pos.roomName];
            const damageWeight = 2;
            const potentialDamageWeight = 1;
            let towerDamageMatrix = !roomIntel.isFriendly && CombatData.getTowerPower(c.pos.roomName);
            let creepDamageMatrix = CombatData.getHostileCreepDamage(c.pos.roomName);
            let hitsMax = c.hitsMax + _.sum(c.body, bp => bp.type === TOUGH ? 100 / getBodypartBoostMod(bp) - 100 : 0);
            let hits = c.hits + _.sum(c.body, bp => bp.type === TOUGH ? bp.hits / getBodypartBoostMod(bp) - bp.hits : 0);
            let result = damageWeight * (hitsMax - hits);
            result += potentialDamageWeight * (towerDamageMatrix && towerDamageMatrix[c.pos.y * 50 + c.pos.x] || 0);
            result += potentialDamageWeight * (creepDamageMatrix && creepDamageMatrix[c.pos.y * 50 + c.pos.x] || 0);
            return {
                creep: c,
                damage: result
            };
        });
        for (let creep of this.creeps) {
            let mostDamaged = _(potentialDamage)
                .filter(v => v.creep.pos.isNearTo(creep.pos))
                .max(v => v.damage);
            creep.heal(mostDamaged.creep);
            mostDamaged.damage -= getBodypartPower(HEAL, creep) * HEAL_POWER;
        }
    }
    onRun() {
        if (Game.time > this.memory.timeout && this.creeps.length === 0) {
            this.abort();
            return;
        }
        if (this.creeps.length === 0)
            this.memory.status = 1 /* Status.Rallying */;
        //
        if (this.memory.lastCreepCount && this.memory.lastCreepCount > this.creeps.length)
            this.memory.closing = true;
        this.memory.lastCreepCount = this.creeps.length;
        if (this.memory.status === 3 /* Status.Attacking */ && this.creeps.some(c => !c.pos.isExit() && c.hits < c.hitsMax - 600 || c.hits < c.hitsMax - 1200))
            this.memory.status = 4 /* Status.Retreating */;
        if (this.memory.status === 3 /* Status.Attacking */ && GIntel.rooms[this.roomName] && GIntel.rooms[this.roomName].safeMode)
            this.memory.status = 4 /* Status.Retreating */;
        if (this.memory.status === 4 /* Status.Retreating */ && this.creeps.every(c => c.hits > c.hitsMax - 100))
            this.memory.status = 3 /* Status.Attacking */;
        if (this.memory.status === 4 /* Status.Retreating */)
            this.retreat();
        else if (this.memory.status === 1 /* Status.Rallying */)
            this.rally();
        else if (this.memory.status === 2 /* Status.Moving */)
            this.move();
        else if (this.memory.status === 3 /* Status.Attacking */)
            this.attack();
        this.heal();
    }
}
OperationHitDuo.OperationType = 'HitDuo';
OperationHitDuo.TicksUntilTimeout = 1500;
__decorate([
    profile()
], OperationHitDuo.prototype, "onInitForTick", null);
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationHitDuo.prototype, "getSpawnRequestsInternal", null);
__decorate([
    profile()
], OperationHitDuo.prototype, "findNewTarget", null);
__decorate([
    profile()
], OperationHitDuo.prototype, "attack", null);
__decorate([
    profile()
], OperationHitDuo.prototype, "retreat", null);
__decorate([
    profile()
], OperationHitDuo.prototype, "onRun", null);
class FlagOperationHitDuo extends OperationHitDuo {
    constructor(empire, id) {
        super(empire, id);
    }
    init(roomName) {
        if (Memory.flags[this.id])
            return;
        let operationMemory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            //
            closing: false,
            //
            roomName: roomName,
            boostTier: Math.floor((Math.min(this.flag.color, COLOR_BROWN) - 1) / 2) % 4,
            attackRoomRcl: ((Math.min(this.flag.color, COLOR_BROWN) - 1) % 2 === 0) ? 7 : 8,
            useTough: this.flag.color === COLOR_GREY,
            keepStorage: this.flag.secondaryColor >= COLOR_GREY,
            keepTerminal: this.flag.secondaryColor >= COLOR_WHITE,
            status: 1 /* Status.Rallying */,
            timeout: Game.time + OperationHitDuo.TicksUntilTimeout
        };
        Memory.flags[this.id] = operationMemory;
    }
    get memory() {
        return Memory.flags[this.id];
    }
    get roomName() {
        return this.flag.pos.roomName;
    }
    get readyToDelete() {
        return !this.flag || super.readyToDelete;
    }
    get flag() {
        return Game.flags[this.id];
    }
    deleteMemory() {
        delete Memory.flags[this.id];
    }
    onInitForTick() {
        super.onInitForTick();
        this.memory.roomName = this.flag.pos.roomName;
        if (this.flag.secondaryColor !== COLOR_RED) {
            this.memory.keepStorage = this.flag.secondaryColor >= COLOR_GREY;
            this.memory.keepTerminal = this.flag.secondaryColor >= COLOR_WHITE;
        }
    }
}

class OperationGuard extends BaseGlobalOperation {
    constructor(empire, id) {
        super(empire, id);
    }
    init(roomName) {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            closing: false,
            roomName: roomName
        };
        Memory.operations[this.id] = memory;
    }
    get memory() {
        return super.memory;
    }
    get room() {
        return Game.rooms[this.roomName];
    }
    get roomName() {
        return this.memory.roomName;
    }
    updateEstimatedStats() {
        if (this.composition) {
            this.estimatedStats.energyPerTick = 0;
            this.estimatedStats.spawnTime = 0;
            this.estimatedStats.baseCpu = 0;
        }
        else {
            // TODO
            this.estimatedStats.energyPerTick = 0;
            this.estimatedStats.spawnTime = 0;
            this.estimatedStats.baseCpu = 0.2 * (this.composition
                ? (this.composition.rangerCount + this.composition.meleeCount + this.composition.healerCount)
                : 3);
        }
    }
    updateLastAttack() {
        if (!this.room)
            return;
        let hostiles = this.room.findHostileCreeps().filter(h => {
            if (h.owner.username === 'Invader' || h.owner.username === 'Source Keeper')
                return false;
            if (!h.body.some(bp => bp.type === WORK || bp.type === ATTACK || bp.type === RANGED_ATTACK || bp.type === HEAL || bp.type === CLAIM))
                return false;
            return true;
        });
        let currentAttack = {
            creepCost: 0,
            creepCount: hostiles.length,
            workPower: 0,
            meleePower: 0,
            rangedPower: 0,
            healPower: 0,
            maxWorkPower: 0,
            maxMeleePower: 0,
            maxRangedPower: 0,
            maxHealPower: 0,
            toughPower: 1,
            maxToughPerCreep: 0,
            time: Game.time
        };
        for (let h of hostiles) {
            if (h.pos.isExit() || h.room.memory.portals && h.room.memory.portals.find(p => p.pos === h.pos.serialize()))
                this.memory.mostRecentExit = h.pos.serialize();
            let toughParts = 0;
            let workPower = 0;
            let meleePower = 0;
            let rangedPower = 0;
            let healPower = 0;
            for (let b of h.body) {
                if (b.type === WORK)
                    workPower += b.boost && (b.boost === 'ZH' || b.boost === 'ZH2O' || b.boost === 'XZH2O') && BOOSTS[b.type][b.boost].dismantle || 1;
                if (b.type === ATTACK)
                    meleePower += b.boost && BOOSTS[b.type][b.boost].attack || 1;
                if (b.type === RANGED_ATTACK)
                    rangedPower += b.boost && BOOSTS[b.type][b.boost].rangedAttack || 1;
                if (b.type === HEAL)
                    healPower += b.boost && BOOSTS[b.type][b.boost].heal || 1;
                if (b.type === TOUGH) {
                    ++toughParts;
                    currentAttack.toughPower = Math.min(currentAttack.toughPower, b.boost && BOOSTS.tough[b.boost].damage || 1);
                }
            }
            currentAttack.maxToughPerCreep = Math.max(currentAttack.maxToughPerCreep, toughParts);
            if (meleePower > 0 || rangedPower > 0 || healPower > 0) {
                let creepCost = 0;
                for (let b of h.body)
                    creepCost += BODYPART_COST[b.type];
                currentAttack.creepCost = Math.max(currentAttack.creepCost, creepCost);
            }
            currentAttack.workPower += workPower;
            currentAttack.meleePower += meleePower;
            currentAttack.rangedPower += rangedPower;
            currentAttack.healPower += healPower;
            currentAttack.maxWorkPower = Math.max(currentAttack.maxWorkPower, workPower);
            currentAttack.maxMeleePower = Math.max(currentAttack.maxMeleePower, meleePower);
            currentAttack.maxRangedPower = Math.max(currentAttack.maxRangedPower, rangedPower);
            currentAttack.maxHealPower = Math.max(currentAttack.maxHealPower, healPower);
        }
        if (!this.memory.lastAttack
            || currentAttack.creepCost > (this.memory.lastAttack.creepCost || 0)
            || currentAttack.workPower > this.memory.lastAttack.workPower
            || currentAttack.meleePower > this.memory.lastAttack.meleePower
            || currentAttack.rangedPower > this.memory.lastAttack.rangedPower
            || currentAttack.healPower > this.memory.lastAttack.healPower
            || currentAttack.creepCount > this.memory.lastAttack.creepCount
            || Game.time - this.memory.lastAttack.time > 3000) {
            this.memory.lastAttack = currentAttack;
        }
    }
    updateComposition() {
        if (!this.memory.lastAttack) {
            let energyCapacityAvailable = this.spawnRoom && this.spawnRoom.energyCapacityAvailable || 300;
            let rangerSize = Math.min(25, Math.floor(energyCapacityAvailable / (BODYPART_COST[RANGED_ATTACK] + BODYPART_COST[MOVE])));
            let meleeSize = Math.min(25, Math.floor(energyCapacityAvailable / (BODYPART_COST[ATTACK] + BODYPART_COST[MOVE])));
            let healerSize = Math.min(25, Math.floor(energyCapacityAvailable / (BODYPART_COST[HEAL] + BODYPART_COST[MOVE])));
            this.composition = {
                creepCost: energyCapacityAvailable,
                tier: 0,
                rangerBody: new CreepBody(`${rangerSize}R${rangerSize}M`),
                rangerCount: 1,
                healerBody: new CreepBody(`${healerSize}M${healerSize}H`),
                healerCount: 1,
                meleeBody: new CreepBody(`${meleeSize}A${meleeSize}M`),
                meleeCount: 1,
                lastUpdate: Game.time
            };
            this.shouldUpdateEstimatedStats = true;
        }
        else if (!this.composition || this.memory.lastAttack.time !== this.composition.lastUpdate) {
            //  damage to nullify perfect healing on toughest hostile
            const minimumDamage = Math.min(this.memory.lastAttack.healPower * HEAL_POWER, 4 * this.memory.lastAttack.maxHealPower * HEAL_POWER) / this.memory.lastAttack.toughPower;
            const towerDamage = (this.room && this.room.myRoom) ? this.room.myRoom.layout.towers.length * 150 : 0;
            const maxCreepCount = 2;
            let targetCreepDamage = Math.min(this.memory.lastAttack.meleePower, 2 * this.memory.lastAttack.maxMeleePower) * ATTACK_POWER
                + this.memory.lastAttack.rangedPower * RANGED_ATTACK_POWER
                + (minimumDamage - towerDamage);
            targetCreepDamage *= 1.5;
            let creepCost = [300, 300, 550, 800, 1300, 1800, 2300, 5600, 12900].find(cost => cost >= this.memory.lastAttack.creepCost);
            let bodyProportions = [
                { part: 1, move: 1 },
                { part: 2, move: 1 },
                { part: 3, move: 1 },
                { part: 4, move: 1 }
            ];
            let boostMultipliers = {
                ranged: [1, BOOSTS.ranged_attack.KO.rangedAttack, BOOSTS.ranged_attack.KHO2.rangedAttack, BOOSTS.ranged_attack.XKHO2.rangedAttack],
                healer: [1, BOOSTS.heal.LO.heal, BOOSTS.heal.LHO2.heal, BOOSTS.heal.XLHO2.heal],
                melee: [1, BOOSTS.attack.UH.attack, BOOSTS.attack.UH2O.attack, BOOSTS.attack.XUH2O.attack]
            };
            const maxTier = 1; //3;
            for (let tier = 0; tier <= maxTier; ++tier) {
                let maxSize = Math.floor(50 / (bodyProportions[tier].part + bodyProportions[tier].move));
                let rangerSize = Math.min(maxSize, Math.floor(creepCost / (BODYPART_COST[RANGED_ATTACK] * bodyProportions[tier].part + BODYPART_COST[MOVE] * bodyProportions[tier].move)));
                let meleeSize = Math.min(maxSize, Math.floor(creepCost / (BODYPART_COST[ATTACK] * bodyProportions[tier].part + BODYPART_COST[MOVE] * bodyProportions[tier].move)));
                let healerSize = Math.min(maxSize, Math.floor(creepCost / (BODYPART_COST[HEAL] * bodyProportions[tier].part + BODYPART_COST[MOVE] * bodyProportions[tier].move)));
                let creepDamage = RANGED_ATTACK_POWER * rangerSize * bodyProportions[tier].part * boostMultipliers.ranged[tier]
                    + ATTACK_POWER * meleeSize * bodyProportions[tier].part * boostMultipliers.melee[tier]
                    + HEAL_POWER * healerSize * bodyProportions[tier].part * boostMultipliers.healer[tier];
                if (creepDamage * maxCreepCount >= targetCreepDamage) {
                    let triosCount = creepDamage === 0 ? 0 : Math.ceil((targetCreepDamage || 1) / creepDamage);
                    if (!this.composition
                        || rangerSize * bodyProportions[tier].part !== this.composition.rangerBody[RANGED_ATTACK]
                        || meleeSize * bodyProportions[tier].part !== this.composition.meleeBody[ATTACK]
                        || healerSize * bodyProportions[tier].part !== this.composition.healerBody[HEAL]
                        || triosCount !== this.composition.rangerCount
                        || tier !== this.composition.tier) {
                        let oldComposition = this.composition;
                        this.rallyPos = undefined;
                        this.composition = {
                            creepCost: creepCost,
                            tier: tier,
                            rangerBody: new CreepBody(`${rangerSize * bodyProportions[tier].part}R${rangerSize * bodyProportions[tier].move}M`),
                            rangerCount: triosCount,
                            healerBody: new CreepBody(`${healerSize * bodyProportions[tier].move}M${healerSize * bodyProportions[tier].part}H`),
                            healerCount: triosCount,
                            meleeBody: new CreepBody(`${meleeSize * bodyProportions[tier].part}A${meleeSize * bodyProportions[tier].move}M`),
                            meleeCount: triosCount,
                            lastUpdate: Game.time
                        };
                        this.shouldUpdateEstimatedStats = true;
                        console.log(this.id, 'composition changed<br/>oldComposition:', JSON.stringify(oldComposition), '<br/>newComposition:', JSON.stringify(this.composition));
                    }
                    break;
                }
            }
        }
    }
    updateRally(roomName, rallySize) {
        let room = Game.rooms[roomName];
        if (!room) {
            return undefined;
        }
        let POI = this.memory.mostRecentExit
            ? RoomPosition.deserialize(this.memory.mostRecentExit)
            : room.myRoom
                ? room.myRoom.layout.roomPlan.pos
                : new RoomPosition(25, 25, roomName);
        let foundRally = Common.findRally(room, rallySize * rallySize, POI, this.creeps);
        if (foundRally)
            return new RoomPosition(foundRally.x + (rallySize - 1) / 2, foundRally.y + (rallySize - 1) / 2, foundRally.roomName);
        else
            return undefined;
    }
    updateCombatData() {
        let hostiles = this.room ? this.room.findHostileCreeps().filter(h => h.owner.username !== 'Source Keeper') : [];
        this.memory.target = hostiles.length > 0 ? _.min(hostiles, h => h.hits / h.hitsMax).pos.serialize() : this.memory.mostRecentExit;
    }
    isValidSpawnRoom(myRoom) {
        if (!this.composition)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME / 2)
            return false;
        if (myRoom.room.energyCapacityAvailable < this.composition.creepCost)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        if (!this.composition)
            return false;
        let resourcesNeeded = {
            energy: this.composition.healerCount * this.composition.healerBody.cost
                + this.composition.rangerCount * this.composition.rangerBody.cost
                + this.composition.meleeCount * this.composition.meleeBody.cost
        };
        if (this.composition.tier === 1) {
            resourcesNeeded.KO = this.composition.rangerCount * this.composition.rangerBody[RANGED_ATTACK] * LAB_BOOST_MINERAL;
            resourcesNeeded.LO = this.composition.healerCount * this.composition.healerBody[HEAL] * LAB_BOOST_MINERAL;
            resourcesNeeded.UH = this.composition.meleeCount * this.composition.meleeBody[ATTACK] * LAB_BOOST_MINERAL;
            resourcesNeeded.ZO = this.composition.rangerCount * this.composition.rangerBody[MOVE] * LAB_BOOST_MINERAL
                + this.composition.healerCount * this.composition.healerBody[MOVE] * LAB_BOOST_MINERAL
                + this.composition.meleeCount * this.composition.meleeBody[MOVE] * LAB_BOOST_MINERAL;
        }
        else if (this.composition.tier === 2) {
            resourcesNeeded.KHO2 = this.composition.rangerCount * this.composition.rangerBody[RANGED_ATTACK] * LAB_BOOST_MINERAL;
            resourcesNeeded.LHO2 = this.composition.healerCount * this.composition.healerBody[HEAL] * LAB_BOOST_MINERAL;
            resourcesNeeded.UH2O = this.composition.meleeCount * this.composition.meleeBody[ATTACK] * LAB_BOOST_MINERAL;
            resourcesNeeded.ZHO2 = this.composition.rangerCount * this.composition.rangerBody[MOVE] * LAB_BOOST_MINERAL
                + this.composition.healerCount * this.composition.healerBody[MOVE] * LAB_BOOST_MINERAL
                + this.composition.meleeCount * this.composition.meleeBody[MOVE] * LAB_BOOST_MINERAL;
        }
        else if (this.composition.tier === 3) {
            resourcesNeeded.XKHO2 = this.composition.rangerCount * this.composition.rangerBody[RANGED_ATTACK] * LAB_BOOST_MINERAL;
            resourcesNeeded.XLHO2 = this.composition.healerCount * this.composition.healerBody[HEAL] * LAB_BOOST_MINERAL;
            resourcesNeeded.XUH2O = this.composition.meleeCount * this.composition.meleeBody[ATTACK] * LAB_BOOST_MINERAL;
            resourcesNeeded.XZHO2 = this.composition.rangerCount * this.composition.rangerBody[MOVE] * LAB_BOOST_MINERAL
                + this.composition.healerCount * this.composition.healerBody[MOVE] * LAB_BOOST_MINERAL
                + this.composition.meleeCount * this.composition.meleeBody[MOVE] * LAB_BOOST_MINERAL;
        }
        for (let resourceType in resourcesNeeded) {
            let needed = resourcesNeeded[resourceType];
            let storedResource = (myRoom.layout.storage && myRoom.layout.storage.store[resourceType] || 0) + (myRoom.layout.terminal && myRoom.layout.terminal.store[resourceType] || 0);
            if (storedResource < needed)
                return false;
        }
        return true;
    }
    onAssignSpawnRoom() {
        // without this check updateComposition will check for room.myRoom, which checks for GEmpire, which doesn't exist when onAssignSpawnRoom is called during constructor
        if (!this.memory.lastAttack)
            this.updateComposition();
    }
    getSpawnRequestsInternal() {
        if (!this.composition)
            return [];
        if (this.memory.closing)
            return [];
        let roomIntel = GIntel.rooms[this.roomName];
        if (roomIntel && roomIntel.safeMode && roomIntel.safeMode - Game.time > CREEP_LIFE_TIME / 2)
            return [];
        const tier = this.composition.tier;
        let boostOptions = {
            ranged: [
                [null],
                [[RES_KO, RES_ZO]],
                [[RES_KHO2, RES_ZHO2]],
                [[RES_XKHO2, RES_XZHO2]]
            ][tier],
            melee: [
                [null],
                [[RES_UH, RES_ZO]],
                [[RES_UH2O, RES_ZHO2]],
                [[RES_XUH2O, RES_XZHO2]]
            ][tier],
            heal: [
                [null],
                [[RES_LO, RES_ZO]],
                [[RES_LHO2, RES_ZHO2]],
                [[RES_XLHO2, RES_XZHO2]]
            ][tier]
        };
        const walkDistance = Game.map.getRoomLinearDistance(this.roomName, this.spawnRoomName) * 50;
        let result = [];
        let activeGuards = this.creeps.filter(c => c.memory.state !== 3 /* GuardStatus.Guard */ || (c.ticksToLive || Infinity) > walkDistance + this.composition.meleeBody.spawnTime);
        let rangersNeeded = this.composition.rangerCount - _.sum(activeGuards, c => c.body.find(b => b.type === RANGED_ATTACK) ? 1 : 0);
        const rallyingCreepsCount = _.sum(this.creeps, c => c.memory.state === 0 /* GuardStatus.Boost */ || c.memory.state === 1 /* GuardStatus.SafeRally */ ? 1 : 0);
        const spawnPriority = rallyingCreepsCount > 0 ? StartedSquadPriority : (FlagSpawnPriority + 1);
        for (let i = 0; i < rangersNeeded; ++i) {
            result.push({
                id: generateRandomKey(5),
                nameBase: Config.CreepNames.Guard,
                priority: spawnPriority,
                minEnergy: this.composition.rangerBody.cost,
                parts: this.composition.rangerBody,
                memory: {
                    state: 0 /* GuardStatus.Boost */
                },
                boostOptions: boostOptions.ranged,
                noRepurpose: false,
                operation: this
            });
        }
        let meleesNeeded = this.composition.meleeCount - _.sum(activeGuards, c => c.body.find(b => b.type === ATTACK) ? 1 : 0);
        for (let i = 0; i < meleesNeeded; ++i) {
            result.push({
                id: generateRandomKey(5),
                nameBase: Config.CreepNames.Guard,
                priority: spawnPriority,
                minEnergy: this.composition.meleeBody.cost,
                parts: this.composition.meleeBody,
                memory: {
                    state: 0 /* GuardStatus.Boost */
                },
                boostOptions: boostOptions.melee,
                noRepurpose: false,
                operation: this
            });
        }
        let healersNeeded = this.composition.healerCount - _.sum(activeGuards, c => c.body.find(b => b.type === HEAL) ? 1 : 0);
        for (let i = 0; i < healersNeeded; ++i) {
            result.push({
                id: generateRandomKey(5),
                nameBase: 'Medic',
                priority: spawnPriority,
                minEnergy: this.composition.healerBody.cost,
                parts: this.composition.healerBody,
                memory: {
                    state: 0 /* GuardStatus.Boost */
                },
                boostOptions: boostOptions.heal,
                noRepurpose: false,
                operation: this
            });
        }
        return result;
    }
    boost(creep) {
        let creepMemory = creep.memory;
        if (!creepMemory.boosts) {
            creepMemory.state = 1 /* GuardStatus.SafeRally */;
            return;
        }
        this.boostCreep(creep);
    }
    goToSafeRally(creep) {
        let creepMemory = creep.memory;
        if (this.skipSafeRally) {
            creepMemory.state = 2 /* GuardStatus.Move */;
            return;
        }
        const rallyOpts = {
            ignoreRoads: true,
            maxOps: 10000
        };
        let creepSafeRallyPos;
        if (this.safeRallyPos && this.safeRallyRange === 1) {
            let safeRallyTopLeft = new RoomPosition(this.safeRallyPos.x - 1, this.safeRallyPos.y - 1, this.safeRallyPos.roomName);
            creepSafeRallyPos = Common.getRallyCreepPosition(safeRallyTopLeft, 3, this.safeRallyIndex);
            ++this.safeRallyIndex;
        }
        if (creepSafeRallyPos && !creep.pos.isEqualTo(creepSafeRallyPos))
            creep.goTo(creepSafeRallyPos, 0, rallyOpts);
        else if (creepSafeRallyPos)
            creep.giveWay();
        else if (this.safeRallyPos && !creep.pos.inRangeTo(this.safeRallyPos, this.safeRallyRange))
            creep.goTo(this.safeRallyPos, this.safeRallyRange, rallyOpts);
        else if (this.safeRallyPos)
            creep.giveWay({ pos: this.safeRallyPos, range: this.safeRallyRange });
        else if (creep.pos.roomName !== this.roomName || creep.pos.isExit())
            creep.goToRoom(this.roomName, rallyOpts);
        else
            creep.giveWay();
    }
    move(creep) {
        let creepMemory = creep.memory;
        if (creep.pos.roomName === this.roomName) {
            creepMemory.state = 3 /* GuardStatus.Guard */;
            creepMemory.groupId = undefined;
            return;
        }
        // moving is handled by group
        if (creepMemory.groupId && !this.skipSafeRally)
            return;
        const rallyOpts = {
            ensurePath: true,
            ignoreRoads: true,
            maxOps: 20000
        };
        if (this.rallyPos)
            creep.goTo(this.rallyPos, 0, rallyOpts);
        else
            creep.goToRoom(this.roomName, rallyOpts);
    }
    goBackToRoom(creep, opts) {
        let creepMemory = creep.memory;
        let targetPos = creepMemory.targetPos && RoomPosition.deserialize(creepMemory.targetPos);
        if (targetPos)
            CombatPather.goTo(creep, targetPos, creepMemory.targetRange, opts);
        else if (this.rallyPos)
            CombatPather.goTo(creep, this.rallyPos, this.rallyRange, opts);
        else
            creep.goToRoom(this.roomName);
    }
    RangerFunc(creep) {
        let creepMemory = creep.memory;
        if (creepMemory.state === 0 /* GuardStatus.Boost */)
            this.boost(creep);
        if (creepMemory.state === 1 /* GuardStatus.SafeRally */)
            this.goToSafeRally(creep);
        if (creepMemory.state === 2 /* GuardStatus.Move */)
            this.move(creep);
        if (creep.hits < creep.hitsMax && creep.body.find(bp => bp.type === HEAL))
            creep.heal(creep);
        let hostiles = creep.room.findHostileCreeps().filter(h => h.owner.username !== 'Source Keeper' && h.body.some(bp => bp.type === WORK || bp.type === ATTACK || bp.type === RANGED_ATTACK || bp.type === HEAL || bp.type === CLAIM));
        let pathblockingObstacle = GIntel.rooms[creep.room.name].isFriendly
            ? undefined
            : creep.pos.lookInRange(LOOK_STRUCTURES, 3).find(s => (s.structureType === STRUCTURE_WALL || s.structureType === STRUCTURE_RAMPART) && s.hits < 5000);
        if (hostiles.length > 0)
            creep.shootAtWill(hostiles);
        else if (pathblockingObstacle)
            creep.rangedAttack(pathblockingObstacle);
        if (creepMemory.state === 3 /* GuardStatus.Guard */) {
            let opts = {
                maxOps: 2000,
                dontIgnoreCreeps: true,
                avoidDamage: RANGED_ATTACK_POWER * getBodypartPower(RANGED_ATTACK, creep) + HEAL_POWER * getBodypartPower(HEAL, creep),
                avoidDamageMargin: 1
            };
            let fleeOpts = Object.assign(Object.assign({}, opts), { flee: true, maxRooms: 1 });
            const roomIntel = GIntel.rooms[this.roomName];
            if (roomIntel && !roomIntel.isFriendly && roomIntel.towers > 0)
                creep.fleeFromRoom(this.roomName);
            else if (creep.pos.roomName !== this.roomName) {
                this.goBackToRoom(creep, opts);
            }
            else if (hostiles.length === 0) {
                if (this.rallyPos && !creep.pos.inRangeTo(this.rallyPos, this.rallyRange))
                    creep.goTo(this.rallyPos, this.rallyRange);
                else if (creep.pos.isExit())
                    creep.moveOffExit();
                else
                    creep.smokeBreak();
            }
            else {
                let closest = creep.pos.findClosestByRange(hostiles);
                let closestMedic = creep.pos.findClosestByRange(this.creeps.filter(c => c.body.some(bp => bp.type === HEAL)));
                if (closestMedic && creep.hits < creep.hitsMax && !creep.pos.isNearTo(closestMedic.pos)) {
                    creepMemory.targetPos = closestMedic.pos.serialize();
                    creepMemory.targetRange = 1;
                }
                else if (closest) {
                    creepMemory.targetPos = closest.pos.serialize();
                    creepMemory.targetRange = 2;
                }
                else {
                    creepMemory.targetPos = undefined;
                    creepMemory.targetRange = undefined;
                }
                let targetPos = RoomPosition.deserialize(creepMemory.targetPos);
                if (closest.pos.isEqualTo(targetPos)) {
                    if (closest.getActiveBodyparts(RANGED_ATTACK) === 0 && closest.getActiveBodyparts(ATTACK) === 0)
                        CombatPather.goTo(creep, closest.pos, 1, opts);
                    else if (!creep.pos.inRangeTo(closest, 3))
                        CombatPather.goTo(creep, closest.pos, 3, opts);
                    else if (creep.pos.inRangeTo(closest, 2))
                        CombatPather.goTo(creep, closest.pos, 5, fleeOpts);
                    else
                        creep.giveWay(true);
                }
                else {
                    if (creep.pos.isNearTo(targetPos))
                        creep.move(creep.pos.getDirectionTo(targetPos));
                    else
                        CombatPather.goTo(creep, targetPos, 0, opts);
                }
            }
        }
    }
    MeleeFunc(creep) {
        let creepMemory = creep.memory;
        if (creepMemory.state === 0 /* GuardStatus.Boost */)
            this.boost(creep);
        if (creepMemory.state === 1 /* GuardStatus.SafeRally */)
            this.goToSafeRally(creep);
        if (creepMemory.state === 2 /* GuardStatus.Move */)
            this.move(creep);
        let hostiles = creep.room.findHostileCreeps().filter(h => h.owner.username !== 'Source Keeper' && h.body.some(bp => bp.type === WORK || bp.type === ATTACK || bp.type === RANGED_ATTACK || bp.type === HEAL || bp.type === CLAIM));
        let pathblockingObstacle = GIntel.rooms[creep.room.name].isFriendly
            ? undefined
            : creep.pos.lookInRange(LOOK_STRUCTURES, 1).find(s => (s.structureType === STRUCTURE_WALL || s.structureType === STRUCTURE_RAMPART) && s.hits < 5000);
        if (hostiles.length > 0)
            creep.shootAtWill(hostiles);
        else if (pathblockingObstacle)
            creep.attack(pathblockingObstacle);
        if (creepMemory.state === 3 /* GuardStatus.Guard */) {
            let opts = {
                maxOps: 2000,
                dontIgnoreCreeps: true,
                avoidDamage: ATTACK_POWER * getBodypartPower(ATTACK, creep),
                avoidDamageMargin: 1
            };
            const roomIntel = GIntel.rooms[this.roomName];
            if (roomIntel && !roomIntel.isFriendly && roomIntel.towers > 0)
                creep.fleeFromRoom(this.roomName);
            else if (creep.pos.roomName !== this.roomName) {
                this.goBackToRoom(creep, opts);
            }
            else if (hostiles.length === 0) {
                if (this.rallyPos && !creep.pos.inRangeTo(this.rallyPos, this.rallyRange))
                    creep.goTo(this.rallyPos, this.rallyRange);
                else if (creep.pos.isExit())
                    creep.moveOffExit();
                else
                    creep.giveWay(true);
            }
            else {
                let closest = creep.pos.findClosestByRange(hostiles);
                let closestMedic = creep.pos.findClosestByRange(this.creeps.filter(c => c.body.some(bp => bp.type === HEAL)));
                if (closestMedic && creep.hits < creep.hitsMax && !creep.pos.isNearTo(closestMedic.pos)) {
                    creepMemory.targetPos = closestMedic.pos.serialize();
                    creepMemory.targetRange = 1;
                }
                else if (closest) {
                    creepMemory.targetPos = closest.pos.serialize();
                    creepMemory.targetRange = 1;
                }
                else {
                    creepMemory.targetPos = undefined;
                    creepMemory.targetRange = undefined;
                }
                let targetPos = RoomPosition.deserialize(creepMemory.targetPos);
                if (creep.pos.isNearTo(targetPos))
                    creep.move(creep.pos.getDirectionTo(targetPos));
                else
                    CombatPather.goTo(creep, targetPos, 0, opts);
            }
        }
    }
    HealerFunc(creep) {
        let creepMemory = creep.memory;
        if (creepMemory.state === 0 /* GuardStatus.Boost */)
            this.boost(creep);
        if (creepMemory.state === 1 /* GuardStatus.SafeRally */)
            this.goToSafeRally(creep);
        if (creepMemory.state === 2 /* GuardStatus.Move */)
            this.move(creep);
        //
        let allies = creep.room.findFriendlyCreeps();
        let injuredAllies = allies.filter(c => c.hits < c.hitsMax);
        let injuredSoldiers = injuredAllies.filter(c => !!c.body.find(bp => bp.type === ATTACK) || !!c.body.find(bp => bp.type === RANGED_ATTACK) || !!c.body.find(bp => bp.type === HEAL));
        let closest = injuredSoldiers.length > 0
            ? _.max(injuredSoldiers, c => (c.hitsMax - c.hits) / Math.max(1, c.pos.getRangeTo(creep.pos)))
            : injuredAllies.length > 0
                ? _.max(injuredAllies, c => (c.hitsMax - c.hits) / Math.max(1, c.pos.getRangeTo(creep.pos)))
                : creep.room.findHostileCreeps().length > 0
                    ? _.min(allies, c => c.getActiveBodyparts(HEAL) ? Infinity : c.pos.getRangeTo(creep.pos))
                    : undefined;
        if (closest && creep.pos.isNearTo(closest))
            creep.heal(closest);
        else if (closest && creep.pos.inRangeTo(closest.pos, 3))
            creep.rangedHeal(closest);
        else
            creep.heal(creep);
        //
        if (creepMemory.state === 3 /* GuardStatus.Guard */) {
            let opts = {
                dontIgnoreCreeps: true,
                avoidDamage: HEAL_POWER * getBodypartPower(HEAL, creep),
                avoidDamageMargin: 1
            };
            const roomIntel = GIntel.rooms[this.roomName];
            if (roomIntel && !roomIntel.isFriendly && roomIntel.towers > 0)
                creep.fleeFromRoom(this.roomName);
            else if (creep.pos.roomName !== this.roomName) {
                this.goBackToRoom(creep, opts);
            }
            else if (allies.length === 0) {
                if (this.rallyPos && !creep.pos.inRangeTo(this.rallyPos, this.rallyRange))
                    creep.goTo(this.rallyPos, this.rallyRange);
                else if (creep.pos.isExit())
                    creep.moveOffExit();
                else
                    creep.giveWay(true);
            }
            else {
                if (closest && closest !== creep) {
                    creepMemory.targetPos = closest.pos.serialize();
                    creepMemory.targetRange = 1;
                }
                else {
                    creepMemory.targetPos = undefined;
                    creepMemory.targetRange = undefined;
                }
                if (closest && closest !== creep && !creep.pos.isNearTo(closest))
                    CombatPather.goTo(creep, closest.pos, 1, opts);
                else if (creep.pos.isExit())
                    creep.moveOffExit();
                else if (closest && closest !== creep) {
                    if (closest instanceof Creep) {
                        closest.pull(creep);
                        creep.move(closest);
                    }
                    else /* if (closest instanceof PowerCreep) */ {
                        creep.move(creep.pos.getDirectionTo(closest.pos));
                    }
                }
                else if (this.rallyPos && !creep.pos.inRangeTo(this.rallyPos, this.rallyRange))
                    creep.goTo(this.rallyPos, this.rallyRange);
                else
                    creep.giveWay();
            }
        }
    }
    moveGroups() {
        let creepsReady = this.creeps.filter(c => !c.spawning && c.memory.state === 1 /* GuardStatus.SafeRally */ && (!this.safeRallyPos || c.pos.inRangeTo(this.safeRallyPos, this.safeRallyRange) ? 1 : 0));
        if (creepsReady.length > 0
            && (!this.composition
                || (_.sum(creepsReady, c => c.getActiveBodyparts(HEAL) ? 1 : 0) >= this.composition.healerCount
                    && _.sum(creepsReady, c => c.getActiveBodyparts(RANGED_ATTACK) ? 1 : 0) >= this.composition.rangerCount
                    && _.sum(creepsReady, c => c.getActiveBodyparts(ATTACK) ? 1 : 0) >= this.composition.meleeCount))) {
            let groupId = _.random(1, 9999);
            for (let creep of creepsReady) {
                let creepMemory = creep.memory;
                creepMemory.state = 2 /* GuardStatus.Move */;
                creepMemory.groupId = groupId;
            }
        }
        const rallyOpts = {
            ensurePath: true,
            ignoreRoads: true,
            maxOps: 20000
        };
        let movingGroups = _.groupBy(this.creeps.filter(c => !!c.memory.groupId), c => c.memory.groupId);
        for (let groupId in movingGroups) {
            let group = movingGroups[groupId];
            if (this.rallyPos)
                Pather.sneakGoTo(group, this.rallyPos, 0, rallyOpts);
            else
                Pather.sneakGoTo(group, new RoomPosition(25, 25, this.roomName), 23, rallyOpts);
        }
    }
    onRun() {
        this.safeRallyIndex = 0;
        this.safeRallyRange = Math.floor(Math.ceil(Math.sqrt(_.sum(this.creeps, c => c.memory.state === 1 /* GuardStatus.SafeRally */ ? 1 : 0)) + 1) / 2);
        this.rallyRange = Math.max(1, Math.floor(Math.sqrt(_.sum(this.creeps, c => c.memory.state === 3 /* GuardStatus.Guard */ ? 1 : 0)) / 2));
        this.updateLastAttack();
        this.updateComposition();
        this.skipSafeRally = this.creeps.some(c => c.pos.roomName === this.roomName) && this.room.intel.isSafe;
        if (!this.safeRallyPos || this.safeRallyPos.roomName !== this.spawnRoomName || Game.time % 50 === 0)
            this.safeRallyPos = this.updateRally(this.spawnRoomName, this.safeRallyRange * 2 + 1);
        if (!this.rallyPos || GIntel.rooms[this.roomName].invasion || Game.time % 50 === 0)
            this.rallyPos = this.updateRally(this.roomName, this.rallyRange * 2 + 1);
        this.updateCombatData();
        if (this.rallyPos) {
            let x = this.rallyPos.x - this.rallyRange - 0.5;
            let y = this.rallyPos.y - this.rallyRange - 0.5;
            let w = 2 * this.rallyRange + 1;
            let h = 2 * this.rallyRange + 1;
            Common.getRoomVisual(this.rallyPos.roomName).rect(x, y, w, h, { fill: null, stroke: '#ff0000', strokeWidth: 0.1, opacity: 0.5 });
        }
        if (this.safeRallyPos) {
            let x = this.safeRallyPos.x - this.safeRallyRange - 0.5;
            let y = this.safeRallyPos.y - this.safeRallyRange - 0.5;
            let w = 2 * this.safeRallyRange + 1;
            let h = 2 * this.safeRallyRange + 1;
            Common.getRoomVisual(this.safeRallyPos.roomName).rect(x, y, w, h, { fill: null, stroke: '#ff0000', strokeWidth: 0.1, opacity: 0.5 });
        }
        if (!this.skipSafeRally)
            this.moveGroups();
        for (let creep of this.creeps)
            if (!creep.spawning) {
                if (creep.body.some(bp => bp.type === RANGED_ATTACK))
                    this.RangerFunc(creep);
                else if (creep.body.some(bp => bp.type === ATTACK))
                    this.MeleeFunc(creep);
                else if (creep.body.some(bp => bp.type === HEAL))
                    this.HealerFunc(creep);
            }
    }
}
OperationGuard.OperationType = 'Guard';
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationGuard.prototype, "getSpawnRequestsInternal", null);
__decorate([
    profile()
], OperationGuard.prototype, "onRun", null);

class OperationSupply extends BaseGlobalOperation {
    constructor(empire, id) {
        super(empire, id);
        if (this.memory) {
            this.isMyRoom = !!this.room && this.room.controller.my;
        }
    }
    init(roomName, targetCreepCount) {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            closing: false,
            targetCreepCount: targetCreepCount,
            roomName: roomName
        };
        this.isMyRoom = !!Game.rooms[roomName] && Game.rooms[roomName].controller.my;
        Memory.operations[this.id] = memory;
    }
    get memory() {
        return super.memory;
    }
    get roomName() {
        return this.memory.roomName;
    }
    get room() {
        return Game.rooms[this.roomName];
    }
    updateEstimatedStats() {
        if (!this.spawnRoomName)
            return;
        const distance = Game.map.getRoomLinearDistance(this.spawnRoomName, this.roomName);
        const cpuPerCreep = (distance < 7 ? 0.1 : 0.2);
        this.estimatedStats.energyPerTick = -this.creepBody.cost * this.creeps.length / CREEP_LIFE_TIME;
        this.estimatedStats.spawnTime = this.creepBody.spawnTime * this.creeps.length;
        this.estimatedStats.baseCpu = cpuPerCreep * this.creeps.length;
    }
    onSpawn(requestId, creepName) {
        super.onSpawn(requestId, creepName);
        this.shouldUpdateEstimatedStats = true;
    }
    onCreepDeath(creepName) {
        this.shouldUpdateEstimatedStats = true;
    }
    onAssignSpawnRoom() {
        const distance = Game.map.getRoomLinearDistance(this.spawnRoomName, this.roomName);
        const carryPerMove = (distance < 7 ? 2 : 1);
        let parts = Math.floor(this.spawnRoom.energyCapacityAvailable / (carryPerMove * BODYPART_COST[CARRY] + BODYPART_COST[MOVE]));
        parts = Math.min(parts, Math.floor(50 / (carryPerMove + 1)));
        this.creepBody = new CreepBody(carryPerMove === 2 ? `${parts}[CCM]` : `${parts}[CM]`);
        this.shouldUpdateEstimatedStats = true;
    }
    isValidSpawnRoom(myRoom) {
        if (myRoom.room.energyCapacityAvailable < 200)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME / 2)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        const requiredSupplierRoomEnergy = this.isMyRoom
            ? this.room.storage && this.room.storage.store.energy || 10000
            : GIntel.rooms[this.roomName] && GIntel.rooms[this.roomName].storedEnergy || 10000;
        return myRoom.getEnergyAmount() >= requiredSupplierRoomEnergy;
    }
    getSpawnRequestsInternal() {
        const roomIntel = GIntel.rooms[this.roomName];
        if (this.memory.closing)
            return [];
        if (!roomIntel.isSafe)
            return [];
        if (this.room && this.room.myRoom && this.room.terminal && this.room.terminal.isActive())
            return [];
        if (!this.spawnRoom)
            return [];
        if (this.spawnRoom.myRoom.getStoredResource(RES_ENERGY) < Config.TARGET_STOCK.energy.terminal + 10000)
            return [];
        //if (roomIntel.spawns === 0)
        //  return;
        let result = [];
        let neededCount = this.memory.targetCreepCount - this.creeps.length;
        for (let i = 0; i < neededCount; ++i) {
            result.push({
                id: generateRandomKey(5),
                nameBase: 'Supplier',
                priority: FlagSpawnPriority - 1,
                minEnergy: 200,
                parts: this.creepBody,
                memory: {
                    state: 0
                },
                boostOptions: [[RES_XKH2O], [RES_KH2O], [RES_KH], null],
                noRepurpose: true,
                operation: this
            });
        }
        return result;
    }
    supplierFunc(creep) {
        let creepMemory = creep.memory;
        if (creepMemory.boosts) {
            this.boostCreep(creep);
            return;
        }
        if (creepMemory.state === 0) {
            let room = this.spawnRoom;
            let storage = (!room.storage || room.terminal && room.terminal.store.energy > Config.TARGET_STOCK.energy.terminal) ? room.terminal : room.storage;
            if (creep.store.getFreeCapacity() === 0)
                creepMemory.state = 1;
            else if (creep.pos.isNearTo(storage.pos)) {
                creep.withdraw(storage, RESOURCE_ENERGY);
                creep.giveWay(true);
            }
            else
                creep.goTo(storage.pos, 1, { ensurePath: true });
        }
        if (creepMemory.state === 1) {
            const dropoffFlag = this.isMyRoom
                ? undefined
                : _.find(Game.flags, (v, k) => k.toLowerCase().startsWith('dropoff'));
            if (!this.isMyRoom && !dropoffFlag) {
                this.abort();
                return;
            }
            let targetPos = this.isMyRoom
                ? this.room.myRoom.getCollectionPoint()
                : dropoffFlag.pos;
            let storeStructure = this.isMyRoom
                ? targetPos.lookFor(LOOK_STRUCTURES).find(s => {
                    return s.isActive()
                        && (s.structureType === STRUCTURE_CONTAINER || s.structureType === STRUCTURE_STORAGE || s.structureType === STRUCTURE_TERMINAL)
                        && s.hasStore()
                        && s.store.getFreeCapacity() > 0;
                })
                : this.room
                    ? targetPos.lookInRange(LOOK_STRUCTURES, 1).find(s => s.isActive() && s.hasStore())
                    : undefined;
            if (storeStructure && creep.pos.isNearTo(targetPos)) {
                creep.transfer(storeStructure, RESOURCE_ENERGY);
                Stats.registerSpending(this.roomName, this.constructor.name, -creep.store.energy);
                creep.giveWay(true);
            }
            else if (storeStructure)
                creep.goTo(targetPos, 1, { avoidUnsafeRooms: true, ensurePath: true });
            else if (creep.pos.isEqualTo(targetPos)) {
                creep.drop(RESOURCE_ENERGY);
                Stats.registerSpending(this.roomName, this.constructor.name, -creep.store.energy);
                creep.giveWay(true);
            }
            else
                creep.goTo(targetPos, 0, { avoidUnsafeRooms: true, ensurePath: true });
            if (creep.store.getUsedCapacity() === 0) {
                if (creep.ticksToLive > 1.1 * 3 * this.routeDistance)
                    creepMemory.state = 0;
                else
                    this.dismissCreep(creep, true, false);
            }
        }
    }
    onRun() {
        const roomIntel = GIntel.rooms[this.roomName];
        if (roomIntel && !roomIntel.isMy && !Config.ALLIES.has(roomIntel.owner)) {
            this.abort();
            return;
        }
        if (this.spawnRoom && this.spawnRoom.terminal && this.room && this.room.terminal) {
            this.abort();
            return;
        }
        const routeOpts = {
            avoidHostileRooms: true,
            avoidUnsafeRooms: false
        };
        if (this.spawnRoomName) {
            const route = Pather.findRoute(this.spawnRoomName, this.roomName, routeOpts);
            this.routeDistance = (route.length - 1) * 50;
        }
        for (let creep of this.creeps)
            if (!creep.spawning)
                this.supplierFunc(creep);
    }
}
OperationSupply.OperationType = 'Supply';
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationSupply.prototype, "getSpawnRequestsInternal", null);
__decorate([
    profile()
], OperationSupply.prototype, "onRun", null);
class FlagOperationSupply extends OperationSupply {
    constructor(empire, id) {
        super(empire, id);
    }
    init(roomName) {
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            closing: false,
            targetCreepCount: this.flag.color,
            roomName: roomName
        };
        this.isMyRoom = !!Game.rooms[roomName] && Game.rooms[roomName].controller.my;
        Memory.flags[this.id] = memory;
    }
    get readyToDelete() {
        return !this.flag || super.readyToDelete;
    }
    deleteMemory() {
        delete Memory.flags[this.id];
    }
    get memory() {
        return Memory.flags[this.id];
    }
    get flag() {
        return Game.flags[this.id];
    }
    get roomName() {
        return this.flag.pos.roomName;
    }
    onInitForTick() {
        super.onInitForTick();
        this.memory.roomName = this.flag.pos.roomName;
        this.memory.targetCreepCount = this.flag.color;
    }
}

var Status$3;
(function (Status) {
    Status[Status["Grouping"] = 0] = "Grouping";
    Status[Status["Moving"] = 1] = "Moving";
    Status[Status["Fighting"] = 2] = "Fighting";
    Status[Status["Idling"] = 3] = "Idling";
})(Status$3 || (Status$3 = {}));
class OperationSkirmish extends BaseGlobalOperation {
    constructor(empire, id) {
        super(empire, id);
    }
    // ---------------------------------------------------------------------
    get memory() {
        return super.memory;
    }
    // ---------------------------------------------------------------------
    init(hostiles) {
        const roomName = this.getHostilesLocation(hostiles);
        let hostileTotalCost = 0;
        let hostileMaxRcl = 1;
        for (let hostileId of hostiles) {
            const cachedBody = GCreepBodyCache.get(hostileId);
            hostileTotalCost += cachedBody.cost;
            let hostileRcl = parseInt(_.findKey(ROOM_ENERGY_CAPACITY, rec => rec >= cachedBody.cost));
            if (hostileRcl > hostileMaxRcl)
                hostileMaxRcl = hostileRcl;
        }
        let memory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            closing: false,
            roomName: roomName,
            //
            status: Status$3.Grouping,
            hostiles: hostiles,
            hostileMaxRcl: hostileMaxRcl,
            hostileTotalCost: hostileTotalCost
        };
        Memory.operations[this.id] = memory;
    }
    // ---------------------------------------------------------------------
    updateEstimatedStats() {
        this.estimatedStats.energyPerTick = 0;
        this.estimatedStats.spawnTime = 0;
        this.estimatedStats.baseCpu = 0;
    }
    isValidSpawnRoom(myRoom) {
        if (myRoom.room.controller.level < this.hostileMaxRcl - 1)
            return false;
        const body = OperationSkirmish.bodies[myRoom.room.controller.level];
        const squadSize = Math.ceil(this.hostilesTotalCost * OperationSkirmish.overkillMultiplier / body.cost);
        if (squadSize > 7)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        return true;
    }
    onAssignSpawnRoom() {
        const bodyRcl = Math.min(this.hostileMaxRcl + 1, this.spawnRoom.controller.level);
        const body = OperationSkirmish.bodies[bodyRcl];
        const squadSize = Math.ceil(this.hostilesTotalCost * OperationSkirmish.overkillMultiplier / body.cost);
        this.skirmisherBody = body;
        this.squadSize = squadSize;
    }
    getSpawnRequestsInternal() {
        if (!this.spawnRoom)
            return [];
        if (this.memory.status !== Status$3.Grouping)
            return [];
        let priority = this.creeps.length > 0
            ? StartedSquadPriority
            : FlagSpawnPriority;
        priority += 0.1 * this.creeps.length;
        let result = [];
        let creepsNeeded = this.squadSize - this.creeps.length;
        for (let i = 0; i < creepsNeeded; ++i) {
            result.push({
                id: generateRandomKey(5),
                nameBase: 'Skirmisher',
                priority: priority,
                minEnergy: this.skirmisherBody.cost,
                parts: this.skirmisherBody,
                memory: {},
                boostOptions: [null],
                noRepurpose: true,
                operation: this
            });
        }
        return result;
    }
    // ---------------------------------------------------------------------
    get hostilesTotalCost() {
        return this.memory.hostileTotalCost;
    }
    get hostileMaxRcl() {
        return this.memory.hostileMaxRcl;
    }
    getHostilesLocation(hostiles) {
        let resultScore = 0;
        let result = undefined;
        let lastKnownLocations = {};
        for (let hostileId of hostiles) {
            const roomName = GIntel.getLastKnownCreepLocation(hostileId);
            lastKnownLocations[roomName] = lastKnownLocations[roomName] || 0;
            ++lastKnownLocations[roomName];
            if (lastKnownLocations[roomName] > resultScore) {
                resultScore = lastKnownLocations[roomName];
                result = roomName;
            }
        }
        return result;
    }
    // ---------------------------------------------------------------------
    groupUp(creeps) {
        let groupedUp = 0;
        if (this.creeps.length > 0) {
            const rallyRoom = creeps[0].room;
            const rallyPos = Common.findRally(rallyRoom, this.squadSize, creeps[0].pos, creeps);
            const rallySize = Math.ceil(Math.sqrt(this.squadSize));
            const visual = Common.getRoomVisual(rallyPos.roomName);
            visual.text(this.id, rallyPos.x - 0.5, rallyPos.y - 0.6, { align: 'left', color: '#ff00ff', font: 0.25 });
            visual.rect(rallyPos.x - 0.5, rallyPos.y - 0.5, rallySize, rallySize, { fill: null, stroke: '#ff0000', strokeWidth: 0.1, opacity: 0.5 });
            for (let i = 0; i < creeps.length; ++i) {
                const creep = creeps[i];
                const creepMemory = creep.memory;
                if (creepMemory.boosts)
                    this.boostCreep(creep);
                else {
                    const creepRallyPos = Common.getRallyCreepPosition(rallyPos, rallySize, i);
                    if (!creep.pos.isEqualTo(creepRallyPos))
                        creep.goTo(creepRallyPos, 0);
                    else {
                        creep.giveWay(true);
                        ++groupedUp;
                    }
                }
            }
        }
        if (groupedUp >= this.squadSize)
            this.memory.status = Status$3.Moving;
    }
    move(creeps) {
        for (let creep of creeps)
            if (creep.hits < creep.hitsMax)
                creep.heal(creep);
        const targetRoom = this.roomName;
        if (creeps[0].pos.roomName === this.roomName)
            this.memory.status = Status$3.Fighting;
        else
            Pather.sneakGoTo(creeps, new RoomPosition(25, 25, targetRoom), 23, {});
    }
    fight(creeps) {
        for (let creep of creeps)
            this.skirmisherFunc(creep);
    }
    skirmisherFunc(creep) {
        //const creepMemory = creep.memory as SkirmisherMemory;
        const hostiles = creep.room.findHostileCreeps().filter(h => h.owner.username !== 'Source Keeper' && h.body.some(bp => bp.type === WORK || bp.type === ATTACK || bp.type === RANGED_ATTACK || bp.type === HEAL || bp.type === CLAIM));
        if (creep.hits < creep.hitsMax || hostiles.some(h => h.pos.inRangeTo(creep.pos, 3)))
            creep.heal(creep);
        if (hostiles.length > 0)
            creep.shootAtWill(hostiles);
        const target = creep.pos.findClosestByRange(hostiles);
        if (!target) {
            if (creep.pos.roomName === this.roomName)
                creep.smokeBreak();
            else
                creep.goToRoom(this.roomName);
            return;
        }
        let targetBody = GCreepBodyCache.get(target.id);
        if (!target.isPowerCreep() && !targetBody) {
            GCreepBodyCache.add(target);
            targetBody = GCreepBodyCache.get(target.id);
        }
        const opts = {
            maxOps: 2000,
            dontIgnoreCreeps: true
        };
        const fleeOpts = Object.assign(Object.assign({}, opts), { flee: true, maxRooms: 1 });
        if (!target.isPowerCreep() && targetBody[RANGED_ATTACK] === 0 && targetBody[ATTACK] === 0)
            CombatPather.goTo(creep, target.pos, 1, opts);
        else if (!creep.pos.inRangeTo(target, 3))
            CombatPather.goTo(creep, target.pos, 3, opts);
        else if (creep.pos.inRangeTo(target, 2))
            CombatPather.goTo(creep, target.pos, 5, fleeOpts);
        else
            creep.giveWay(true);
    }
    // ---------------------------------------------------------------------
    visualize() {
        Game.map.visual.rect(new RoomPosition(0, 0, this.roomName), 50, 50, {
            fill: 'transparent',
            opacity: 1,
            stroke: '#ff0000',
            strokeWidth: 0.5
        });
    }
    // ---------------------------------------------------------------------
    onRun() {
        const status = this.memory.status;
        if (status !== Status$3.Grouping && this.creeps.length === 0) {
            this.close();
            return;
        }
        let newRoomName = this.getHostilesLocation(this.memory.hostiles);
        this.memory.roomName = newRoomName || this.memory.roomName;
        if (status === Status$3.Grouping) {
            this.groupUp(this.creeps);
        }
        if (status === Status$3.Moving) {
            this.move(this.creeps);
        }
        if (status === Status$3.Fighting) {
            this.fight(this.creeps);
        }
        if (status === Status$3.Idling) ;
        this.visualize();
    }
}
OperationSkirmish.OperationType = 'Skirmish';
OperationSkirmish.bodies = {
    1: new CreepBody('RM'),
    2: new CreepBody('2MRH'),
    3: new CreepBody('3M2RH'),
    4: new CreepBody('5M3R2H'),
    5: new CreepBody('8M6R2H'),
    6: new CreepBody('10M7R3H'),
    7: new CreepBody('24M16R8H'),
    8: new CreepBody('25M16R9H')
};
OperationSkirmish.overkillMultiplier = 1.2;
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationSkirmish.prototype, "getSpawnRequestsInternal", null);
__decorate([
    check,
    profile()
], OperationSkirmish.prototype, "onRun", null);
/* TODO
 * attacking pathblockers when moving
 * fleeing from towers
 */

class StrategyPeacekeeping extends BaseStrategy {
    constructor(empire) {
        super(empire);
        if (!this.memory) {
            let strategyMemory = {
                hostileGroups: {},
                peacekeepingResponses: {}
            };
            Memory.strategies['Peacekeeping'] = strategyMemory;
        }
        this.hostileToGroupLookup = {};
        for (let groupId in this.memory.hostileGroups) {
            const group = this.memory.hostileGroups[groupId];
            for (let creepId of group.creeps) {
                this.hostileToGroupLookup[creepId] = groupId;
            }
        }
    }
    get memory() {
        return Memory.strategies['Peacekeeping'];
    }
    assignHostileToGroup(creepId) {
        const creepRoom = GIntel.getLastKnownCreepLocation(creepId);
        for (let groupId in this.memory.hostileGroups) {
            const group = this.memory.hostileGroups[groupId];
            if (group.roomName !== creepRoom)
                continue;
            group.creeps.push(creepId);
            this.hostileToGroupLookup[creepId] = groupId;
            return;
        }
        // no group was found, create a new one
        let id = generateRandomKey(10);
        this.memory.hostileGroups[id] = {
            roomName: creepRoom,
            creeps: [creepId]
        };
        this.hostileToGroupLookup[creepId] = id;
    }
    groupHostiles() {
        for (let roomName in GIntel.rooms) {
            const roomIntel = GIntel.rooms[roomName];
            if (roomIntel.isPOI) {
                for (let hostile of roomIntel.hostiles) {
                    if (hostile.owner === 'Invader')
                        continue;
                    if (!(hostile.id in this.hostileToGroupLookup)) {
                        this.assignHostileToGroup(hostile.id);
                    }
                }
            }
        }
    }
    deleteGroup(groupId) {
        for (let creepId of this.memory.hostileGroups[groupId].creeps)
            delete this.hostileToGroupLookup[creepId];
        delete this.memory.hostileGroups[groupId];
    }
    createGlobalOperations(activeOperations) {
        let result = [];
        // cluster hostiles
        this.groupHostiles();
        // clear outdated hostile groups
        for (let groupId in this.memory.hostileGroups) {
            const group = this.memory.hostileGroups[groupId];
            group.creeps = group.creeps.filter(creepId => !!GIntel.getLastKnownCreepLocation(creepId));
            if (group.creeps.length === 0)
                this.deleteGroup(groupId);
        }
        // close responses to outdated groups
        for (let hostileGroupId in this.memory.peacekeepingResponses) {
            const responseId = this.memory.peacekeepingResponses[hostileGroupId];
            if (activeOperations[responseId] && !this.memory.hostileGroups[hostileGroupId]) {
                activeOperations[responseId].close();
            }
            if (!activeOperations[responseId]) {
                delete this.memory.peacekeepingResponses[hostileGroupId];
            }
        }
        //
        for (let groupId in this.memory.hostileGroups) {
            if (this.memory.peacekeepingResponses[groupId])
                continue;
            // create response
            const hostileGroup = this.memory.hostileGroups[groupId];
            const responseId = OperationSkirmish.OperationType + '_' + groupId;
            this.memory.peacekeepingResponses[groupId] = responseId;
            let response = new OperationSkirmish(this.empire, responseId);
            response.init(hostileGroup.creeps);
            result.push(response);
        }
        return result;
    }
}
__decorate([
    check
], StrategyPeacekeeping.prototype, "createGlobalOperations", null);

class StrategyRoomSupport extends BaseStrategy {
    constructor(empire) {
        super(empire);
        if (!this.memory) {
            let strategyMemory = {
                guardOperations: {},
                buildOperations: {}
            };
            Memory.strategies['RoomSupport'] = strategyMemory;
        }
    }
    get memory() {
        return Memory.strategies['RoomSupport'];
    }
    createGlobalOperations(activeOperations) {
        let myRooms = this.empire.myRooms;
        for (let guardOperationRoom in this.memory.guardOperations) {
            const guardOperationId = this.memory.guardOperations[guardOperationRoom];
            const guardOperation = activeOperations[guardOperationId];
            const myRoom = myRooms.find(mr => mr.roomName === guardOperation.roomName);
            if (!myRoom
                || _.some(Game.flags, flag => flag.pos.roomName === guardOperation.roomName && flag.name.startsWith('NoGuard'))
                || myRoom.room.find(FIND_MY_SPAWNS).length > 0) {
                guardOperation.close();
                delete this.memory.guardOperations[guardOperationRoom];
            }
        }
        for (let buildOperationRoom in this.memory.buildOperations) {
            const buildOperationId = this.memory.buildOperations[buildOperationRoom];
            const buildOperation = activeOperations[buildOperationId];
            const myRoom = myRooms.find(mr => mr.roomName === buildOperation.roomName);
            if (!myRoom || myRoom.room.find(FIND_MY_SPAWNS).length > 0) {
                buildOperation.close();
                delete this.memory.buildOperations[buildOperationRoom];
            }
        }
        let result = [];
        for (let myRoom of myRooms) {
            if (myRoom.room.find(FIND_MY_SPAWNS).length === 0) {
                // Guard
                if (!this.memory.guardOperations[myRoom.roomName] && myRoom.room.find(FIND_FLAGS).every(f => !f.name.startsWith('NoGuard'))) {
                    const guardOperationId = OperationGuard.OperationType + '_' + myRoom.roomName + '_' + Game.time;
                    const guardOperation = new OperationGuard(this.empire, guardOperationId);
                    guardOperation.init(myRoom.roomName);
                    this.memory.guardOperations[myRoom.roomName] = guardOperationId;
                    result.push(guardOperation);
                }
                // Build
                if (!this.memory.buildOperations[myRoom.roomName]) {
                    const buildOperationId = OperationBuildSupport.OperationType + '_' + myRoom.roomName + '_' + Game.time;
                    const buildOperation = new OperationBuildSupport(this.empire, buildOperationId);
                    buildOperation.init(myRoom.roomName, 6);
                    this.memory.buildOperations[myRoom.roomName] = buildOperationId;
                    result.push(buildOperation);
                }
            }
        }
        return result;
    }
}
__decorate([
    check
], StrategyRoomSupport.prototype, "createGlobalOperations", null);

class OperationStrongholdLow extends BaseGlobalOperation {
    constructor(empire, id) {
        super(empire, id);
    }
    init(roomName, strongholLevel) {
        if (Memory.operations[this.id])
            return;
        let operationMemory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            //
            closing: false,
            //
            roomName: roomName,
            strongholLevel: strongholLevel
        };
        Memory.operations[this.id] = operationMemory;
    }
    get memory() {
        return super.memory;
    }
    onInitForTick() {
        super.onInitForTick();
        if (!this.sniperBody) {
            switch (this.memory.strongholLevel) {
                case 1:
                    this.sniperBody = new CreepBody('2T22R16M8H');
                    break;
                case 2:
                    this.sniperBody = new CreepBody('4T22R12M10H');
                    break;
                case 3:
                    this.sniperBody = new CreepBody('6T22R10M12H');
                    break;
            }
        }
    }
    updateEstimatedStats() {
        this.estimatedStats.energyPerTick = -this.sniperBody.cost / CREEP_LIFE_TIME;
        this.estimatedStats.spawnTime = this.sniperBody.spawnTime;
        this.estimatedStats.baseCpu = 0.4;
    }
    isValidSpawnRoom(myRoom) {
        const maxCreepCost = this.sniperBody.cost;
        if (myRoom.room.energyCapacityAvailable < maxCreepCost)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME * 0.666)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        const creepCost = this.sniperBody.cost;
        if (myRoom.getStoredResource(RES_ENERGY) < creepCost)
            return false;
        const boosts = [
            [RES_XGHO2, RES_LO, RES_KO, RES_ZO],
            [RES_XGHO2, RES_LHO2, RES_KHO2, RES_ZHO2],
            [RES_XGHO2, RES_XLHO2, RES_XKHO2, RES_XZHO2]
        ][this.memory.strongholLevel - 1];
        for (let boost of boosts) {
            if (GEmpire.getStoredResource(boost) < (this.sniperBody[BOOST_TO_BODYPART[boost]] || 0) * LAB_BOOST_MINERAL)
                return false;
        }
        return true;
    }
    getSpawnRequestsInternal() {
        if (this.memory.closing)
            return [];
        if (this.creeps.length > 0)
            return [];
        const boostOptions = [
            [[RES_XGHO2, RES_LO, RES_KO, RES_ZO]],
            [[RES_XGHO2, RES_LHO2, RES_KHO2, RES_ZHO2]],
            [[RES_XGHO2, RES_XLHO2, RES_XKHO2, RES_XZHO2]]
        ][this.memory.strongholLevel - 1];
        let result = [
            {
                id: generateRandomKey(5),
                nameBase: 'Sniper',
                priority: FlagSpawnPriority,
                minEnergy: this.sniperBody.cost,
                parts: this.sniperBody,
                memory: {},
                boostOptions: boostOptions,
                noRepurpose: true,
                operation: this
            }
        ];
        return result;
    }
    onRun() {
        const intel = GIntel.rooms[this.roomName];
        const invaderCore = intel.invaderCore && this.room && intel.invaderCore.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_INVADER_CORE);
        if (!intel.invaderCore || intel.lastScout === Game.time && !invaderCore) {
            for (let creep of this.creeps)
                this.dismissCreep(creep, true, false);
            this.close();
        }
        else if (this.creeps.length > 0) {
            let sniper = this.creeps[0];
            if (sniper.memory.boosts) {
                this.boostCreep(sniper);
            }
            else if (sniper.pos.roomName !== this.roomName) {
                sniper.goTo(intel.invaderCore.pos, 3);
            }
            else {
                let hostileStructures = sniper.room.find(FIND_HOSTILE_STRUCTURES);
                let obstacles = [];
                for (let s of hostileStructures) {
                    for (let dir = TOP; dir <= TOP_LEFT; ++dir) {
                        let offsetPos = s.pos.nextPosition(dir);
                        if (!obstacles.find(o => o.isEqualTo(offsetPos)))
                            obstacles.push(offsetPos);
                    }
                }
                if (!sniper.pos.inRangeTo(intel.invaderCore.pos, 3)) {
                    CombatPather.goTo(sniper, intel.invaderCore.pos, 3, { avoidDamage: intel.towers * 600 + 1, obstacles: obstacles });
                }
                else {
                    const hostileInRange = sniper.pos.lookInRange(LOOK_CREEPS, 3).find(c => !c.my && !c.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_RAMPART));
                    if (hostileInRange)
                        sniper.rangedAttack(hostileInRange);
                    else
                        sniper.rangedAttack(invaderCore);
                }
            }
            if (sniper.hits < sniper.hitsMax || sniper.pos.roomName === this.roomName) {
                sniper.heal(sniper);
            }
        }
    }
}
OperationStrongholdLow.OperationType = 'StrongholdLow';
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationStrongholdLow.prototype, "getSpawnRequestsInternal", null);
class FlagOperationStrongholdLow extends OperationStrongholdLow {
    constructor(empire, id) {
        super(empire, id);
    }
    init(roomName) {
        if (Memory.flags[this.id])
            return;
        const intel = GIntel.rooms[this.roomName];
        if (!intel.invaderCore)
            return;
        let operationMemory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            //
            closing: false,
            //
            roomName: roomName,
            strongholLevel: intel.invaderCore.level
        };
        Memory.flags[this.id] = operationMemory;
    }
    deleteMemory() {
        delete Memory.flags[this.id];
    }
    get memory() {
        return Memory.flags[this.id];
    }
    get flag() {
        return Game.flags[this.id];
    }
    get roomName() {
        return this.flag.pos.roomName;
    }
}

class OperationStrongholdMid extends BaseGlobalOperation {
    constructor(empire, id) {
        super(empire, id);
        this.tankBody = new CreepBody('20T15R5H10M');
        this.healerBody = new CreepBody('2T10M38H');
        this.dpsBody = new CreepBody('39R10M1H');
        this.tankRequestId = null;
        this.healerRequestId = null;
        this.dpsRequestIds = [];
        if (this.memory && this.memory.tankPosition) {
            this.tankPosition = RoomPosition.deserialize(this.memory.tankPosition);
            this.dpsOuterPositions = this.memory.dpsOuterPositions.map(pos => RoomPosition.deserialize(pos));
            this.dpsInnerPositions = this.memory.dpsInnerPositions.map(pos => RoomPosition.deserialize(pos));
        }
        const intel = GIntel.rooms[this.roomName];
        this.obstacles = [];
        for (let i = -2; i <= 2; ++i) {
            this.obstacles.push(new RoomPosition(intel.invaderCore.pos.x - 3, intel.invaderCore.pos.y + i, intel.invaderCore.pos.roomName));
            this.obstacles.push(new RoomPosition(intel.invaderCore.pos.x + 3, intel.invaderCore.pos.y + i, intel.invaderCore.pos.roomName));
            this.obstacles.push(new RoomPosition(intel.invaderCore.pos.x + i, intel.invaderCore.pos.y - 3, intel.invaderCore.pos.roomName));
            this.obstacles.push(new RoomPosition(intel.invaderCore.pos.x + i, intel.invaderCore.pos.y + 3, intel.invaderCore.pos.roomName));
        }
    }
    init(roomName, strongholLevel) {
        if (Memory.operations[this.id])
            return;
        let operationMemory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            //
            closing: false,
            //
            roomName: roomName,
            tank: null,
            healer: null,
            dps: []
        };
        Memory.operations[this.id] = operationMemory;
    }
    get memory() {
        return super.memory;
    }
    onInitForTick() {
        super.onInitForTick();
        this.tank = Game.creeps[this.memory.tank];
        this.healer = Game.creeps[this.memory.healer];
        this.dps = this.memory.dps.map(dpsName => Game.creeps[dpsName]);
        if (!this.tankPosition && this.tank && this.tank.pos.roomName === this.roomName)
            this.selectPositions(this.room, this.tank.pos);
        if (this.room) {
            this.obstacles = this.obstacles.filter(o => !!o.lookInRange(LOOK_STRUCTURES, 1).find(s => s.structureType === STRUCTURE_RAMPART));
        }
    }
    updateEstimatedStats() {
        this.estimatedStats.energyPerTick = -this.tankBody.cost / CREEP_LIFE_TIME;
        this.estimatedStats.spawnTime = this.tankBody.spawnTime;
        this.estimatedStats.baseCpu = 0.4;
    }
    isValidSpawnRoom(myRoom) {
        const maxCreepCost = Math.max(this.tankBody.cost, this.healerBody.cost, this.dpsBody.cost);
        if (myRoom.room.energyCapacityAvailable < maxCreepCost)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME * 0.666)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        // TODO - account for already spawned and boosted creeps
        let creepCost = (this.tank ? 0 : this.tankBody.cost) + (this.healer ? 0 : this.healerBody.cost) + (5 - this.dps.length) * this.dpsBody.cost;
        if (myRoom.getStoredResource(RES_ENERGY) < creepCost)
            return false;
        const boosts = [RES_XGHO2, RES_XLHO2, /*RES_XKHO2, */ RES_XZHO2];
        for (let boost of boosts) {
            let boostNeeded = 0;
            boostNeeded += (!this.tank && this.tankBody[BOOST_TO_BODYPART[boost]] || 0) * LAB_BOOST_MINERAL;
            boostNeeded += (!this.healer && this.healerBody[BOOST_TO_BODYPART[boost]] || 0) * LAB_BOOST_MINERAL;
            boostNeeded += (5 - this.dps.length) * (this.dpsBody[BOOST_TO_BODYPART[boost]] || 0) * LAB_BOOST_MINERAL;
            if (GEmpire.getStoredResource(boost) < boostNeeded)
                return false;
        }
        return true;
    }
    getSpawnRequestsInternal() {
        if (this.memory.closing)
            return [];
        const startedSpawning = !!this.tank || !!this.healer || this.dps.length > 0;
        const priority = startedSpawning ? StartedSquadPriority : FlagSpawnPriority;
        let result = [];
        if (!this.tank) {
            this.tankRequestId = generateRandomKey(5);
            result.push({
                id: this.tankRequestId,
                nameBase: 'Tank',
                priority: priority,
                minEnergy: this.tankBody.cost,
                parts: this.tankBody,
                memory: {},
                boostOptions: [[RES_XGHO2, RES_XLHO2, RES_XKHO2, RES_XZHO2], [RES_XGHO2, RES_XLHO2, RES_KHO2, RES_XZHO2], [RES_XGHO2, RES_XLHO2, RES_KO, RES_XZHO2], [RES_XGHO2, RES_XLHO2, RES_XZHO2]],
                noRepurpose: true,
                operation: this
            });
        }
        if (this.tank && !this.healer) {
            this.healerRequestId = generateRandomKey(5);
            result.push({
                id: this.healerRequestId,
                nameBase: 'Healer',
                priority: priority,
                minEnergy: this.healerBody.cost,
                parts: this.healerBody,
                memory: {},
                boostOptions: [[RES_XGHO2, RES_XLHO2, RES_XZHO2]],
                noRepurpose: true,
                operation: this
            });
        }
        if (this.dps.length < 5) {
            this.dpsRequestIds = [];
            for (let i = this.dps.length; i < 5; ++i) {
                const dpsRequestId = generateRandomKey(5);
                this.dpsRequestIds.push(dpsRequestId);
                result.push({
                    id: dpsRequestId,
                    nameBase: 'DPS',
                    priority: priority,
                    minEnergy: this.dpsBody.cost,
                    parts: this.dpsBody,
                    memory: {},
                    boostOptions: [[RES_XLHO2, RES_XKHO2, RES_XZHO2], [RES_XLHO2, RES_KHO2, RES_XZHO2], [RES_XLHO2, RES_KO, RES_XZHO2], [RES_XLHO2, RES_XZHO2]],
                    noRepurpose: true,
                    operation: this
                });
            }
        }
        return result;
    }
    onSpawn(requestId, creepName) {
        super.onSpawn(requestId, creepName);
        if (this.tankRequestId === requestId) {
            this.memory.tank = creepName;
            this.tankRequestId = null;
        }
        else if (this.healerRequestId === requestId) {
            this.memory.healer = creepName;
            this.healerRequestId = null;
        }
        else if (this.dpsRequestIds.includes(requestId)) {
            this.memory.dps.push(creepName);
            _.pull(this.dpsRequestIds, creepName);
        }
    }
    onCreepDeath(creepName) {
        if (this.memory.tank === creepName) {
            this.memory.tank = null;
        }
        else if (this.memory.healer === creepName) {
            this.memory.healer = null;
        }
        else if (this.memory.dps.includes(creepName)) {
            _.pull(this.memory.dps, creepName);
        }
    }
    selectPositions(room, enterPos) {
        const intel = GIntel.rooms[this.roomName];
        const terrain = Game.map.getRoomTerrain(room.name);
        let corners = [
            new RoomPosition(intel.invaderCore.pos.x - 2, intel.invaderCore.pos.y - 2, intel.invaderCore.pos.roomName),
            new RoomPosition(intel.invaderCore.pos.x + 2, intel.invaderCore.pos.y - 2, intel.invaderCore.pos.roomName),
            new RoomPosition(intel.invaderCore.pos.x - 2, intel.invaderCore.pos.y + 2, intel.invaderCore.pos.roomName),
            new RoomPosition(intel.invaderCore.pos.x + 2, intel.invaderCore.pos.y + 2, intel.invaderCore.pos.roomName)
        ];
        const pathToClosestCorner = Pather.findPathToClosest(enterPos, corners.map(corner => ({ pos: corner, range: 1 })), { obstacles: this.obstacles });
        this.tankPosition = _.last(pathToClosestCorner.path);
        _.remove(corners, c => c.isEqualTo(this.tankPosition));
        const dpsCorner = _.min(corners, corner => corner.lookInRange(LOOK_TERRAIN, 3).filter(t => t === 'wall').length);
        this.dpsOuterPositions = [];
        this.dpsInnerPositions = [];
        for (let y = dpsCorner.y - 2; y <= dpsCorner.y + 2; ++y) {
            for (let x = dpsCorner.x - 2; x <= dpsCorner.x + 2; ++x) {
                if ((terrain.get(x, y) & TERRAIN_MASK_WALL) > 0)
                    continue;
                if (room.lookForAt(LOOK_STRUCTURES, x, y).find(s => s.structureType === STRUCTURE_RAMPART))
                    continue;
                const dpsPos = new RoomPosition(x, y, this.roomName);
                if (intel.invaderCore.pos.getRangeTo(dpsPos) > 3)
                    this.dpsOuterPositions.push(dpsPos);
                else
                    this.dpsInnerPositions.push(dpsPos);
            }
        }
        this.memory.tankPosition = this.tankPosition.serialize();
        this.memory.dpsOuterPositions = this.dpsOuterPositions.map(pos => pos.serialize());
        this.memory.dpsInnerPositions = this.dpsInnerPositions.map(pos => pos.serialize());
    }
    calculateHostileDamage(pos) {
        let result = 0;
        let towers = this.room.find(FIND_STRUCTURES).filter(s => s.structureType === STRUCTURE_TOWER);
        for (let tower of towers) {
            result += TOWER_POWER_ATTACK * Common.calcTowerMultiplier(pos.x, pos.y, tower.pos.x, tower.pos.y);
        }
        let hostileDamage = CombatData.getHostileCreepDamage(pos.roomName);
        result += hostileDamage[pos.y * 50 + pos.x];
        return result;
    }
    visualize() {
        if (!this.tankPosition)
            return;
        const visual = new RoomVisual(this.roomName);
        for (let dpsPos of this.dpsInnerPositions)
            visual.circle(dpsPos, { opacity: 0.5, fill: '#00AA00', radius: 0.5 });
        for (let dpsPos of this.dpsOuterPositions)
            visual.circle(dpsPos, { opacity: 0.5, fill: '#0000AA', radius: 0.5 });
        visual.circle(this.tankPosition, { opacity: 0.5, fill: '#AA0000', radius: 0.5 });
    }
    runDuo() {
        const intel = GIntel.rooms[this.roomName];
        const invaderCore = intel.invaderCore && this.room && intel.invaderCore.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_INVADER_CORE);
        if (this.tank) {
            if (this.tank.memory.boosts) {
                this.boostCreep(this.tank);
            }
            else if (!this.healer || this.healer.spawning || this.healer.memory.boosts) {
                this.tank.giveWay();
            }
        }
        if (this.healer) {
            if (this.healer.memory.boosts) {
                this.boostCreep(this.healer);
            }
            else if (!this.tank || this.tank.spawning || this.tank.memory.boosts) {
                this.healer.giveWay();
            }
        }
        if (this.tank && !this.tank.spawning && !this.tank.memory.boosts && this.healer && !this.healer.spawning && !this.healer.memory.boosts) {
            let duo = [this.tank, this.healer];
            if (!this.tankPosition || this.tank.pos.roomName !== this.roomName) {
                const travelOpts = {
                    avoidSourceKeepers: false,
                    ignoreRoads: true,
                    ensurePath: true,
                    avoidUnsafeRooms: false
                };
                Pather.sneakGoTo(duo, intel.invaderCore.pos, 5, travelOpts);
                for (let creep of duo) {
                    if (creep.hits < creep.hitsMax) {
                        creep.heal(creep);
                    }
                }
                this.tank.shootAtWill(this.tank.room.findHostileCreeps());
            }
            else {
                if (!this.tank.pos.isEqualTo(this.tankPosition))
                    CombatPather.goTo(this.tank, this.tankPosition, 0, { obstacles: this.obstacles, squadMembers: [this.healer] });
                else
                    this.tank.rangedAttack(invaderCore);
                let damageOnTank = this.calculateHostileDamage(this.tank.pos);
                let damageOnHealer = this.calculateHostileDamage(this.healer.pos);
                let distanceToTank = invaderCore.pos.getRangeTo(this.tank.pos);
                let distanceToHealer = invaderCore.pos.getRangeTo(this.healer.pos);
                let healTarget;
                if (damageOnHealer > damageOnTank
                    //|| damageOnHealer === damageOnTank && distanceToHealer < distanceToTank
                    || damageOnHealer === damageOnTank && distanceToHealer === distanceToTank && this.healer.ticksToLive < this.tank.ticksToLive) {
                    healTarget = this.healer;
                }
                else {
                    healTarget = this.tank;
                }
                this.healer.heal(healTarget);
                this.tank.heal(this.healer.hits < this.healer.hitsMax ? this.healer : healTarget);
            }
        }
    }
    runDps() {
        var _a, _b;
        const intel = GIntel.rooms[this.roomName];
        const hostileCreeps = ((_a = this.room) === null || _a === void 0 ? void 0 : _a.findHostileCreeps()) || [];
        const invaderCore = intel.invaderCore && this.room && intel.invaderCore.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_INVADER_CORE);
        let hostileStructures = [];
        if (this.room) {
            hostileStructures = (_b = this.room) === null || _b === void 0 ? void 0 : _b.find(FIND_HOSTILE_STRUCTURES).filter(s => {
                if (!s.isAttackable())
                    return false;
                if (s.structureType !== STRUCTURE_RAMPART && !!s.pos.lookFor(LOOK_STRUCTURES).find(r => r.structureType === STRUCTURE_RAMPART))
                    return false;
                return true;
            });
        }
        const goodInnerPositions = this.dpsInnerPositions
            ? this.dpsInnerPositions.filter(pos => this.room && pos.lookInRange(LOOK_STRUCTURES, 3).length > 0 && !pos.lookInRange(LOOK_STRUCTURES, 1).find(s => s.structureType === STRUCTURE_RAMPART && !s.pos.lookFor(LOOK_STRUCTURES).find(t => t.structureType === STRUCTURE_TOWER)))
            : [];
        for (let creep of this.dps) {
            if (creep.memory.boosts) {
                this.boostCreep(creep);
            }
            else if (creep.pos.roomName !== this.roomName) {
                if (this.tank && this.tank.pos.roomName === this.roomName
                    || !_.some(Game.map.describeExits(this.roomName), nextRoom => nextRoom === creep.pos.roomName)) {
                    const travelOpts = {
                        avoidSourceKeepers: false,
                        ignoreRoads: true,
                        ensurePath: true,
                        avoidUnsafeRooms: false
                    };
                    creep.goTo(intel.invaderCore.pos, 5, travelOpts);
                }
                else if (creep.pos.isExit()) {
                    creep.moveOffExit();
                }
                else {
                    creep.giveWay();
                }
                if (creep.hits < creep.hitsMax) {
                    creep.heal(creep);
                }
                creep.shootAtWill(creep.room.findHostileCreeps());
            }
            else {
                const isOnOuterPos = this.dpsOuterPositions.some(pos => pos.isEqualTo(creep.pos));
                const isOnInnerPos = goodInnerPositions.some(pos => pos.isEqualTo(creep.pos));
                if (!isOnInnerPos && goodInnerPositions.some(pos => pos.lookFor(LOOK_CREEPS).length === 0)) {
                    const targetPos = goodInnerPositions.find(pos => pos.lookFor(LOOK_CREEPS).length === 0);
                    CombatPather.goTo(creep, targetPos, 0, { obstacles: [...this.creeps.map(c => c.pos), ...this.obstacles] });
                }
                else if (!isOnOuterPos && !isOnInnerPos) {
                    let targetPos = this.dpsOuterPositions.find(pos => pos.lookFor(LOOK_CREEPS).length === 0);
                    CombatPather.goTo(creep, targetPos, 0, { obstacles: [...this.creeps.map(c => c.pos), ...this.obstacles] });
                }
                let exposedHostilesInRange = hostileCreeps.filter(h => h.pos.inRangeTo(creep, 3) && !h.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_RAMPART));
                if (exposedHostilesInRange.length > 0)
                    creep.shootAtWill(exposedHostilesInRange, _.min(exposedHostilesInRange, h => h.hits));
                else
                    creep.shootAtWill(hostileStructures, invaderCore);
                if (creep.hits < creep.hitsMax) {
                    creep.heal(creep);
                }
            }
        }
    }
    onRun() {
        const intel = GIntel.rooms[this.roomName];
        const invaderCore = intel.invaderCore && this.room && intel.invaderCore.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_INVADER_CORE);
        if (!intel.invaderCore || intel.lastScout === Game.time && !invaderCore) {
            for (let creep of this.creeps)
                this.dismissCreep(creep, true, false);
            this.close();
            return;
        }
        if (this.creeps.length === 0)
            return;
        this.runDuo();
        this.runDps();
        //this.visualize();
    }
}
OperationStrongholdMid.OperationType = 'StrongholdMid';
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationStrongholdMid.prototype, "getSpawnRequestsInternal", null);
class FlagOperationStrongholdMid extends OperationStrongholdMid {
    constructor(empire, id) {
        super(empire, id);
    }
    init(roomName) {
        if (Memory.flags[this.id])
            return;
        const intel = GIntel.rooms[this.roomName];
        if (!intel.invaderCore)
            return;
        let operationMemory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            //
            closing: false,
            //
            roomName: roomName,
            tank: null,
            healer: null,
            dps: []
        };
        Memory.flags[this.id] = operationMemory;
    }
    deleteMemory() {
        delete Memory.flags[this.id];
    }
    get memory() {
        return Memory.flags[this.id];
    }
    get flag() {
        return Game.flags[this.id];
    }
    get roomName() {
        return this.flag.pos.roomName;
    }
}

class OperationStrongholdHigh extends BaseGlobalOperation {
    constructor(empire, id) {
        super(empire, id);
        this.healerTargetCount = 3;
        this.dpsTargetCount = 11;
        this.tankBody = new CreepBody('43T1H6M');
        this.healerBody = new CreepBody('2T6M42H');
        this.dpsBody = new CreepBody('39R10M1H');
        this.flee = false;
        this.tankRequestId = null;
        this.healerRequestIds = [];
        this.dpsRequestIds = [];
        if (this.memory && this.memory.tankPosition) {
            this.tankPosition = RoomPosition.deserialize(this.memory.tankPosition);
            this.dpsCorner = RoomPosition.deserialize(this.memory.dpsCorner);
            this.dpsR3Positions = this.memory.dpsR3Positions.map(pos => RoomPosition.deserialize(pos));
            this.dpsR2Positions = this.memory.dpsR2Positions.map(pos => RoomPosition.deserialize(pos));
            this.dpsR1Positions = this.memory.dpsR1Positions.map(pos => RoomPosition.deserialize(pos));
        }
        const intel = GIntel.rooms[this.roomName];
        const invaderCorePos = intel.invaderCore.pos;
        this.obstacles = [];
        for (let i = -2; i <= 2; ++i) {
            this.obstacles.push(new RoomPosition(invaderCorePos.x - 4, invaderCorePos.y + i, invaderCorePos.roomName));
            this.obstacles.push(new RoomPosition(invaderCorePos.x + 4, invaderCorePos.y + i, invaderCorePos.roomName));
            this.obstacles.push(new RoomPosition(invaderCorePos.x + i, invaderCorePos.y - 4, invaderCorePos.roomName));
            this.obstacles.push(new RoomPosition(invaderCorePos.x + i, invaderCorePos.y + 4, invaderCorePos.roomName));
        }
        this.obstacles.push(new RoomPosition(invaderCorePos.x - 3, invaderCorePos.y - 3, invaderCorePos.roomName));
        this.obstacles.push(new RoomPosition(invaderCorePos.x - 3, invaderCorePos.y + 3, invaderCorePos.roomName));
        this.obstacles.push(new RoomPosition(invaderCorePos.x + 3, invaderCorePos.y - 3, invaderCorePos.roomName));
        this.obstacles.push(new RoomPosition(invaderCorePos.x + 3, invaderCorePos.y + 3, invaderCorePos.roomName));
        this.obstacles.push(new RoomPosition(invaderCorePos.x - 3, invaderCorePos.y - 4, invaderCorePos.roomName));
        this.obstacles.push(new RoomPosition(invaderCorePos.x - 4, invaderCorePos.y - 3, invaderCorePos.roomName));
        this.obstacles.push(new RoomPosition(invaderCorePos.x - 3, invaderCorePos.y + 4, invaderCorePos.roomName));
        this.obstacles.push(new RoomPosition(invaderCorePos.x - 4, invaderCorePos.y + 3, invaderCorePos.roomName));
        this.obstacles.push(new RoomPosition(invaderCorePos.x + 3, invaderCorePos.y - 4, invaderCorePos.roomName));
        this.obstacles.push(new RoomPosition(invaderCorePos.x + 4, invaderCorePos.y - 3, invaderCorePos.roomName));
        this.obstacles.push(new RoomPosition(invaderCorePos.x + 3, invaderCorePos.y + 4, invaderCorePos.roomName));
        this.obstacles.push(new RoomPosition(invaderCorePos.x + 4, invaderCorePos.y + 3, invaderCorePos.roomName));
    }
    init(roomName, strongholLevel) {
        if (Memory.operations[this.id])
            return;
        let operationMemory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            //
            closing: false,
            //
            roomName: roomName,
            tank: null,
            healers: [],
            dps: []
        };
        Memory.operations[this.id] = operationMemory;
    }
    get memory() {
        return super.memory;
    }
    onInitForTick() {
        super.onInitForTick();
        this.memory.tank = this.memory.creeps.includes(this.memory.tank) ? this.memory.tank : null;
        this.memory.healers = this.memory.healers.filter(creepName => this.memory.creeps.includes(creepName));
        this.memory.dps = this.memory.dps.filter(creepName => this.memory.creeps.includes(creepName));
        this.tank = Game.creeps[this.memory.tank];
        this.healers = this.memory.healers.map(healerName => Game.creeps[healerName]);
        this.dps = this.memory.dps.map(dpsName => Game.creeps[dpsName]);
        if (!this.tankPosition && this.tank && this.tank.pos.roomName === this.roomName)
            this.selectPositions(this.room, this.tank.pos);
        const enterPosFlag = Game.flags['EnterPos'];
        if (this.room && enterPosFlag)
            this.selectPositions(this.room, enterPosFlag.pos);
        if (this.room) {
            this.obstacles = this.obstacles.filter(o => !!o.lookInRange(LOOK_STRUCTURES, 1).find(s => s.structureType === STRUCTURE_RAMPART));
        }
    }
    updateEstimatedStats() {
        this.estimatedStats.energyPerTick = -this.tankBody.cost / CREEP_LIFE_TIME;
        this.estimatedStats.spawnTime = this.tankBody.spawnTime;
        this.estimatedStats.baseCpu = 0.4;
    }
    isValidSpawnRoom(myRoom) {
        const maxCreepCost = Math.max(this.tankBody.cost, this.healerBody.cost, this.dpsBody.cost);
        if (myRoom.room.energyCapacityAvailable < maxCreepCost)
            return false;
        if (50 * Game.map.getRoomLinearDistance(myRoom.roomName, this.roomName) > CREEP_LIFE_TIME * 0.666)
            return false;
        return true;
    }
    hasEnoughResources(myRoom) {
        // TODO - account for already spawned and boosted creeps
        let creepCost = this.tankBody.cost + this.healerBody.cost + 5 * this.dpsBody.cost;
        if (myRoom.getStoredResource(RES_ENERGY) < creepCost)
            return false;
        const boosts = [RES_XGHO2, RES_XLHO2, /*RES_XKHO2,*/ RES_XZHO2];
        for (let boost of boosts) {
            let boostNeeded = 0;
            boostNeeded += (this.tank ? 0 : 1) * (this.tankBody[BOOST_TO_BODYPART[boost]] || 0) * LAB_BOOST_MINERAL;
            boostNeeded += (this.healerTargetCount - this.healers.length) * (this.healerBody[BOOST_TO_BODYPART[boost]] || 0) * LAB_BOOST_MINERAL;
            boostNeeded += (this.dpsTargetCount - this.dps.length) * (this.dpsBody[BOOST_TO_BODYPART[boost]] || 0) * LAB_BOOST_MINERAL;
            if (GEmpire.getStoredResource(boost) < boostNeeded)
                return false;
        }
        return true;
    }
    getSpawnRequestsInternal() {
        if (this.memory.closing)
            return [];
        const startedSpawning = !!this.tank || this.healers.length > 0 || this.dps.length > 0;
        const priority = startedSpawning ? StartedSquadPriority : FlagSpawnPriority;
        let result = [];
        if (!this.tank) {
            this.tankRequestId = generateRandomKey(5);
            result.push({
                id: this.tankRequestId,
                nameBase: 'Tank',
                priority: priority,
                minEnergy: this.tankBody.cost,
                parts: this.tankBody,
                memory: {},
                boostOptions: [[RES_XGHO2, RES_XLHO2, RES_XZHO2]],
                noRepurpose: true,
                operation: this
            });
        }
        if (this.healers.length < this.healerTargetCount) {
            this.healerRequestIds = [];
            for (let i = this.healers.length; i < this.healerTargetCount; ++i) {
                const healerRequestId = generateRandomKey(5);
                this.healerRequestIds.push(healerRequestId);
                result.push({
                    id: healerRequestId,
                    nameBase: 'Healer',
                    priority: priority,
                    minEnergy: this.healerBody.cost,
                    parts: this.healerBody,
                    memory: {},
                    boostOptions: [[RES_XGHO2, RES_XLHO2, RES_XZHO2]],
                    noRepurpose: true,
                    operation: this
                });
            }
        }
        if (this.dps.length < this.dpsTargetCount) {
            this.dpsRequestIds = [];
            for (let i = this.dps.length; i < this.dpsTargetCount; ++i) {
                const dpsRequestId = generateRandomKey(5);
                this.dpsRequestIds.push(dpsRequestId);
                result.push({
                    id: dpsRequestId,
                    nameBase: 'DPS',
                    priority: priority,
                    minEnergy: this.dpsBody.cost,
                    parts: this.dpsBody,
                    memory: {},
                    boostOptions: [[RES_XLHO2, RES_XKHO2, RES_XZHO2], [RES_XLHO2, RES_KHO2, RES_XZHO2], [RES_XLHO2, RES_KO, RES_XZHO2], [RES_XLHO2, RES_XZHO2]],
                    noRepurpose: true,
                    operation: this
                });
            }
        }
        return result;
    }
    onSpawn(requestId, creepName) {
        super.onSpawn(requestId, creepName);
        if (this.tankRequestId === requestId) {
            this.memory.tank = creepName;
            this.tankRequestId = null;
        }
        else if (this.healerRequestIds.includes(requestId)) {
            this.memory.healers.push(creepName);
            _.pull(this.healerRequestIds, creepName);
        }
        else if (this.dpsRequestIds.includes(requestId)) {
            this.memory.dps.push(creepName);
            _.pull(this.dpsRequestIds, creepName);
        }
    }
    onCreepDeath(creepName) {
        if (this.memory.tank === creepName) {
            this.memory.tank = null;
        }
        else if (this.memory.healers.includes(creepName)) {
            _.pull(this.memory.healers, creepName);
        }
        else if (this.memory.dps.includes(creepName)) {
            _.pull(this.memory.dps, creepName);
        }
    }
    selectPositions(room, enterPos) {
        const intel = GIntel.rooms[this.roomName];
        const invaderCorePos = intel.invaderCore.pos;
        const terrain = Game.map.getRoomTerrain(room.name);
        const tankCornerOffsets = [
            { x: -5, y: -4 },
            { x: -4, y: -5 },
            { x: 3, y: -5 },
            { x: 4, y: -4 },
            { x: -4, y: 4 },
            { x: -5, y: 3 },
            { x: 4, y: 3 },
            { x: 3, y: 4 }
        ];
        let tankCorners = tankCornerOffsets
            .filter(o => {
            if (invaderCorePos.x + o.x < 1 || invaderCorePos.x + o.x > 47)
                return false;
            if (invaderCorePos.y + o.y < 1 || invaderCorePos.y + o.y > 47)
                return false;
            return true;
        })
            .map(o => new RoomPosition(invaderCorePos.x + o.x, invaderCorePos.y + o.y, invaderCorePos.roomName));
        tankCorners = tankCorners.filter(c => {
            if ((terrain.get(c.x, c.y) & TERRAIN_MASK_WALL) > 0)
                return false;
            if ((terrain.get(c.x + 1, c.y) & TERRAIN_MASK_WALL) > 0)
                return false;
            if ((terrain.get(c.x, c.y + 1) & TERRAIN_MASK_WALL) > 0)
                return false;
            if ((terrain.get(c.x + 1, c.y + 1) & TERRAIN_MASK_WALL) > 0)
                return false;
            return true;
        });
        const pathToClosestCorner = Pather.findPathToClosest(enterPos, tankCorners.map(corner => ({ pos: corner, range: 0 })), { obstacles: this.obstacles });
        this.tankPosition = _.last(pathToClosestCorner.path);
        let dpsCorners = [
            new RoomPosition(invaderCorePos.x - 3, invaderCorePos.y - 3, invaderCorePos.roomName),
            new RoomPosition(invaderCorePos.x - 3, invaderCorePos.y + 3, invaderCorePos.roomName),
            new RoomPosition(invaderCorePos.x + 3, invaderCorePos.y - 3, invaderCorePos.roomName),
            new RoomPosition(invaderCorePos.x + 3, invaderCorePos.y + 3, invaderCorePos.roomName)
        ];
        dpsCorners = dpsCorners.filter(corner => !corner.inRangeTo(this.tankPosition, 2));
        this.dpsCorner = _.max(dpsCorners, corner => corner.lookInRange(LOOK_TERRAIN, 3).filter(t => t !== 'wall').length);
        const r3offsets = [
            { x: 1, y: 1 },
            { x: 1, y: 2 },
            { x: 2, y: 1 },
            { x: 0, y: 2 },
            { x: 2, y: 0 },
            { x: -1, y: 2 },
            { x: 2, y: -1 },
            { x: -2, y: 2 },
            { x: 2, y: -2 },
            { x: -3, y: 2 },
            { x: 2, y: -3 }
        ];
        const r2offsets = [
            { x: 0, y: 0 },
            { x: 0, y: 1 },
            { x: 1, y: 0 },
            { x: -1, y: 1 },
            { x: 1, y: -1 },
            { x: -2, y: 1 },
            { x: 1, y: -2 },
            { x: -3, y: 1 },
            { x: 1, y: -3 }
        ];
        const r1offsets = [
            { x: -1, y: -1 },
            { x: -1, y: 0 },
            { x: 0, y: -1 },
            { x: -2, y: 0 },
            { x: 0, y: -2 },
            { x: -3, y: 0 },
            { x: 0, y: -3 }
        ];
        const cornerDirectionVector = {
            x: Math.sign(this.dpsCorner.x - invaderCorePos.x),
            y: Math.sign(this.dpsCorner.y - invaderCorePos.y)
        };
        this.dpsR3Positions = r3offsets
            .filter(o => {
            if (this.dpsCorner.x + o.x * cornerDirectionVector.x < 1 || this.dpsCorner.x + o.x * cornerDirectionVector.x > 48)
                return false;
            if (this.dpsCorner.y + o.y * cornerDirectionVector.y < 1 || this.dpsCorner.y + o.y * cornerDirectionVector.y > 48)
                return false;
            return true;
        })
            .map(o => new RoomPosition(this.dpsCorner.x + o.x * cornerDirectionVector.x, this.dpsCorner.y + o.y * cornerDirectionVector.y, this.dpsCorner.roomName))
            .filter(pos => (terrain.get(pos.x, pos.y) & TERRAIN_MASK_WALL) === 0);
        this.dpsR2Positions = r2offsets
            .filter(o => {
            if (this.dpsCorner.x + o.x * cornerDirectionVector.x < 1 || this.dpsCorner.x + o.x * cornerDirectionVector.x > 48)
                return false;
            if (this.dpsCorner.y + o.y * cornerDirectionVector.y < 1 || this.dpsCorner.y + o.y * cornerDirectionVector.y > 48)
                return false;
            return true;
        })
            .map(o => new RoomPosition(this.dpsCorner.x + o.x * cornerDirectionVector.x, this.dpsCorner.y + o.y * cornerDirectionVector.y, this.dpsCorner.roomName))
            .filter(pos => (terrain.get(pos.x, pos.y) & TERRAIN_MASK_WALL) === 0);
        this.dpsR1Positions = r1offsets
            .filter(o => {
            if (this.dpsCorner.x + o.x * cornerDirectionVector.x < 1 || this.dpsCorner.x + o.x * cornerDirectionVector.x > 48)
                return false;
            if (this.dpsCorner.y + o.y * cornerDirectionVector.y < 1 || this.dpsCorner.y + o.y * cornerDirectionVector.y > 48)
                return false;
            return true;
        })
            .map(o => new RoomPosition(this.dpsCorner.x + o.x * cornerDirectionVector.x, this.dpsCorner.y + o.y * cornerDirectionVector.y, this.dpsCorner.roomName))
            .filter(pos => (terrain.get(pos.x, pos.y) & TERRAIN_MASK_WALL) === 0);
        this.memory.tankPosition = this.tankPosition.serialize();
        this.memory.dpsCorner = this.dpsCorner.serialize();
        this.memory.dpsR3Positions = this.dpsR3Positions.map(pos => pos.serialize());
        this.memory.dpsR2Positions = this.dpsR2Positions.map(pos => pos.serialize());
        this.memory.dpsR1Positions = this.dpsR1Positions.map(pos => pos.serialize());
    }
    calculateHostileDamage(pos) {
        let result = 0;
        let towers = this.room.find(FIND_STRUCTURES).filter(s => s.structureType === STRUCTURE_TOWER);
        for (let tower of towers) {
            result += TOWER_POWER_ATTACK * Common.calcTowerMultiplier(pos.x, pos.y, tower.pos.x, tower.pos.y);
        }
        let hostileDamage = CombatData.getHostileCreepDamage(pos.roomName);
        result += hostileDamage[pos.y * 50 + pos.x];
        return result;
    }
    visualize() {
        if (!this.tankPosition)
            return;
        const visual = new RoomVisual(this.roomName);
        for (let obstacle of this.obstacles)
            visual.rect(obstacle.x - 0.25, obstacle.y - 0.25, 0.5, 0.5, { opacity: 0.5, fill: null, stroke: '#AA0000', strokeWidth: 0.1 });
        for (let dpsPos of this.dpsR3Positions)
            visual.circle(dpsPos, { opacity: 0.3, fill: '#0000AA', radius: 0.5 });
        for (let dpsPos of this.dpsR2Positions)
            visual.circle(dpsPos, { opacity: 0.4, fill: '#0000AA', radius: 0.5 });
        for (let dpsPos of this.dpsR1Positions)
            visual.circle(dpsPos, { opacity: 0.5, fill: '#0000AA', radius: 0.5 });
        visual.circle(this.tankPosition, { opacity: 0.5, fill: '#00AA00', radius: 0.5 });
    }
    getTankInSquadPosition() {
        const intel = GIntel.rooms[this.roomName];
        const invaderCorePos = intel.invaderCore.pos;
        if (this.tankPosition.x < invaderCorePos.x) {
            if (this.tankPosition.y < invaderCorePos.y) {
                return 3;
            }
            else {
                return 1;
            }
        }
        else {
            if (this.tankPosition.y < invaderCorePos.y) {
                return 2;
            }
            else {
                return 0;
            }
        }
    }
    runQuad() {
        const intel = GIntel.rooms[this.roomName];
        const areReady = this.tank && !this.tank.spawning && !this.tank.memory.boosts && this.healers.length === 3 && this.healers.every(h => !h.spawning && !h.memory.boosts);
        if (!areReady) {
            if (this.tank) {
                if (this.tank.memory.boosts) {
                    this.boostCreep(this.tank);
                }
                else {
                    this.tank.giveWay();
                }
            }
            for (let healer of this.healers) {
                if (healer.memory.boosts) {
                    this.boostCreep(healer);
                }
                else {
                    healer.giveWay();
                }
            }
        }
        else {
            let squad = [this.tank, ...this.healers];
            if (!this.tankPosition || this.tank.pos.roomName !== this.roomName) {
                if (_.some(Game.map.describeExits(this.roomName), nextRoom => nextRoom === this.tank.pos.roomName)) {
                    CombatPather.goTo(this.tank, intel.invaderCore.pos, 5, { squadMembers: this.healers, avoidNarrowPaths: true });
                }
                else {
                    const travelOpts = {
                        avoidSourceKeepers: false,
                        ignoreRoads: true,
                        ensurePath: true,
                        avoidUnsafeRooms: false
                    };
                    Pather.sneakGoTo(squad, intel.invaderCore.pos, 5, travelOpts);
                }
                for (let creep of squad) {
                    if (creep.hits < creep.hitsMax) {
                        creep.heal(creep);
                    }
                }
            }
            else {
                let tankInSquadPosition = this.getTankInSquadPosition();
                squad = [...this.healers];
                squad.splice(tankInSquadPosition, 0, this.tank);
                if (!squad[0].pos.isEqualTo(this.tankPosition))
                    CombatPather.goTo(squad[0], this.tankPosition, 0, { obstacles: this.obstacles.filter(o => !o.isNearTo(this.tankPosition)), squadMembers: squad.slice(1), avoidNarrowPaths: true });
                for (let healer of this.healers) {
                    let healTarget = _.max(squad.filter(c => c.pos.roomName === healer.pos.roomName), c => this.calculateHostileDamage(c.pos) - c.ticksToLive / 1500);
                    if (healer.pos.isNearTo(healTarget))
                        healer.heal(healTarget);
                    else
                        healer.rangedHeal(healTarget);
                }
                let lowestHpCreep = _.min(squad, c => c.hits);
                if (lowestHpCreep.hits < lowestHpCreep.hitsMax)
                    this.tank.heal(lowestHpCreep);
                else if (this.tank.pos.lookInRange(LOOK_CREEPS, 1).find(c => !c.my && c.getActiveBodyparts(RANGED_ATTACK) > 0))
                    this.tank.heal(this.healers[0]);
                else
                    this.tank.heal(this.tank);
            }
        }
    }
    runDps() {
        var _a;
        const intel = GIntel.rooms[this.roomName];
        const hostileCreeps = ((_a = this.room) === null || _a === void 0 ? void 0 : _a.findHostileCreeps()) || [];
        const invaderCore = intel.invaderCore && this.room && intel.invaderCore.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_INVADER_CORE);
        let hostileStructures = [];
        if (this.room && this.dpsCorner) {
            hostileStructures = this.dpsCorner.lookInRange(LOOK_STRUCTURES, 3)
                .filter(s => {
                if (!s.isAttackable())
                    return false;
                if (s.structureType === STRUCTURE_CONTAINER)
                    return false;
                if (s.structureType !== STRUCTURE_RAMPART && !!s.pos.lookFor(LOOK_STRUCTURES).find(r => r.structureType === STRUCTURE_RAMPART))
                    return false;
                return true;
            });
        }
        let goodPositions = this.tank && this.tank.pos.roomName === this.roomName && this.tank.pos.inRangeTo(invaderCore.pos, 5)
            ? [
                this.dpsR1Positions ? this.dpsR1Positions.filter(pos => this.room && pos.lookInRange(LOOK_STRUCTURES, 3).filter(s => s.structureType !== STRUCTURE_CONTAINER).length > 0 && !pos.lookInRange(LOOK_STRUCTURES, 1).find(s => s.structureType === STRUCTURE_RAMPART && !s.pos.lookFor(LOOK_STRUCTURES).find(t => t.structureType === STRUCTURE_TOWER))) : [],
                this.dpsR2Positions ? this.dpsR2Positions.filter(pos => this.room && pos.lookInRange(LOOK_STRUCTURES, 3).filter(s => s.structureType !== STRUCTURE_CONTAINER).length > 0 && !pos.lookInRange(LOOK_STRUCTURES, 1).find(s => s.structureType === STRUCTURE_RAMPART && !s.pos.lookFor(LOOK_STRUCTURES).find(t => t.structureType === STRUCTURE_TOWER))) : [],
                this.dpsR3Positions ? this.dpsR3Positions.filter(pos => this.room && pos.lookInRange(LOOK_STRUCTURES, 3).filter(s => s.structureType !== STRUCTURE_CONTAINER).length > 0 && !pos.lookInRange(LOOK_STRUCTURES, 1).find(s => s.structureType === STRUCTURE_RAMPART && !s.pos.lookFor(LOOK_STRUCTURES).find(t => t.structureType === STRUCTURE_TOWER))) : []
            ]
            : [[]];
        for (let creep of this.dps) {
            const isInNeighbourRoom = _.some(Game.map.describeExits(this.roomName), nextRoom => nextRoom === creep.pos.roomName);
            if (creep.memory.boosts) {
                this.boostCreep(creep);
            }
            else if (creep.pos.roomName === this.roomName && (!this.tank || this.tank.ticksToLive < 20 || this.tank.pos.roomName !== this.roomName)) {
                creep.fleeFromRoom(this.roomName);
            }
            else if (isInNeighbourRoom && (!this.tank || this.tank.ticksToLive < 20 || this.tank.pos.roomName !== this.roomName)) {
                if (creep.pos.isExit())
                    creep.moveOffExit();
                else
                    creep.giveWay(true);
            }
            else if (creep.pos.roomName !== this.roomName && goodPositions.every(gp => gp.length === 0)) {
                if (this.tank && this.tank.pos.roomName === this.roomName && this.tank.pos.inRangeTo(invaderCore.pos, 5)
                    || !isInNeighbourRoom
                //|| isInNeighbourRoom && Common.getExitTiles(creep.pos.roomName, Game.rooms[creep.pos.roomName].getExitTo(this.roomName)).every(exit => !creep.pos.inRangeTo(exit, 3))
                ) {
                    const travelOpts = {
                        avoidSourceKeepers: false,
                        ignoreRoads: true,
                        ensurePath: true,
                        avoidUnsafeRooms: false
                    };
                    creep.goTo(intel.invaderCore.pos, 5, travelOpts);
                }
                else if (creep.pos.isExit()) {
                    creep.moveOffExit();
                }
                else {
                    creep.giveWay();
                }
                if (creep.hits < creep.hitsMax) {
                    creep.heal(creep);
                }
                creep.shootAtWill(creep.room.findHostileCreeps());
            }
            else {
                for (let ring of goodPositions) {
                    const isInRing = ring.some(pos => pos.isEqualTo(creep.pos));
                    const emptySpot = ring.find(pos => pos.lookFor(LOOK_CREEPS).length === 0);
                    if (emptySpot && (!isInRing || ring.findIndex(pos => pos.isEqualTo(creep.pos)) > ring.findIndex(pos => pos.isEqualTo(emptySpot)))) {
                        CombatPather.goTo(creep, emptySpot, 0, { obstacles: [...this.creeps.map(c => c.pos), ...this.obstacles] });
                        break;
                    }
                    else if (isInRing) {
                        break;
                    }
                }
                let exposedHostilesInRange = hostileCreeps.filter(h => h.pos.inRangeTo(creep, 3) && !h.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_RAMPART));
                if (exposedHostilesInRange.length > 0)
                    creep.shootAtWill(exposedHostilesInRange, _.min(exposedHostilesInRange, h => h.hits));
                else if (invaderCore.pos.inRangeTo(creep.pos, 3))
                    creep.shootAtWill(hostileStructures, invaderCore);
                else
                    creep.shootAtWill(hostileStructures);
                if (creep.hits < creep.hitsMax) {
                    creep.heal(creep);
                }
            }
        }
    }
    onRun() {
        const intel = GIntel.rooms[this.roomName];
        const invaderCore = intel.invaderCore && this.room && intel.invaderCore.pos.lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_INVADER_CORE);
        if (!intel.invaderCore || intel.lastScout === Game.time && !invaderCore) {
            for (let creep of this.creeps)
                this.dismissCreep(creep, true, false);
            this.close();
            return;
        }
        if (this.creeps.length > 0) {
            if (this.flee) {
                for (let creep of this.creeps) {
                    creep.fleeFromRoom(this.roomName);
                }
            }
            else {
                this.runQuad();
                this.runDps();
            }
        }
        //this.visualize();
    }
}
OperationStrongholdHigh.OperationType = 'StrongholdHigh';
__decorate([
    profile("SpawnLogic" /* ProfilerFunctionType.SpawnLogic */)
], OperationStrongholdHigh.prototype, "getSpawnRequestsInternal", null);
class FlagOperationStrongholdHigh extends OperationStrongholdHigh {
    constructor(empire, id) {
        super(empire, id);
    }
    init(roomName) {
        if (Memory.flags[this.id])
            return;
        const intel = GIntel.rooms[this.roomName];
        if (!intel.invaderCore)
            return;
        let operationMemory = {
            creeps: [],
            targetScale: 0,
            cpu: 0,
            //
            closing: false,
            //
            roomName: roomName,
            tank: null,
            healers: [],
            dps: []
        };
        Memory.flags[this.id] = operationMemory;
    }
    onInitForTick() {
        this.flee = this.flag.color === COLOR_GREY;
        super.onInitForTick();
    }
    deleteMemory() {
        delete Memory.flags[this.id];
    }
    get memory() {
        return Memory.flags[this.id];
    }
    get flag() {
        return Game.flags[this.id];
    }
    get roomName() {
        return this.flag.pos.roomName;
    }
}

const ExpectedOperationConstructors = {
    [OperationHarass.OperationType]: OperationHarass,
    [OperationGuard.OperationType]: OperationGuard,
    [OperationDeclaim.OperationType]: OperationDeclaim,
    [OperationRaid.OperationType]: OperationRaid
};
const GlobalOperationConstructors = {
    [OperationClaim.OperationType]: OperationClaim,
    [OperationHarass.OperationType]: OperationHarass,
    [OperationHitSquad.OperationType]: OperationHitSquad,
    [OperationGuard.OperationType]: OperationGuard,
    [OperationBuildSupport.OperationType]: OperationBuildSupport,
    [OperationDeclaim.OperationType]: OperationDeclaim,
    [OperationRaid.OperationType]: OperationRaid,
    [OperationSupply.OperationType]: OperationSupply,
    [OperationDeposit.OperationType]: OperationDeposit,
    [OperationPowerHarvest.OperationType]: OperationPowerHarvest,
    [OperationDemolish.OperationType]: OperationDemolish,
    [OperationSkirmish.OperationType]: OperationSkirmish
};
const FlagOperationConstructors = {
    'Drain': FlagOperationDrain,
    'Salvage': FlagOperationSalvageTeam,
    'Demolisher': FlagOperationDemolisher,
    'Swarm': FlagOperationSwarm,
    'HitSquad': FlagOperationHitSquad,
    'HitDuo': FlagOperationHitDuo,
    'Build': FlagOperationBuildSupport,
    'Supply': FlagOperationSupply,
    'StrongholdLow': FlagOperationStrongholdLow,
    'StrongholdMid': FlagOperationStrongholdMid,
    'StrongholdHigh': FlagOperationStrongholdHigh
};
class Strategist {
    constructor(empire) {
        this.empire = empire;
        Memory.strategies = Memory.strategies || {};
        this.strategyClaim = new StrategyClaim(empire);
        this.strategyHarass = new StrategyHarass(empire);
        this.strategySiege = new StrategySiege(empire);
        this.strategyHighwayHarvesting = new StrategyHighwayHarvesting(empire);
        this.strategyStomp = new StrategyStomp(empire);
        this.strategyPeacekeeping = new StrategyPeacekeeping(empire);
        this.strategyRoomSupport = new StrategyRoomSupport(empire);
        this.globalOperations = {};
        for (let operationName in Memory.operations) {
            let constructorKey = Object.keys(GlobalOperationConstructors).find(operationNameBase => operationName.startsWith(operationNameBase));
            if (constructorKey) {
                const operationMemory = Memory.operations[operationName];
                const spawnRoomName = operationMemory && operationMemory.spawnRoom;
                if (spawnRoomName && (!Game.rooms[spawnRoomName] || !Game.rooms[spawnRoomName].controller.my))
                    operationMemory.spawnRoom = undefined;
                let operationConstructor = GlobalOperationConstructors[constructorKey];
                this.globalOperations[operationName] = new operationConstructor(this.empire, operationName);
            }
        }
        for (let flagName in Game.flags) {
            let constructorKey = Object.keys(FlagOperationConstructors).find(operationNameBase => flagName.startsWith(operationNameBase));
            if (constructorKey) {
                const operationMemory = Memory.flags[flagName];
                const spawnRoomName = operationMemory && operationMemory.spawnRoom;
                if (spawnRoomName && (!Game.rooms[spawnRoomName] || !Game.rooms[spawnRoomName].controller.my))
                    operationMemory.spawnRoom = undefined;
                let operationConstructor = FlagOperationConstructors[constructorKey];
                this.globalOperations[flagName] = new operationConstructor(this.empire, flagName);
            }
        }
    }
    clearFinishedOperations() {
        for (let operationId in this.globalOperations) {
            let operation = this.globalOperations[operationId];
            if (operation.readyToDelete) {
                if (operation.spawnRoom) {
                    let myRoom = this.empire.myRooms.find(mr => mr.roomName === operation.spawnRoomName);
                    _.remove(myRoom.globalOperations, operation);
                }
                this.globalOperations[operationId].deleteMemory();
                delete this.globalOperations[operationId];
            }
        }
    }
    run(myRooms) {
        if (_.random(0, 9) !== 0)
            return;
        // clean up
        this.clearFinishedOperations();
        // flag operations
        let flagOperationNames = Object.keys(FlagOperationConstructors);
        for (let flagName in Game.flags) {
            let flag = Game.flags[flagName];
            if (flag.secondaryColor === COLOR_RED) {
                if (this.globalOperations[flagName])
                    this.globalOperations[flagName].close();
                else
                    flag.remove();
                continue;
            }
            if (this.globalOperations[flagName])
                continue;
            let operationName = flagOperationNames.find(operationNameBase => flagName.startsWith(operationNameBase));
            if (operationName) {
                const operationConstructor = FlagOperationConstructors[operationName];
                const newOperation = new operationConstructor(this.empire, flagName);
                newOperation.init(flag.pos.roomName);
                newOperation.initForTick();
                this.globalOperations[flagName] = newOperation;
            }
        }
        //
        let strategies = [
            this.strategyClaim,
            this.strategyHarass,
            this.strategySiege,
            this.strategyHighwayHarvesting,
            this.strategyStomp,
            this.strategyPeacekeeping,
            this.strategyRoomSupport
        ];
        for (let strategy of strategies) {
            let newGlobalOperations = strategy.createGlobalOperations(this.globalOperations);
            if (newGlobalOperations) {
                for (let o of newGlobalOperations)
                    this.globalOperations[o.id] = o;
            }
        }
        //
        let expectedOperations = {};
        for (let flagName in Game.flags) {
            let flag = Game.flags[flagName];
            if (flag.secondaryColor === COLOR_RED)
                continue;
            const flagRoomName = flag.pos.roomName;
            const roomIntel = GIntel.rooms[flagRoomName];
            if (flagName.startsWith('Declaim')) {
                if (!roomIntel || roomIntel.isHostile) {
                    expectedOperations[flagRoomName] = expectedOperations[flagRoomName] || {};
                    expectedOperations[flagRoomName].Declaim = expectedOperations[flagRoomName].Declaim || 0;
                    ++expectedOperations[flagRoomName].Declaim;
                }
            }
            else if (flagName.startsWith('Guard')) {
                expectedOperations[flagRoomName] = expectedOperations[flagRoomName] || {};
                expectedOperations[flagRoomName].Guard = expectedOperations[flagRoomName].Guard || 1;
            }
            else if (flagName.startsWith('Harass')) {
                expectedOperations[flagRoomName] = expectedOperations[flagRoomName] || {};
                expectedOperations[flagRoomName].Harass = expectedOperations[flagRoomName].Harass || 0;
                ++expectedOperations[flagRoomName].Harass;
            }
            else if (flagName.startsWith('Raid')) {
                expectedOperations[flagRoomName] = expectedOperations[flagRoomName] || {};
                expectedOperations[flagRoomName].Raid = expectedOperations[flagRoomName].Raid || 0;
                ++expectedOperations[flagRoomName].Raid;
            }
            //else if (flagName.startsWith('Supply') && (roomIntel.isMy || roomIntel.owner && Config.ALLIES.has(roomIntel.owner))) {
            //  expectedOperations[flagRoomName] = expectedOperations[flagRoomName] || {};
            //  expectedOperations[flagRoomName].Supply = expectedOperations[flagRoomName].Supply || 1;
            //}
        }
        //
        for (let operationId in this.globalOperations) {
            let operation = this.globalOperations[operationId];
            let roomName = operation.roomName;
            let constructor = _.find(GlobalOperationConstructors, value => value === operation.constructor);
            // flag operation
            if (!constructor)
                continue;
            // expected and active
            if (expectedOperations[roomName] && constructor.OperationType in expectedOperations[roomName]) {
                let operationType = constructor.OperationType;
                if (operationType in expectedOperations[roomName])
                    --expectedOperations[roomName][operationType];
                if (expectedOperations[roomName][operationType] <= 0)
                    delete expectedOperations[roomName][operationType];
            }
        }
        // add missing operations
        for (let roomName in expectedOperations)
            for (let key in expectedOperations[roomName]) {
                // TODO - this should never happen
                if (roomName === undefined || roomName === 'undefined') {
                    console.log(`operation ${key} has undefined roomName`);
                }
                let operationType = key;
                errGuard(() => {
                    const operationConstructor = ExpectedOperationConstructors[operationType];
                    const operationId = operationType + '_' + roomName + '_' + Game.time;
                    const newOperation = new operationConstructor(this.empire, operationId);
                    newOperation.init(roomName);
                    newOperation.initForTick();
                    this.globalOperations[operationId] = newOperation;
                });
            }
    }
    showStatus() {
        let myAttacks = _(this.globalOperations)
            .filter((o) => (o instanceof OperationHitSquad || o instanceof FlagOperationSwarm) && !!o.memory)
            .map(o => (GIntel.rooms[o.roomName] ? '  ' + GIntel.rooms[o.roomName].owner : '') + ' in ' + o.roomName)
            .value();
        Visual.addText(undefined, 'War manager', 'Attacking: ' + (myAttacks.length === 0 ? 'None' : ''));
        for (let attack of myAttacks)
            Visual.addText(undefined, 'War manager', attack);
    }
}
__decorate([
    profile()
], Strategist.prototype, "run", null);

const RequestTypeStr = {
    [0 /* RequestType.RESOURCE */]: 'RESOURCE',
    [1 /* RequestType.DEFENSE */]: 'DEFENSE',
    [2 /* RequestType.ATTACK */]: 'ATTACK',
    [3 /* RequestType.EXECUTE */]: 'EXECUTE',
    [4 /* RequestType.HATE */]: 'HATE',
    [5 /* RequestType.FUNNEL */]: 'FUNNEL'
};
function logRequests(allyName, requests, rawRequests) {
    let log = allyName + ':<br/>';
    if (requests && _.isArray(requests)) {
        for (let r of requests) {
            log += RequestTypeStr[r.requestType] + ' - ';
            if (r.requestType === 0 /* RequestType.RESOURCE */)
                log += `resourceType: ${r.resourceType}, maxAmount: ${r.maxAmount}, room: ${r.roomName}, priority: ${r.priority}<br/>`;
            else if (r.requestType === 1 /* RequestType.DEFENSE */)
                log += `room: ${r.roomName}, priority: ${r.priority}<br/>`;
            else if (r.requestType === 2 /* RequestType.ATTACK */)
                log += `room: ${r.roomName}, priority: ${r.priority}, playerName: ${r.playerName}<br/>`;
            //else if (r.requestType === RequestType.EXECUTE)
            //  requestListStr += 'priority: ' + r.priority + '<br/>';
            else if (r.requestType === 4 /* RequestType.HATE */)
                log += `playerName: ${r.playerName}, priority: ${r.priority}<br/>`;
            else if (r.requestType === 5 /* RequestType.FUNNEL */)
                log += `roomName: ${r.roomName}, maxAmount: ${r.maxAmount}, goalType: ${r.goalType}, timeout: ${r.timeout}<br/>`;
        }
    }
    else {
        log += rawRequests;
    }
    console.log(log);
}
class AllyManager {
    checkAllies(callback) {
        let allies = [...Config.ALLIES];
        let currentAllyName = allies[Game.time % Config.ALLIES.size];
        if (this.allyRequests === undefined) {
            if (RawMemory.foreignSegment && RawMemory.foreignSegment.username === currentAllyName) {
                try {
                    this.allyRequests = JSON.parse(RawMemory.foreignSegment.data);
                }
                catch (_a) {
                    console.log('failed to parse', currentAllyName, 'request segment');
                    this.allyRequests = null;
                }
                if (Memory.toggles.swcCooperationLog) {
                    logRequests(currentAllyName, this.allyRequests, RawMemory.foreignSegment.data);
                }
            }
            else {
                this.allyRequests = null;
                //console.log("Simple allies either has no segment or has the wrong name?");
            }
        }
        if (this.allyRequests) {
            for (let request of this.allyRequests) {
                callback(request);
            }
        }
        let nextAllyName = allies[(Game.time + 1) % Config.ALLIES.size];
        RawMemory.setActiveForeignSegment(nextAllyName, Config.segments.swcSimpleProtocol);
    }
    // Call before making any requests
    startOfTick() {
        this.requestArray = [];
        this.allyRequests = undefined;
    }
    // Call after making all your requests
    endOfTick() {
        SegmentManager.setSegment(Config.segments.swcSimpleProtocol, this.requestArray);
        RawMemory.setPublicSegments([Config.segments.swcSimpleProtocol]);
    }
    // Priority is unbounded. It's up to you and your allies to sort out what you want it to mean
    requestHelp(roomName, priority) {
        this.requestArray.push({
            requestType: 1 /* RequestType.DEFENSE */,
            roomName: roomName,
            priority: priority || 0
        });
    }
    requestResource(roomName, resourceType, priority) {
        this.requestArray.push({
            requestType: 0 /* RequestType.RESOURCE */,
            resourceType: resourceType,
            roomName: roomName,
            priority: priority || 0
        });
    }
}
const simpleAllies = new AllyManager();

class OperationIdle {
    constructor() {
        this.creepNames = [];
    }
    registerUnownedCreeps() {
        let ownedCreeps = new Set([]);
        let recursiveFind = function (o) {
            if (!_.isObject(o) && !_.isArray(o))
                return;
            for (let p in o) {
                if (!o[p])
                    continue;
                if (p === 'creeps') {
                    for (let creepName of o[p])
                        ownedCreeps.add(creepName);
                }
                else {
                    recursiveFind(o[p]);
                }
            }
        };
        for (let roomName in Memory.myRooms)
            recursiveFind(Memory.myRooms[roomName]);
        for (let flagName in Memory.flags)
            recursiveFind(Memory.flags[flagName]);
        for (let key in Memory.operations)
            recursiveFind(Memory.operations[key]);
        //
        this.creepNames = [];
        for (let creepName in Game.creeps)
            if (!ownedCreeps.has(creepName)) {
                console.log(creepName, 'picked up by operationIdle');
                let creep = Game.creeps[creepName];
                let creepMemory = creep.memory;
                if (creepMemory.recycle === undefined || creepMemory.repurpose === undefined) {
                    creep.memory = {
                        recycle: true,
                        repurpose: true
                    };
                }
                this.creepNames.push(creepName);
            }
    }
    initForTick() {
        this.hirableCreeps = [];
        this.recyclableCreeps = [];
        this.creepNames = this.creepNames.filter(name => {
            let creep = Game.creeps[name];
            if (!creep)
                return false;
            let creepMemory = creep.memory;
            if (creepMemory.repurpose)
                this.hirableCreeps.push(creep);
            if (creepMemory.recycle)
                this.recyclableCreeps.push(creep);
            return (creepMemory.repurpose || creepMemory.recycle);
        });
    }
    addCreep(creep, recycle, repurpose) {
        creep.memory = {
            recycle: recycle,
            repurpose: repurpose
        };
        this.creepNames.push(creep.name);
    }
    hireCreeps(spawnRequests) {
        this.hirableCreeps = this.hirableCreeps.filter(creep => {
            let bestRequest = undefined;
            for (let request of spawnRequests) {
                if (request.noRepurpose)
                    continue;
                // already found a better job
                if (bestRequest && request.priority < bestRequest.priority)
                    continue;
                let requestedBodyMove = request.parts[MOVE];
                let creepBodyMove = _.sum(creep.body, bp => bp.type === MOVE ? 1 : 0);
                // too immobile
                if (requestedBodyMove / request.parts.parts.length > creepBodyMove / creep.body.length)
                    continue;
                // too far
                // TODO - use intel room distance
                let distance = Game.map.getRoomLinearDistance(request.operation.roomName, creep.pos.roomName);
                if (!_.isFinite(distance)) {
                    console.log('Non finite distance:', distance, 'request.operation.roomName:', request.operation.roomName, 'creep.pos.roomName:', creep.pos.roomName);
                    continue;
                }
                if (distance > 2)
                    continue;
                // body compatibility
                // TODO - some decent criteria
                if (_.some(BODYPARTS_ALL, partType => _.sum(creep.body, bp => bp.type === partType ? 1 : 0) < request.parts[partType] / 2))
                    continue;
                bestRequest = request;
            }
            if (bestRequest) {
                bestRequest.operation.onSpawn(bestRequest.id, creep.name);
                creep.memory = bestRequest.memory;
                _.remove(this.recyclableCreeps, creep);
                _.remove(this.creepNames, creep.name);
                _.remove(spawnRequests, bestRequest);
                return false;
            }
            else {
                return true;
            }
        });
    }
    run(myRooms) {
        const say = {
            0: '',
            1: '\u{274C}',
            2: '\u{231B}',
            3: '\u{274C}\u{231B}'
        };
        for (let creepName of this.creepNames) {
            let creep = Game.creeps[creepName];
            let creepMemory = creep.memory;
            creep.say(say[(creepMemory.recycle ? 1 : 0) + (creepMemory.repurpose ? 2 : 0)], false);
            creep.giveWay();
            if (creep.hits < creep.hitsMax && creep.getActiveBodyparts(HEAL))
                creep.heal(creep);
            if (creep.getActiveBodyparts(RANGED_ATTACK))
                creep.shootAtWill(creep.room.findHostileCreeps());
            if (creep.getActiveBodyparts(ATTACK)) {
                let inMeleeRange = creep.room.findHostileCreeps().find(h => h.pos.isNearTo(creep.pos));
                if (inMeleeRange)
                    creep.attack(inMeleeRange);
            }
        }
        for (let creep of this.recyclableCreeps) {
            let creepMemory = creep.memory;
            if (!creepMemory.recycleRoom) {
                let myClosestRoom = _.min(myRooms, mr => Game.map.getRoomLinearDistance(mr.roomName, creep.pos.roomName));
                if (myClosestRoom)
                    creepMemory.recycleRoom = myClosestRoom.roomName;
            }
            if (!creepMemory.recycleRoom)
                continue;
            // might happen on reset
            if (!Game.rooms[creepMemory.recycleRoom])
                continue;
            let recycleRoom = Game.rooms[creepMemory.recycleRoom].myRoom;
            if (!recycleRoom) {
                creepMemory.recycleRoom = undefined;
                continue;
            }
            let containerPos = recycleRoom.layout.roomPlan.core[8].container[0];
            let recycleSpawn = recycleRoom.layout.roomPlan.core[8].spawn[0].lookFor(LOOK_STRUCTURES).find(s => s.structureType === STRUCTURE_SPAWN);
            if (creep.ticksToLive < CREEP_LIFE_TIME * LAB_UNBOOST_MINERAL / LAB_BOOST_MINERAL && creep.body.find(b => !!b.boost) && recycleRoom.requestUnboost(creep)) {
                let labContainerPos = recycleRoom.layout.roomPlan.core[8].container[1];
                if (creep.pos.isEqualTo(labContainerPos)) {
                    let unboostLab = creep.pos.lookInRange(LOOK_STRUCTURES, 1).find(s => s.structureType === STRUCTURE_LAB && s.cooldown === 0);
                    if (unboostLab)
                        unboostLab.unboostCreep(creep);
                    creep.giveWay();
                }
                else
                    creep.goTo(labContainerPos, 0, { ensurePath: true });
            }
            else if (creep.pos.isEqualTo(containerPos)) {
                if (recycleSpawn)
                    recycleSpawn.recycleCreep(creep);
                else
                    creep.suicide();
            }
            else
                creep.goTo(containerPos, 0, { ensurePath: true });
        }
    }
}

class Balancer {
    constructor(empire) {
        this.id = "Balancer";
        this.empire = empire;
    }
    assignGlobalOperationToRoom(operation, myRoom) {
        operation.assignSpawnRoom(myRoom.roomName);
        if (operation.hasEnoughResources(myRoom)) {
            myRoom.globalOperations.push(operation);
            let operationStats = operation.getEstimatedStats();
            if (operation.isClosing) {
                return {
                    cpu: operationStats.cpu,
                    energyPerTick: 0,
                    spawnTime: 0
                };
            }
            else {
                return {
                    cpu: operationStats.cpu,
                    energyPerTick: operationStats.energyPerTick,
                    spawnTime: operationStats.spawnTime * myRoom.spawnTimeMultiplier
                };
            }
        }
        else {
            return {
                cpu: 0,
                energyPerTick: 0,
                spawnTime: 0
            };
        }
    }
    findBestSpawnRoom(operation, myRooms, availableSpawnTime) {
        if (!operation.roomName)
            return undefined;
        let bestCandidates = [
            { room: undefined, score: -Infinity, distance: Infinity },
            { room: undefined, score: -Infinity, distance: Infinity },
            { room: undefined, score: -Infinity, distance: Infinity },
            { room: undefined, score: -Infinity, distance: Infinity }
        ];
        let operationStats = operation.getEstimatedStats();
        let useSpawnTimeMultiplier = Config.operateSpawnOperations.includes(operation.constructor.name);
        for (let myRoom of myRooms) {
            if (myRoom.roomName === operation.roomName)
                continue;
            if (availableSpawnTime[myRoom.roomName] < operationStats.spawnTime * (useSpawnTimeMultiplier ? myRoom.spawnTimeMultiplier : 1))
                continue;
            if (myRoom.room.memory.invasion && (myRoom.room.memory.invasion.rangedAttack > 0 || myRoom.room.memory.invasion.meleeAttack > 0) && !myRoom.room.controller.safeMode)
                continue;
            if (myRoom.room.find(FIND_MY_SPAWNS).length === 0)
                continue;
            if (myRoom.room.find(FIND_FLAGS).find(f => f.name.startsWith('NoGlobalOperations')))
                continue;
            if (!operation.isValidSpawnRoom(myRoom))
                continue;
            const distance = Game.map.getRoomLinearDistance(myRoom.roomName, operation.roomName) * 50;
            let worstBestCandidate = _.max(bestCandidates, bc => bc.score);
            if (distance < worstBestCandidate.distance) {
                worstBestCandidate.room = myRoom;
                worstBestCandidate.distance = distance;
            }
        }
        const routeOpts = {
            avoidHostileRooms: true,
            avoidUnsafeRooms: false
        };
        let bestScore = -Infinity;
        let bestRoom = undefined;
        bestCandidates.sort((a, b) => a.distance - b.distance);
        for (let candidate of bestCandidates) {
            if (!candidate.room)
                continue;
            let route = Pather.findRoute(candidate.room.roomName, operation.roomName, routeOpts);
            let distance = route.length * 50;
            const spawnTimeAvailable = availableSpawnTime[candidate.room.roomName];
            const score = spawnTimeAvailable - distance;
            if (score > bestScore) {
                bestScore = score;
                bestRoom = candidate.room;
            }
        }
        return bestRoom;
    }
    getUsableOutposts(myRooms) {
        let outposts = [];
        for (let myRoom of myRooms) {
            if (myRoom.room.controller.level < 2)
                continue;
            //const ticksTillAbandon = myRoom.room.controller.level > 4 && myRoom.room.controller.safeMode ? 100 : 1500;
            for (let outpost of myRoom.outposts) {
                if (!outpost.isActive)
                    outpost.updateCpuUsage();
                const roomIntel = GIntel.rooms[outpost.roomName];
                // can't spawn keeperSlayers
                if (outpost.isSkRoom && myRoom.room.energyCapacityAvailable < OperationSKClear.keeperSlayerBody.cost)
                    continue;
                //
                if (roomIntel.usedByAlly)
                    continue;
                if (roomIntel.owner)
                    continue;
                let myRoomStatus = Game.map.getRoomStatus(myRoom.roomName).status;
                if (outpost.pathRooms.some(p => {
                    const pathRoomIntel = GIntel.rooms[p];
                    if (!pathRoomIntel)
                        return true;
                    // TODO - dealing with harassed rooms
                    //if (pathRoomIntel.lastSafe < pathRoomIntel.lastScout - ticksTillAbandon)
                    //  return true;
                    // owned
                    if (pathRoomIntel.owner && !pathRoomIntel.isMy)
                        return true;
                    // reserved by ally
                    if (pathRoomIntel.reservation && Config.WHITELIST.has(pathRoomIntel.reservation.username))
                        return true;
                    // separated by respawn/novice zone walls
                    if (Game.map.getRoomStatus(p).status !== myRoomStatus)
                        return true;
                    // manually excluded
                    if (_.some(Game.flags, flag => flag.pos.roomName === p && flag.name.startsWith('NoRemote')))
                        return true;
                    return false;
                }))
                    continue;
                outposts.push(outpost);
            }
        }
        return outposts;
    }
    resetOperations(myRoom, mineMode, rebalanceLog) {
        let resourcesUsed = {
            spawnTime: 0,
            energyPerTick: 0,
            cpu: myRoom.estimatedCpuUsage
        };
        // activate in room mines
        for (let mine of myRoom.inRoomMines) {
            mine.activate(mineMode, mine.sourceRoomIndex);
        }
        // reset scaling operations to their minimum scaling value
        for (let operation of myRoom.operations) {
            operation.resetTargetScale();
            let stats = operation.getEstimatedStats();
            let currentSpendingScale = operation.targetScale;
            if (!_.isFinite(currentSpendingScale) || !_.isFinite(stats.energyPerTick) || !_.isFinite(stats.spawnTime) || !_.isFinite(stats.cpu)) {
                console.log(myRoom.roomName, 'non finite scale - initial operations');
                console.log(operation.constructor.name, JSON.stringify(stats), 'scale:', JSON.stringify(resourcesUsed));
                continue;
            }
            if (Memory.toggles.logRebalance) {
                rebalanceLog.value += `${myRoom.roomName} initial cost of ${operation.constructor.name}: e/t ${currentSpendingScale * stats.energyPerTick}, spawnTime ${currentSpendingScale * stats.spawnTime}, cpu ${currentSpendingScale === 0 ? 0 : stats.cpu}<br/>`;
            }
            resourcesUsed.energyPerTick += currentSpendingScale * stats.energyPerTick;
            resourcesUsed.spawnTime += currentSpendingScale * stats.spawnTime;
            resourcesUsed.cpu += currentSpendingScale === 0 ? 0 : stats.cpu;
        }
        for (let outpost of myRoom.activeOutposts) {
            if (outpost.isActive)
                outpost.deactivate();
        }
        myRoom.activeOutposts = [];
        return resourcesUsed;
    }
    activateOutpost(myRoom, outpost, mineMode, spawnTime, cpu, rebalanceLog) {
        let resourcesUsed = {
            spawnTime: 0,
            energyPerTick: 0,
            cpu: 0
        };
        // workaround for updating creep compositions when mine mode changed
        outpost.activate(mineMode, myRoom.activeOutposts.length);
        outpost.deactivate();
        //
        let outpostStats = outpost.getEstimatedStats();
        if (myRoom.abandon) {
            rebalanceLog.value += myRoom.roomName + ' not activating ' + outpost.roomName + ' outpost - main room being abanconed<br/>';
            rebalanceLog.value += 'would use ' + outpostStats.spawnTime + ' spawn time and ' + outpostStats.cpu + ' cpu, and gain ' + outpostStats.energyPerTick + ' e/T<br/>';
            return resourcesUsed;
        }
        if (outpostStats.spawnTime > spawnTime || outpostStats.cpu > cpu) {
            rebalanceLog.value += myRoom.roomName + ' not activating ' + outpost.roomName + ' outpost<br/>';
            rebalanceLog.value += 'would use ' + outpostStats.spawnTime + ' spawn time and ' + outpostStats.cpu + ' cpu, and gain ' + outpostStats.energyPerTick + ' e/T<br/>';
            return resourcesUsed;
        }
        else {
            rebalanceLog.value += myRoom.roomName + ' activating ' + outpost.roomName + ' outpost<br/>';
            rebalanceLog.value += 'used ' + outpostStats.spawnTime + ' spawn time and ' + outpostStats.cpu + ' cpu, and gained ' + outpostStats.energyPerTick + ' e/T<br/>';
            outpost.activate(mineMode, myRoom.activeOutposts.length);
            myRoom.activeOutposts.push(outpost);
            if (outpost.isWorking())
                resourcesUsed.energyPerTick += outpostStats.energyPerTick;
            resourcesUsed.spawnTime += outpostStats.spawnTime;
            resourcesUsed.cpu += outpostStats.cpu;
            if (outpost.operationPeacekeeping) {
                let peacekeeepingStats = outpost.operationPeacekeeping.getEstimatedStats();
                resourcesUsed.energyPerTick += peacekeeepingStats.energyPerTick;
                resourcesUsed.spawnTime += peacekeeepingStats.spawnTime;
                resourcesUsed.cpu += peacekeeepingStats.cpu;
            }
            return resourcesUsed;
        }
    }
    scaleSpending(myRoom, energyPerTick, spawnTime, cpu, rebalanceLog) {
        let resourcesUsed = {
            spawnTime: 0,
            energyPerTick: 0,
            cpu: 0
        };
        if (Memory.toggles.logRebalance) {
            rebalanceLog.value += myRoom.roomName + ' scaling spending<br/>';
        }
        // increase spending
        for (let spending of myRoom.spendingOperations) {
            let currentSpendingScale = spending.targetScale;
            if (currentSpendingScale === spending.getMaximumScale())
                continue;
            let stats = spending.getEstimatedStats();
            if (stats.energyPerTick === 0)
                continue;
            // TODO - cpu estimate is based on amount of creeps, scaling changes amount of creeps. It's a mess
            let statsCpu = (spending instanceof OperationUpgrade || spending instanceof OperationBuild)
                ? stats.cpu / Math.max(spending.memory.creeps.length, 1)
                : stats.cpu;
            //
            let scaleEnergyCapped = currentSpendingScale + (energyPerTick / -stats.energyPerTick);
            let scaleSpawnTimeCapped = currentSpendingScale + (spawnTime / stats.spawnTime);
            let scaleCPUCapped = currentSpendingScale + (statsCpu ? cpu / statsCpu : spending.getMaximumScale());
            if (!_.isFinite(currentSpendingScale) || !_.isFinite(stats.energyPerTick) || !_.isFinite(stats.spawnTime) || !_.isFinite(statsCpu)) {
                console.log(myRoom.roomName, 'non finite scale', '<br/>', spending.constructor.name, scaleEnergyCapped, scaleSpawnTimeCapped, scaleCPUCapped, '<br/>energyCapacityAvailable: ' + myRoom.room.energyCapacityAvailable);
                continue;
            }
            let scale = Math.clamp(Math.min(scaleEnergyCapped, scaleSpawnTimeCapped, scaleCPUCapped), spending.getMinimumScale(), spending.getMaximumScale());
            // console.log(spending.constructor.name, scaleEnergyCapped, scaleSpawnTimeCapped, scaleCPUCapped, scale);
            // console.log(JSON.stringify(resourcesAvailable));
            if (scale > currentSpendingScale) {
                spending.setTargetScale(scale);
                let scaleChange = scale - currentSpendingScale;
                resourcesUsed.energyPerTick += scaleChange * stats.energyPerTick;
                resourcesUsed.spawnTime += scaleChange * stats.spawnTime;
                resourcesUsed.cpu += (scale - currentSpendingScale) * statsCpu;
            }
            // capped by cpu or spawn time - return
            if (scale < spending.getMaximumScale()) {
                if (Memory.toggles.logRebalance) {
                    const cappedBy = scale === scaleSpawnTimeCapped
                        ? 'spawn time'
                        : scale === scaleCPUCapped
                            ? 'cpu'
                            : 'energy';
                    rebalanceLog.value += myRoom.roomName + ' capped by ' + cappedBy
                        + '<br/>' + 'scaleEnergyCapped: ' + scaleEnergyCapped + ', scaleSpawnTimeCapped: ' + scaleSpawnTimeCapped + ', scaleCpuCapped: ' + scaleCPUCapped
                        + '<br/>' + 'leave condition: ' + spending.constructor.name + ' ' + scale + ' < ' + spending.getMaximumScale()
                        + '<br/>';
                }
                break;
            }
        }
        return resourcesUsed;
    }
    rebalanceRoomOperations() {
        let rebalanceLog = { value: '' };
        const targetSpawnUsage = 0.9;
        const myRooms = this.empire.myRooms;
        const globalOperations = this.empire.globalOperations;
        let cpuPerRoom = Game.cpu.limit / myRooms.length;
        let targetMineMode = cpuPerRoom > 10 && !Memory.toggles.forceCpuSaving
            ? 0 /* MineMode.SPAWN_TIME */
            : cpuPerRoom > 5
                ? 1 /* MineMode.CPU */
                : 2 /* MineMode.HIGH_CPU */;
        let cpu = Game.cpu.limit - Memory.empireRunCpu - Memory.intelRunCpu - Memory.nonTickCpu;
        let roomEnergyPerTick = {};
        let spawnTime = {};
        rebalanceLog.value += 'resourcesAvialable: cpu - ' + cpu + '<br/>';
        // reset room operation scales
        for (let myRoom of myRooms) {
            roomEnergyPerTick[myRoom.roomName] = (myRoom.getEnergyAmount() - myRoom.getTargetBank()) / (myRoom.room.storage ? 1000 : 100);
            spawnTime[myRoom.roomName] = myRoom.layout.spawns.length * CREEP_LIFE_TIME * targetSpawnUsage;
            const mineMode = myRoom.room.controller.level < 7 ? 0 /* MineMode.SPAWN_TIME */ : targetMineMode;
            let resourcesUsed = this.resetOperations(myRoom, mineMode, rebalanceLog);
            roomEnergyPerTick[myRoom.roomName] += resourcesUsed.energyPerTick;
            spawnTime[myRoom.roomName] -= resourcesUsed.spawnTime;
            cpu -= resourcesUsed.cpu;
            if (Memory.toggles.logRebalance) {
                rebalanceLog.value += 'resetting ' + myRoom.roomName + '<br/>';
                rebalanceLog.value += 'resourcesAvialable: e/T - ' + roomEnergyPerTick[myRoom.roomName] + ', spawnTime - ' + spawnTime[myRoom.roomName] + ', cpu - ' + cpu + '<br/>';
            }
            resourcesUsed = this.scaleSpending(myRoom, roomEnergyPerTick[myRoom.roomName], spawnTime[myRoom.roomName], cpu, rebalanceLog);
            roomEnergyPerTick[myRoom.roomName] += resourcesUsed.energyPerTick;
            spawnTime[myRoom.roomName] -= resourcesUsed.spawnTime;
            cpu -= resourcesUsed.cpu;
            if (Memory.toggles.logRebalance) {
                rebalanceLog.value += 'initial scaling ' + myRoom.roomName + '<br/>';
                rebalanceLog.value += 'resourcesAvialable: e/T - ' + roomEnergyPerTick[myRoom.roomName] + ', spawnTime - ' + spawnTime[myRoom.roomName] + ', cpu - ' + cpu + '<br/>';
            }
        }
        //
        for (let myRoom of myRooms)
            myRoom.globalOperations = [];
        // apply already assigned global operation costs
        for (let operationId in globalOperations) {
            let operation = globalOperations[operationId];
            if (!operation.readyToDelete && operation.spawnRoomName && myRooms.some(mr => mr.roomName === operation.spawnRoomName)) {
                let spawnRoomName = operation.spawnRoomName;
                let myRoom = myRooms.find(mr => mr.roomName === spawnRoomName);
                let operationStats = this.assignGlobalOperationToRoom(operation, myRoom);
                roomEnergyPerTick[spawnRoomName] -= operationStats.energyPerTick;
                spawnTime[spawnRoomName] -= operationStats.spawnTime;
                cpu -= operationStats.cpu;
                if (Memory.toggles.logRebalance) {
                    rebalanceLog.value += 'activating ' + operationId + ' at ' + spawnRoomName + '<br/>';
                    rebalanceLog.value += 'resourcesAvialable: e/T - ' + roomEnergyPerTick[spawnRoomName] + ', spawnTime - ' + spawnTime[spawnRoomName] + ', cpu - ' + cpu + '<br/>';
                }
            }
        }
        // assign global operations to rooms and apply costs
        for (let operationId in globalOperations) {
            let operation = globalOperations[operationId];
            if (!operation.readyToDelete && !operation.spawnRoomName) {
                let bestRoom = this.findBestSpawnRoom(operation, myRooms, spawnTime);
                if (bestRoom) {
                    let spawnRoomName = bestRoom.roomName;
                    let myRoom = myRooms.find(mr => mr.roomName === spawnRoomName);
                    let operationStats = this.assignGlobalOperationToRoom(operation, myRoom);
                    roomEnergyPerTick[spawnRoomName] -= operationStats.energyPerTick;
                    spawnTime[spawnRoomName] -= operationStats.spawnTime;
                    cpu -= operationStats.cpu;
                    if (Memory.toggles.logRebalance) {
                        rebalanceLog.value += 'activating ' + operationId + ' at ' + spawnRoomName + '<br/>';
                        rebalanceLog.value += 'resourcesAvialable: e/T - ' + roomEnergyPerTick[spawnRoomName] + ', spawnTime - ' + spawnTime[spawnRoomName] + ', cpu - ' + cpu + '<br/>';
                    }
                }
            }
        }
        // add outpost, scale room operations up, repeat until run out of cpu or spawn time
        let outposts = this.getUsableOutposts(myRooms);
        outposts.sort((a, b) => {
            const resourcesA = a.getEstimatedStats();
            const resourcesB = b.getEstimatedStats();
            const valueA = a.getGeneratedValue();
            const valueB = b.getGeneratedValue();
            const divideA = targetMineMode === 0 /* MineMode.SPAWN_TIME */ ? resourcesA.spawnTime : resourcesA.baseCpu;
            const divideB = targetMineMode === 0 /* MineMode.SPAWN_TIME */ ? resourcesB.spawnTime : resourcesB.baseCpu;
            if (valueA && valueB && valueA !== valueB)
                return (valueB / divideB) - (valueA / divideA);
            else
                return (resourcesB.energyPerTick / divideB) - (resourcesA.energyPerTick / divideA);
        });
        let roomsFinishedActivatingOutposts = new Set(); // prevent rooms from picking worse outposts
        let usedOutposts = new Set();
        for (let outpostIndex = 0; outpostIndex < outposts.length && cpu > 0; ++outpostIndex) {
            let outpost = outposts[outpostIndex];
            let myRoom = outpost.parentRoom;
            if (spawnTime[myRoom.roomName] <= 0)
                continue;
            if (roomsFinishedActivatingOutposts.has(myRoom.roomName))
                continue;
            if (usedOutposts.has(outpost.roomName))
                continue;
            const mineMode = myRoom.room.controller.level < 7 ? 0 /* MineMode.SPAWN_TIME */ : targetMineMode;
            let resourcesUsed = this.activateOutpost(myRoom, outpost, mineMode, spawnTime[myRoom.roomName], cpu, rebalanceLog);
            roomEnergyPerTick[myRoom.roomName] += resourcesUsed.energyPerTick;
            spawnTime[myRoom.roomName] -= resourcesUsed.spawnTime;
            cpu -= resourcesUsed.cpu;
            if (resourcesUsed.cpu > 0) {
                if (Memory.toggles.logRebalance) {
                    rebalanceLog.value += 'resourcesAvialable: e/T - ' + roomEnergyPerTick[myRoom.roomName] + ', spawnTime - ' + spawnTime[myRoom.roomName] + ', cpu - ' + cpu + '<br/>';
                }
                resourcesUsed = this.scaleSpending(myRoom, roomEnergyPerTick[myRoom.roomName], spawnTime[myRoom.roomName], cpu, rebalanceLog);
                roomEnergyPerTick[myRoom.roomName] += resourcesUsed.energyPerTick;
                spawnTime[myRoom.roomName] -= resourcesUsed.spawnTime;
                cpu -= resourcesUsed.cpu;
                if (Memory.toggles.logRebalance && resourcesUsed.cpu > 0) {
                    rebalanceLog.value += 'resourcesAvialable: e/T - ' + roomEnergyPerTick[myRoom.roomName] + ', spawnTime - ' + spawnTime[myRoom.roomName] + ', cpu - ' + cpu + '<br/>';
                }
                usedOutposts.add(outpost.roomName);
            }
            else {
                roomsFinishedActivatingOutposts.add(myRoom.roomName);
            }
        }
        //
        for (let myRoom of myRooms) {
            for (let outpost of myRoom.outposts)
                if (!outpost.isActive && outpost.hasAnyLivingCreeps())
                    myRoom.activeOutposts.push(outpost);
        }
        //
        if (Memory.toggles.logRebalance)
            console.log(rebalanceLog.value);
    }
    *run() {
        let lastRebalance = 0;
        while (true) {
            if (this.empire.areRoomsLoaded && Game.time - lastRebalance > 30) {
                this.rebalanceRoomOperations();
                lastRebalance = Game.time;
            }
            yield EThreadStatus.FinishedTick;
        }
    }
}
__decorate([
    profile()
], Balancer.prototype, "rebalanceRoomOperations", null);

class Empire {
    constructor() {
        this.id = 'Empire';
        this.rebalanceThread = null;
        this.myRooms = [];
        this.roomsToLoad = [];
        this.thingsToLoad = [
            OperationHarassResults
        ];
        this.market = new Market();
        this.strategist = new Strategist(this);
        this.idle = new OperationIdle();
        this.intershardMemory = {};
        this.info = {
            totalRoomCount: 0,
            totalShardRoomCount: 0
        };
    }
    get resourceValue() {
        return this.market.resourceValue;
    }
    get globalOperations() {
        return this.strategist.globalOperations;
    }
    *loadMyRooms() {
        // clear myRooms that aren't
        let claimFlagRooms = _(Game.flags)
            .filter((f) => f.name.startsWith('Claim'))
            .map(f => f.pos.roomName)
            .value();
        for (let roomName in Memory.myRooms) {
            let room = Game.rooms[roomName];
            if ((!room || !room.controller.my) && !claimFlagRooms.includes(roomName)) {
                if (Memory.myRooms[roomName].layoutSegmentId) {
                    let clearSegmentResult = SegmentManager.clearSegment(Memory.myRooms[roomName].layoutSegmentId);
                    if (clearSegmentResult)
                        delete Memory.myRooms[roomName];
                }
            }
        }
        //
        let myClaimedRooms = _(Memory.myRooms)
            .keys()
            .filter(roomName => Game.rooms[roomName] && Game.rooms[roomName].controller.my)
            .value();
        if (this.roomsToLoad.length === 0 && myClaimedRooms.length !== this.myRooms.length) {
            this.roomsToLoad = myClaimedRooms;
            this.myRooms = [];
        }
        if (this.roomsToLoad.length > 0) {
            for (let roomName of this.roomsToLoad) {
                let result;
                let segmentId = Memory.myRooms[roomName].layoutSegmentId;
                if (segmentId !== undefined && SegmentManager.getSegment(segmentId)) {
                    errGuard(() => {
                        result = new MyRoom(this, roomName);
                    });
                }
                if (result)
                    this.myRooms.push(result);
                yield EThreadStatus.Ready;
            }
            this.roomsToLoad = this.roomsToLoad.filter(roomName => !this.myRooms.find(room => room.roomName === roomName));
            if (this.roomsToLoad.length === 0) {
                this.info.totalShardRoomCount = this.myRooms.length;
                this.idle.registerUnownedCreeps();
            }
        }
        yield EThreadStatus.Ready;
    }
    reloadRoom(roomName) {
        for (let i = 0; i < this.myRooms.length; ++i) {
            let room = this.myRooms[i];
            if (room.roomName === roomName) {
                let segmentId = Memory.myRooms[roomName].layoutSegmentId;
                if (segmentId !== undefined) {
                    this.myRooms[i] = new MyRoom(this, roomName);
                    return true;
                }
            }
        }
        return false;
    }
    get areRoomsLoaded() {
        return this.roomsToLoad.length === 0;
    }
    updateIntershardData() {
        try {
            let allShards = [...Memory.shards];
            for (let shardName of Memory.shards) {
                if (shardName === Game.shard.name)
                    continue;
                let intershardData = InterShardMemory.getRemote(shardName);
                if (!intershardData)
                    continue;
                try {
                    let data = JSON.parse(intershardData);
                    this.intershardMemory[shardName] = data;
                }
                catch (e) {
                    console.log("Couldn't parse " + shardName + "Memory");
                    continue;
                }
                allShards.push(...this.intershardMemory[shardName].knownShards);
            }
            Memory.shards = _.uniq(allShards);
            this.info.totalRoomCount = this.info.totalShardRoomCount + _.sum(this.intershardMemory, ism => ism.myRooms);
            //console.log(Memory.shards);
            let shardMemory = {
                lastWrite: Date.now(),
                knownShards: Memory.shards,
                myRooms: this.myRooms.length
            };
            InterShardMemory.setLocal(JSON.stringify(shardMemory));
        }
        catch (e) {
            // on private server there is apparently no IntershardMemory and it throws error even on if (!IntershardMemory)
        }
    }
    // ---------------------------------------------------------------------
    swcCooperation() {
        simpleAllies.startOfTick();
        const sendThreshold = {
            [RESOURCE_ENERGY]: Memory.toggles.swcAllowFunnel ? 150000 : 300000,
            default: 12000
        };
        const requestThreshold = {
            [RESOURCE_ENERGY]: 100000,
            default: 3000
        };
        const requestAmount = {
            [RESOURCE_ENERGY]: 10000,
            default: 3000
        };
        let requests = [];
        let funnelFlags = _.filter(Game.flags, f => f.name.startsWith('Funnel'));
        // request resources on behalf of allies
        let funnelFlagInAlliedRoom = funnelFlags.find(f => Config.ALLIES.has(GIntel.rooms[f.pos.roomName].owner));
        if (funnelFlagInAlliedRoom) {
            requests.push({
                requestType: 0 /* RequestType.RESOURCE */,
                resourceType: RESOURCE_ENERGY,
                maxAmount: 10000,
                priority: 0.9,
                roomName: funnelFlagInAlliedRoom.pos.roomName
            });
        }
        // legacy, flag controlled funnel request
        let funnelFlagInMyRoom = funnelFlags.find(f => GIntel.rooms[f.pos.roomName].isMy);
        let funnelRcl = funnelFlagInMyRoom && funnelFlagInMyRoom.color;
        if (funnelFlagInMyRoom) {
            const myRoom = this.myRooms.find(mr => mr.roomName === funnelFlagInMyRoom.pos.roomName);
            const energyInRoom = myRoom.getStoredResource(RES_ENERGY);
            if (myRoom.room.controller.level < funnelRcl
                && energyInRoom < 600000
                && myRoom.room.terminal
                && myRoom.room.storage
                && !myRoom.evacResources) {
                requests.push({
                    requestType: 0 /* RequestType.RESOURCE */,
                    resourceType: RESOURCE_ENERGY,
                    maxAmount: Math.min(myRoom.room.storage.store.getFreeCapacity(), myRoom.room.terminal.store.getFreeCapacity()),
                    priority: 0.9,
                    roomName: myRoom.roomName
                });
            }
        }
        // request funneling
        let bestGclRoomCandidates = this.myRooms.filter(mr => !mr.evacResources && mr.room.terminal);
        if (bestGclRoomCandidates.length > 0) {
            const bestGclRoom = _.min(bestGclRoomCandidates, mr => mr.room.controller.progressTotal - mr.room.controller.progress);
            requests.push({
                requestType: 5 /* RequestType.FUNNEL */,
                roomName: bestGclRoom.roomName,
                goalType: 0 /* FunnelGoal.GCL */,
                maxAmount: Game.gcl.progressTotal - Game.gcl.progress,
                timeout: Game.time + 100
            });
        }
        let bestRclRoomCandidates = bestGclRoomCandidates.filter(mr => mr.room.controller.level >= 6 && mr.room.controller.level < 8);
        if (bestRclRoomCandidates.length > 0) {
            const bestRclRoom = _.min(bestRclRoomCandidates, mr => mr.room.controller.progressTotal - mr.room.controller.progress);
            requests.push({
                requestType: 5 /* RequestType.FUNNEL */,
                roomName: bestRclRoom.roomName,
                goalType: bestRclRoom.room.controller.level === 6 ? 1 /* FunnelGoal.RCL7 */ : 2 /* FunnelGoal.RCL8 */,
                maxAmount: bestRclRoom.room.controller.progressTotal - bestRclRoom.room.controller.progress,
                timeout: Game.time + 100
            });
        }
        // request resources from allies
        const ignoredResources = [
            RESOURCE_METAL,
            RESOURCE_BIOMASS,
            RESOURCE_SILICON,
            RESOURCE_MIST,
            RESOURCE_POWER,
            RESOURCE_OPS
        ];
        let resourcesNeeded = {};
        const someSafemode = _.some(this.myRooms, mr => !!mr.room.controller.safeMode);
        for (let key in Config.TARGET_STOCK) {
            let resourceType = key;
            if (ignoredResources.includes(resourceType))
                continue;
            for (let mr of this.myRooms) {
                if (mr.room.terminal && mr.room.storage && !mr.evacResources) {
                    let resourceInRoom = (mr.room.terminal.store[resourceType] || 0) + (mr.room.storage.store[resourceType] || 0);
                    if (resourceInRoom < (requestThreshold[resourceType] || requestThreshold.default)) {
                        if (resourceType === RES_ENERGY) {
                            let canSafemode = !someSafemode && mr.room.controller.safeModeAvailable > 0 && !mr.room.controller.safeModeCooldown;
                            requests.push({
                                requestType: 0 /* RequestType.RESOURCE */,
                                resourceType: resourceType,
                                maxAmount: requestAmount[RES_ENERGY] || requestAmount.default,
                                priority: mr.room.memory.invasion
                                    ? canSafemode
                                        ? 0.85
                                        : 1
                                    : 0,
                                roomName: mr.roomName
                            });
                        }
                        else {
                            resourcesNeeded[resourceType] = resourcesNeeded[resourceType] || 0;
                            resourcesNeeded[resourceType] += requestAmount[resourceType] || requestAmount.default;
                        }
                    }
                }
            }
        }
        let resourceDistributionRoom = _(this.myRooms)
            .filter(mr => mr.room.terminal && mr.room.terminal.store.getFreeCapacity() >= 50000 && !mr.evacResources)
            .max(mr => mr.getEnergyAmount());
        if (resourceDistributionRoom) {
            for (let key in resourcesNeeded) {
                let resourceType = key;
                requests.push({
                    requestType: 0 /* RequestType.RESOURCE */,
                    resourceType: resourceType,
                    maxAmount: requestAmount[RES_ENERGY] || requestAmount.default,
                    priority: 0.25,
                    roomName: resourceDistributionRoom.roomName
                });
            }
        }
        for (let mr of this.myRooms) {
            let spawnInRoom = mr.room.find(FIND_MY_SPAWNS);
            let energyInRoom = (mr.room.terminal && mr.room.terminal.store[RESOURCE_ENERGY] || 0) + (mr.room.storage && mr.room.storage.store[RESOURCE_ENERGY] || 0);
            let helpFlag = mr.room.find(FIND_FLAGS).find(f => f.name.startsWith('Help'));
            let realInvasion = !!mr.room.memory.invasion && mr.room.memory.invasion.heal * HEAL_POWER > mr.layout.towers.length * 150;
            if (spawnInRoom.length > 0 && realInvasion && helpFlag && (energyInRoom < (requestThreshold[RESOURCE_ENERGY] || requestThreshold.default) || helpFlag.color === COLOR_RED)) {
                requests.push({
                    requestType: 1 /* RequestType.DEFENSE */,
                    roomName: mr.roomName,
                    priority: 0.85
                });
            }
        }
        SegmentManager.setSegment(Config.segments.swcSimpleProtocol, requests);
        RawMemory.setPublicSegments([Config.segments.swcSimpleProtocol]);
        // send resources to allies
        let roomsThatSent = new Set();
        const requestCb = (request) => {
            if (request.requestType === 0 /* RequestType.RESOURCE */) {
                if (request.resourceType === RESOURCE_ENERGY && request.priority < 0.9)
                    return;
                let sendMinAmount = 1000;
                let sendAmount = (request.resourceType === RESOURCE_ENERGY
                    ? request.priority === 1
                        ? Infinity
                        : 5000
                    : 1000);
                let funnellingToMyRoom = funnelFlags.some(f => !!this.myRooms.find(mr => mr.layout.terminal && mr.roomName === f.pos.roomName));
                if (request.resourceType === RESOURCE_ENERGY && request.priority < 1 && funnellingToMyRoom)
                    return;
                let areRoomsStocked = this.myRooms.every(mr => {
                    let terminal = Game.rooms[mr.roomName].terminal;
                    let storage = Game.rooms[mr.roomName].storage;
                    if (!terminal || !storage)
                        return true;
                    return mr.getStoredResource(request.resourceType) >= (sendThreshold[request.resourceType] || sendThreshold.default) - Market.sendFilter[request.resourceType];
                });
                let roomThatCan = this.myRooms.find(mr => {
                    if (roomsThatSent.has(mr.roomName))
                        return false;
                    let terminal = Game.rooms[mr.roomName].terminal;
                    let storage = Game.rooms[mr.roomName].storage;
                    if (!terminal || !storage)
                        return false;
                    if (terminal.cooldown)
                        return false;
                    if ((terminal.store[request.resourceType] || 0) < sendMinAmount)
                        return false;
                    let resourceSendThreshold = (request.resourceType === RESOURCE_ENERGY && request.priority < 0.8
                        ? mr.getTargetBank() + Config.TARGET_STOCK.energy.terminal
                        : (sendThreshold[request.resourceType] || sendThreshold.default));
                    if (mr.getStoredResource(request.resourceType) < resourceSendThreshold)
                        return false;
                    return true;
                });
                if (areRoomsStocked && roomThatCan) {
                    if (request.resourceType === RESOURCE_ENERGY) {
                        sendAmount = Math.min(sendAmount, request.maxAmount || 0, Math.floor(Game.rooms[roomThatCan.roomName].terminal.store[RESOURCE_ENERGY] / 2));
                    }
                    if (sendAmount > 0) {
                        let sendResult = Game.rooms[roomThatCan.roomName].terminal.send(request.resourceType, sendAmount, request.roomName);
                        if (sendResult === OK) {
                            roomsThatSent.add(roomThatCan.roomName);
                            console.log(roomThatCan.roomName, 'sending', sendAmount, request.resourceType, 'to', request.roomName, '(priority: ' + request.priority + ')');
                        }
                    }
                }
            }
            else if (request.requestType === 5 /* RequestType.FUNNEL */) ;
        };
        if (funnelFlagInAlliedRoom) {
            requestCb({
                requestType: 0 /* RequestType.RESOURCE */,
                resourceType: RESOURCE_ENERGY,
                maxAmount: 10000,
                priority: 0.9,
                roomName: funnelFlagInAlliedRoom.pos.roomName
            });
        }
        simpleAllies.checkAllies(requestCb);
    }
    // ---------------------------------------------------------------------
    getStoredResource(resourceType) {
        return _.sum(this.myRooms, mr => mr.getStoredResource(resourceType));
    }
    // ---------------------------------------------------------------------
    updateNextGclEstimate() {
        const updateFrequency = 400;
        if (!Memory.nextGclEstimate) {
            Memory.nextGclEstimate = {
                lastProgress: Game.gcl.progress,
                finishTimePrediction: Infinity,
                nextCheck: Game.time
            };
        }
        if (Game.time < Memory.nextGclEstimate.nextCheck)
            return;
        const progresSinceLastCheck = Game.gcl.progress - Memory.nextGclEstimate.lastProgress;
        const ticksTillFinish = (Game.gcl.progressTotal - Game.gcl.progress) / (progresSinceLastCheck / updateFrequency);
        const timeTillFinish = ticksTillFinish * Common.getTickDuration();
        Memory.nextGclEstimate.finishTimePrediction = Date.now() + Math.ceil(timeTillFinish);
        Memory.nextGclEstimate.lastProgress = Game.gcl.progress;
        Memory.nextGclEstimate.nextCheck = Game.time + updateFrequency;
    }
    showStatus() {
        Visual.addText(undefined, 'Empire', 'GCL: ' + Game.gcl.level);
        Visual.addText(undefined, 'Empire', 'GCL progress: ' + (100 * Game.gcl.progress / Game.gcl.progressTotal).toFixed(2) + '%');
        let nextGclTimeEstimate = Memory.nextGclEstimate.finishTimePrediction - Date.now();
        Visual.addText(undefined, 'Empire', 'next GCL estimate: '
            + (_.isFinite(nextGclTimeEstimate) && nextGclTimeEstimate > 0
                ? Math.floor(nextGclTimeEstimate / (1000 * 60 * 60 * 24)) + 'd '
                    + Math.floor((nextGclTimeEstimate % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)) + 'h '
                    + Math.floor((nextGclTimeEstimate % (1000 * 60 * 60)) / (1000 * 60)) + 'm'
                    + ' (' + (Memory.nextGclEstimate.nextCheck - Game.time) + ')'
                : '- (' + (Memory.nextGclEstimate.nextCheck - Game.time) + ')'));
        Visual.addText(undefined, 'Empire', 'Rooms: ' + (this.myRooms.length + _.sum(this.intershardMemory, ism => ism.myRooms)));
        Visual.addText(undefined, 'Empire', 'Rooms on ' + Game.shard.name + ': ' + this.myRooms.length);
        Visual.addText(undefined, 'Empire', 'Creeps: ' + _.size(Game.creeps));
        Visual.addText(undefined, 'Empire', 'Lab uptime: ' + (_.sum(this.myRooms, mr => 100 * mr.memory.stats.labUptime || 0) / _.sum(this.myRooms, mr => mr.memory.stats.labUptime !== undefined ? 1 : 0)).toFixed(2) + '%');
        //
        let incomingNukes = _(this.myRooms)
            .filter(mr => mr.room.find(FIND_NUKES).length > 0)
            .map(mr => '  x' + mr.room.find(FIND_NUKES).length + ' in ' + mr.roomName)
            .value();
        Visual.addText(undefined, 'War manager', 'Incoming nukes: ' + (incomingNukes.length === 0 ? 'None' : ''));
        for (let nuke of incomingNukes)
            Visual.addText(undefined, 'War manager', nuke);
        //
        let attacksOnMe = _(this.myRooms)
            .filter(mr => mr.room.memory.invasion)
            .map(mr => '  ' + mr.room.memory.invasion.owner + ' in ' + mr.roomName)
            .value();
        Visual.addText(undefined, 'War manager', 'Defending: ' + (attacksOnMe.length === 0 ? 'None' : ''));
        for (let attack of attacksOnMe)
            Visual.addText(undefined, 'War manager', attack);
        //
        this.strategist.showStatus();
        for (let mr of this.myRooms) {
            if (Memory.visibleRooms[mr.roomName]) {
                Visual.addText(mr.roomName, mr.roomName, 'Lab uptime: ' + (100 * mr.memory.stats.labUptime).toFixed(2) + '%');
                Visual.addText(mr.roomName, mr.roomName, 'Spawn uptime: ' + (100 * mr.memory.stats.spawnUptime).toFixed(2) + '%');
                Visual.addText(mr.roomName, mr.roomName, 'RCL progress: ' + (mr.room.controller.level === 8 ? '-' : (Math.floor((mr.room.controller.progress / mr.room.controller.progressTotal) * 100) + '%')));
                let nextRclTimeEstimate = mr.memory.upgrade.finishTimePrediction - Date.now();
                Visual.addText(mr.roomName, mr.roomName, 'next RCL estimate: '
                    + (_.isFinite(nextRclTimeEstimate) && nextRclTimeEstimate > 0
                        ? Math.floor(nextRclTimeEstimate / (1000 * 60 * 60 * 24)) + 'd '
                            + Math.floor((nextRclTimeEstimate % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)) + 'h '
                            + Math.floor((nextRclTimeEstimate % (1000 * 60 * 60)) / (1000 * 60)) + 'm'
                            + ' (' + (mr.memory.upgrade.nextCheck - Game.time) + ')'
                        : '-'));
                if (mr.room.controller.safeMode) {
                    let safemodeEndEstimate = mr.room.controller.safeMode * Common.getTickDuration();
                    Visual.addText(mr.roomName, mr.roomName, 'safemode end estimate: '
                        + Math.floor(safemodeEndEstimate / (1000 * 60 * 60 * 24)) + 'd '
                        + Math.floor((safemodeEndEstimate % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)) + 'h '
                        + Math.floor((safemodeEndEstimate % (1000 * 60 * 60)) / (1000 * 60)) + 'm');
                }
                if (mr.room.controller.safeModeCooldown) {
                    let nextSafemodeEstimate = mr.room.controller.safeModeCooldown * Common.getTickDuration();
                    Visual.addText(mr.roomName, mr.roomName, 'safemode available in: '
                        + Math.floor(nextSafemodeEstimate / (1000 * 60 * 60 * 24)) + 'd '
                        + Math.floor((nextSafemodeEstimate % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)) + 'h '
                        + Math.floor((nextSafemodeEstimate % (1000 * 60 * 60)) / (1000 * 60)) + 'm');
                }
                Visual.addText(mr.roomName, mr.roomName, 'Scaling:');
                for (let operation of mr.spendingOperations)
                    Visual.addText(mr.roomName, mr.roomName, '  ' + operation.constructor.name + ': ' + operation.targetScale.toFixed(2));
            }
            if (Memory.visibleRooms[mr.roomName])
                Visual.addText(mr.roomName, mr.roomName, 'Active outposts:');
            for (let outpost of mr.activeOutposts) {
                const outpostStatus = (!outpost.isActive ? '\u{1F6D1}' : outpost.isWorking() ? '\u{26CF}\u{FE0F}' : '\u{23F3}');
                Visual.addMapText(outpost.roomName, mr.roomName + ' (' + outpost.index + ') ' + outpostStatus);
                Visual.addText(mr.roomName, mr.roomName, outpostStatus + ' ' + outpost.roomName);
            }
            for (let outpost of mr.outposts) {
                if (Memory.visibleRooms[outpost.roomName]) {
                    Visual.addText(outpost.roomName, mr.roomName + 'outpost', 'estimated cpu: ' + outpost.getEstimatedStats().cpu);
                    Visual.addText(outpost.roomName, mr.roomName + 'outpost', 'estimated value: ' + outpost.lastValueEstimate);
                }
            }
        }
        for (let id in this.strategist.globalOperations) {
            let go = this.strategist.globalOperations[id];
            if (go.spawnRoomName)
                Visual.addText(go.spawnRoomName, 'Assigned Global Operations', `${id}${go.isClosing ? ' (closing)' : ''}`);
            if (!go.readyToDelete)
                Visual.addText(go.roomName, 'Global Operations', `${id}${go.isClosing ? ' (closing)' : ''}`);
        }
        for (let roomName in GIntel.rooms) {
            const roomIntel = GIntel.rooms[roomName];
            if (roomIntel.hostiles.length > 0)
                Visual.addMapText(roomName, '\u{1F620} x ' + roomIntel.hostiles.length);
            if (Memory.toggles.visualAttackableRooms)
                if (Treaties.canBeAttacked(roomName))
                    Visual.addMapText(roomIntel.roomName, 'attackable', { color: '#ff4444' });
            if (Memory.visibleRooms[roomName]) {
                if (roomIntel.usedByAlly) {
                    Visual.addText(roomName, 'Politics', 'Used by ally: ' + roomIntel.usedByAlly.username);
                    Visual.addText(roomName, 'Politics', 'times out in ' + (roomIntel.usedByAlly.expires - Game.time) + ' ticks');
                }
            }
        }
        Visual.run();
    }
    clearDeadCreepsMemory() {
        for (const name in Memory.creeps)
            if (!(name in Game.creeps))
                delete Memory.creeps[name];
        for (let flagName in Memory.flags)
            if (!Game.flags[flagName])
                delete Memory.flags[flagName];
    }
    observeFlag() {
        for (let flagName in Game.flags) {
            if (flagName.toLowerCase().startsWith('observe')) {
                let observerRoom = _.sample(GEmpire.myRooms.filter(mr => mr.layout.observer && Game.map.getRoomLinearDistance(mr.roomName, Game.flags[flagName].pos.roomName) <= OBSERVER_RANGE));
                if (observerRoom)
                    observerRoom.layout.observer.observeRoom(Game.flags[flagName].pos.roomName);
            }
        }
    }
    *run() {
        while (true) {
            let startCpu = Game.cpu.getUsed();
            const roomLoaderGen = this.loadMyRooms();
            while (!roomLoaderGen.next().done)
                yield EThreadStatus.Ready;
            this.thingsToLoad = this.thingsToLoad.filter(entry => !entry.load());
            // init for tick
            let skipCpuStart = Game.cpu.getUsed();
            for (let myRoom of this.myRooms)
                myRoom.initForTick();
            for (let operationId in this.strategist.globalOperations) {
                errGuard(() => {
                    let operation = this.strategist.globalOperations[operationId];
                    if (!operation.readyToDelete)
                        operation.initForTick();
                });
            }
            let skipCpu = Game.cpu.getUsed() - skipCpuStart;
            //
            this.idle.initForTick();
            //
            if (!this.rebalanceThread)
                this.rebalanceThread = GKernel.createThread(Balancer, this);
            // run
            skipCpuStart = Game.cpu.getUsed();
            if (!TickSkipper.skipRooms)
                for (let myRoom of this.myRooms)
                    myRoom.run();
            for (let operationId in this.strategist.globalOperations) {
                errGuard(() => {
                    let operation = this.strategist.globalOperations[operationId];
                    if (!operation.readyToDelete)
                        operation.run();
                });
            }
            skipCpu += Game.cpu.getUsed() - skipCpuStart;
            //
            if (this.areRoomsLoaded) {
                this.strategist.run(this.myRooms);
                this.idle.run(this.myRooms);
                this.market.run(this.myRooms);
                if (Memory.toggles.swcCooperation)
                    this.swcCooperation();
                this.updateIntershardData();
            }
            //
            this.updateNextGclEstimate();
            if (Memory.toggles && Memory.toggles.visual)
                this.showStatus();
            //
            this.clearDeadCreepsMemory();
            //
            this.observeFlag();
            const tickCpu = Game.cpu.getUsed() - startCpu - skipCpu;
            const rollingPeriod = 1000;
            Memory.empireRunCpu = ((Memory.empireRunCpu || 0) * (rollingPeriod - 1) + tickCpu) / rollingPeriod;
            Stats.registerOperationCpu(this.constructor.name, tickCpu, Memory.empireRunCpu, 0);
            Memory.nonTickCpu = ((Memory.nonTickCpu || 0) * (rollingPeriod - 1) + Profiler.nonTickCpu) / rollingPeriod;
            Stats.registerOperationCpu('nonTickCpu', Profiler.nonTickCpu, Memory.nonTickCpu, 0);
            yield EThreadStatus.FinishedTick;
        }
    }
}
__decorate([
    check,
    profile()
], Empire.prototype, "showStatus", null);
__decorate([
    check,
    profile()
], Empire.prototype, "run", null);

class Kernel {
    constructor() {
        this.threads = [];
    }
    createThread(ctor, ...args) {
        let thread = new ctor(...args);
        this.threads.push({
            instance: thread,
            gen: thread.run()
        });
        return thread;
    }
    run() {
        for (let thread of this.threads) {
            try {
                let threadStatus = EThreadStatus.Ready;
                do {
                    threadStatus = thread.gen.next().value;
                } while (threadStatus === EThreadStatus.Ready && Game.cpu.getUsed() < 480);
            }
            catch (err) {
                console.log('<font color="#ff5555" type="highlight">', `thread ${thread.instance.id} threw an error:<br/>`, (err
                    ? err instanceof Error
                        ? err.stack
                        : err
                    : 'unknown error'), '</font>');
                if (err instanceof TypeError) {
                    thread.gen = thread.instance.run();
                }
            }
        }
    }
}

class MeasureTool {
    static get startFlag() {
        return Game.flags['MTStart'];
    }
    static get finishFlag() {
        return Game.flags['MTFinish'];
    }
    static run() {
        if (this.startFlag && this.finishFlag) {
            if (!this.path
                || !this.startFlag.pos.isEqualTo(this.path[0])
                || !this.finishFlag.pos.isEqualTo(_.last(this.path)) && this.isComplete) {
                const pfResult = Pather.findPath(this.startFlag.pos, { pos: this.finishFlag.pos, range: 0 }, { offroad: true, avoidUnsafeRooms: true, ensurePath: true, avoidSourceKeepers: true, avoidHostileRooms: true });
                this.isComplete = !pfResult.incomplete;
                this.path = [this.startFlag.pos, ...pfResult.path];
            }
        }
        else {
            this.path = null;
        }
        if (this.path) {
            for (let flag of [this.startFlag, this.finishFlag]) {
                const visual = new RoomVisual(flag.pos.roomName);
                visual.text(`Distance: ${!this.isComplete ? 'Incomplete' : this.path.length}`, flag.pos.x, flag.pos.y);
            }
            Game.map.visual.poly(this.path, { fill: undefined, lineStyle: "solid", opacity: 1, stroke: '#ffffff', strokeWidth: 0.5 });
        }
    }
}
MeasureTool.isComplete = false;
MeasureTool.path = null;

global.GKernel = new Kernel;
global.GIntel = new Intel;
global.common = Common;
global.cd = CombatData;
function reinjectClientAbuse() {
    global.forceInjectScreepsBrowserCore();
    global.forceInjectBirthday();
    global.forceInjectRoomTracker();
    global.forceInjectMapTracker();
}
global.reinjectClientAbuse = reinjectClientAbuse;
class InitAfterRespawn {
    constructor() {
        this.id = 'InitAfterRespawn';
    }
    *run() {
        //console.log('hasRespawned:', hasRespawned(), '!Memory.myRooms:', !Memory.myRooms, 'global.lp.saving:', global.lp.saving);
        // clear
        const clearSegmentsGen = SegmentManager.clearSegments();
        while (!clearSegmentsGen.next().done)
            yield EThreadStatus.FinishedTick;
        for (let f in Game.flags)
            Game.flags[f].remove();
        for (let entry in Memory)
            delete Memory[entry];
        RawMemory.set('');
        console.log('Initialization');
        // init memory
        let defaults = {
            rooms: {},
            creeps: {},
            powerCreeps: {},
            flags: {},
            spawns: {},
            //
            myRooms: {},
            //
            intelRunCpu: 0,
            empireRunCpu: 0,
            nonTickCpu: 0,
            toggles: Config.defaultToggles,
            //
            tickDuration: {
                value: 0,
                timestamp: Date.now(),
                tickstamp: Game.time
            },
            //
            market: {
                lastIncomingTransaction: '',
                lastOutgoingTransaction: '',
                lastPricesUpdate: 0,
                bannedTransactions: {},
                expectedTransactions: [],
                buyPricesMax: {},
                sellPricesMin: {},
                buyAvg: {},
                sellAvg: {},
                value: {},
                stddev: {},
                lastHistoryCheck: 0
            },
            //
            nextGclEstimate: {
                nextCheck: Game.time,
                finishTimePrediction: Infinity,
                lastProgress: Game.gcl.progress
            },
            //
            operations: {},
            strategies: {},
            treaties: {},
            shards: [Game.shard.name],
            respawnTick: Game.time,
            //
            visibleRooms: {}
        };
        _.defaultsDeep(Memory, defaults);
        //
        global.GIntel = new Intel;
        global.GEmpire = new Empire;
        //
        GIntel.run();
        const roomName = _.find(Game.structures).pos.roomName;
        let plan = new Future();
        GKernel.createThread(RoomPlanner, roomName, _.find(Game.spawns), null, plan);
        while (!plan.resolved)
            yield EThreadStatus.FinishedTick;
        let createRoomResult = new Future();
        GKernel.createThread(RoomCreateTask, roomName, plan.value, createRoomResult);
        while (!createRoomResult.resolved)
            yield EThreadStatus.FinishedTick;
        return EThreadStatus.Finished;
    }
}
function updateTickrate() {
    if (Game.time - Memory.tickDuration.tickstamp >= 300) {
        Memory.tickDuration.value = (Date.now() - Memory.tickDuration.timestamp) / (Game.time - Memory.tickDuration.tickstamp);
        Memory.tickDuration.timestamp = Date.now();
        Memory.tickDuration.tickstamp = Game.time;
    }
}
console.log('global reset');
let loadSegmentsGen = SegmentManager.loadSegments();
global.GEmpire = GKernel.createThread(Empire);
const loop = memoryCacheWrapLoop(() => {
    errGuard(() => {
        // prevent console spam when some creeps accidentaly steps into a portal. TODO - Also stops auto spawn placement
        //if (_.size(Game.spawns) === 0 && _.size(Game.flags) === 0)
        //  return;
        updateRoomVisibility();
        if (loadSegmentsGen && loadSegmentsGen.next().done)
            loadSegmentsGen = undefined;
        if (Game.time % 1000 === 0)
            reinjectClientAbuse();
        SegmentManager.preTick();
        Stats.preTick();
        Profiler.preTick();
        Treaties.preTick();
        TickSkipper.update();
        if (!TickSkipper.skipTick) {
            Visual.preTick();
            Pather.preTick();
            CostMatrixCache.preTick();
            CombatData.preTick();
            if (hasRespawned())
                GKernel.createThread(InitAfterRespawn);
            else {
                GIntel.run();
                GCreepBodyCache.run();
                GKernel.run();
                updateTickrate();
            }
            CombatData.postTick();
            CostMatrixCache.postTick();
            Pather.postTick();
            PatherDebug.draw();
        }
        MeasureTool.run();
        RoomPlannerTestTool.run();
        Profiler.postTick();
        Stats.postTick();
        SegmentManager.postTick();
    });
});

exports.loop = loop;
